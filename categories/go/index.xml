<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on Ramblings of a build engineer</title>
    <link>https://skarlso.github.io/categories/go/</link>
    <description>Recent content in Go on Ramblings of a build engineer</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 02 Nov 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://skarlso.github.io/categories/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>How to do Google Sign-In with Go - Part 2</title>
      <link>https://skarlso.github.io/2016/11/02/google-signin-with-go-part2/</link>
      <pubDate>Wed, 02 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/11/02/google-signin-with-go-part2/</guid>
      <description>Intro Hi Folks.
This is a follow up on my previous post about Google Sign-In. In this post we will discover what to do with the information retrieved in the first encounter, which you can find here: Google Sign-In Part 1.
Forewords The Project Everything I did in the first post, and that I&amp;rsquo;m going to do in this example, can be found in this project: Google-OAuth-Go-Sample.
Just to recap, we left off previously on the point where we successfully obtained information about the user, with a secure token and a session initiated with them.</description>
    </item>
    
    <item>
      <title>Always Go with []byte</title>
      <link>https://skarlso.github.io/2016/08/19/always-go-with-bytes/</link>
      <pubDate>Fri, 19 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/08/19/always-go-with-bytes/</guid>
      <description>Another quick reminder&amp;hellip; Always go with []byte if possible. I said it before, and I&amp;rsquo;m going to say it over and over again. It&amp;rsquo;s crucial.
Here is a little code from exercism.io. First, with strings:
package igpay import ( &amp;quot;strings&amp;quot; ) // PigLatin translates reguler old English into awesome pig-latin. func PigLatin(in string) (ret string) { for _, v := range strings.Fields(in) { ret += pigLatin(v) + &amp;quot; &amp;quot; } return strings.</description>
    </item>
    
    <item>
      <title>Global variable for never changing regex</title>
      <link>https://skarlso.github.io/2016/08/16/never-changing-regex/</link>
      <pubDate>Tue, 16 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/08/16/never-changing-regex/</guid>
      <description>Quick reminder. If you have a never changing regex in Go, do NOT put it into a frequently called function. ALWAYS put it into a global variable. I&amp;rsquo;ll show you why.
Benchmark for code with a variable in a frequently called function:
BenchmarkNumber-8 30000	41633 ns/op BenchmarkAreaCode-8 50000	27736 ns/op BenchmarkFormat-8 50000	29263 ns/op PASS ok _/phone-number	5.110s  Benchmark for code with the same variable outside in a global scope:</description>
    </item>
    
    <item>
      <title>How to do Google sign-in with Go</title>
      <link>https://skarlso.github.io/2016/06/12/google-signin-with-go/</link>
      <pubDate>Sun, 12 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/06/12/google-signin-with-go/</guid>
      <description>&lt;p&gt;Hi folks.&lt;/p&gt;

&lt;p&gt;Today, I would like to write up a step - by - step guide with a sample web app on how to do Google Sign-In and authorization.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Wercker Fixed</title>
      <link>https://skarlso.github.io/2016/03/09/wercker-fixed/</link>
      <pubDate>Wed, 09 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/03/09/wercker-fixed/</guid>
      <description>Hi Folks.
So Wercker was not working. After a minor modification it seems to be okay now. The config file needed for it to work looks like this:
box: golang build: steps: - arjen/hugo-build: theme: redlounge deploy: steps: - install-packages: packages: git - leipert/git-push: gh_oauth: $GIT_TOKEN repo: skarlso/skarlso.github.io branch: master basedir: public  The modification is the box type to golang and removed ssh-client from packages.
Thanks, Gergely.</description>
    </item>
    
    <item>
      <title>Wercker Test</title>
      <link>https://skarlso.github.io/2016/03/04/wercker-test-2/</link>
      <pubDate>Fri, 04 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/03/04/wercker-test-2/</guid>
      <description>Basics This is a wercker Test.</description>
    </item>
    
    <item>
      <title>Wercker Test</title>
      <link>https://skarlso.github.io/2016/02/10/wercker-test/</link>
      <pubDate>Wed, 10 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/02/10/wercker-test/</guid>
      <description>Basics This is a wercker Test.</description>
    </item>
    
    <item>
      <title>Doing CORS in Go with Gin and JSON</title>
      <link>https://skarlso.github.io/2016/02/02/doing-cors-in-go-with-gin-and-json/</link>
      <pubDate>Tue, 02 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/02/02/doing-cors-in-go-with-gin-and-json/</guid>
      <description>Basics Hello folks.
This will be a quick post about how to do CORS with jQuery, Gin in Go with a very simple ajax GET and Json.
I&amp;rsquo;m choosing JSON here because basically I don&amp;rsquo;t really like JSONP. And actually, it&amp;rsquo;s not very complicated to do CORS, it&amp;rsquo;s just hidden enough so that it doesn&amp;rsquo;t become transparent.
First, what is CORS? It&amp;rsquo;s Cross-Platform Resource Sharing. It has been invented so that without your explicit authorization in the header of a request, Javascript can&amp;rsquo;t reach outside of your domain and be potentially harmful to your visitors.</description>
    </item>
    
    <item>
      <title>My Journey in advent of code</title>
      <link>https://skarlso.github.io/2016/01/22/my-journey-in-advent-of-code/</link>
      <pubDate>Fri, 22 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/01/22/my-journey-in-advent-of-code/</guid>
      <description>Hello folks.
I wanted to share with you my tale of working through the problems with Advent Of Code.
It is a nice tale and there are a few things I learned from it, especially in Go, since I used that solve all of the problems. So, let&amp;rsquo;s get started.
Solving the problems The most important lesson I learned while doing these exercises was, how to solve these problems. A couple of them were simple enough to not have to over think it, but most of them got very tricky.</description>
    </item>
    
    <item>
      <title>Improving performance with byte slice and int map</title>
      <link>https://skarlso.github.io/2016/01/05/improving-performance-with-byte-slice-and-int-map/</link>
      <pubDate>Tue, 05 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/01/05/improving-performance-with-byte-slice-and-int-map/</guid>
      <description>Hello Folks.
Today I would like to share with you my little tale of refactoring my solution to Advent Of Code Day 13.
It&amp;rsquo;s a lovely tale of action, adventure, drama, and comedy.
Let&amp;rsquo;s being with my first iteration of the problem.
package main import ( &amp;quot;bufio&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;math&amp;quot; &amp;quot;os&amp;quot; &amp;quot;strconv&amp;quot; &amp;quot;strings&amp;quot; &amp;quot;github.com/skarlso/goutils/arrayutils&amp;quot; ) var seatingCombinations = make([][]string, 0) var table = make(map[string][]map[string]int) var keys = make([]string, 0) //Person a person type Person struct { // neighbour *Person name string like int } func main() { file, _ := os.</description>
    </item>
    
    <item>
      <title>Byte arrays and Channels</title>
      <link>https://skarlso.github.io/2016/01/01/byte-arrays-and-channels/</link>
      <pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/01/01/byte-arrays-and-channels/</guid>
      <description>Hi folks and a Happy new Year!
Today, I would like to show you some interesting things you can do with channels. Consider the following simple example.
package main import &amp;quot;fmt&amp;quot; func main() { generatedPassword := make(chan int, 100) correctPassword := make(chan int) defer close(generatedPassword) defer close(correctPassword) go passwordIncrement(generatedPassword) go checkPassword(generatedPassword, correctPassword) pass := &amp;lt;-correctPassword fmt.Println(pass) } func checkPassword(input &amp;lt;-chan int, output chan&amp;lt;- int) { for { p := &amp;lt;-input //Introduce lengthy operation here // time.</description>
    </item>
    
    <item>
      <title>Use Byte Array Instead of Strings</title>
      <link>https://skarlso.github.io/2015/12/29/use-byte-array-instead-of-strings/</link>
      <pubDate>Tue, 29 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2015/12/29/use-byte-array-instead-of-strings/</guid>
      <description>Hello Folks.
This is just a quick post on the topic and a reminder for myself and everybody to ALWAYS USE []BYTE INSTEAD OF STRINGS.
[]Byte is marginally faster than a simple Strings. In fact, I would say using []byte should be the standard instead of strings.
Sample code:
package solutions import &amp;quot;fmt&amp;quot; const ( //INPUT input INPUT = &amp;quot;1321131112&amp;quot; //LIMIT limit LIMIT = 50 ) //LookAndSay translates numbers according to Look and Say algo func LookAndSay(s string, c chan string) { charCount := 1 look := &amp;quot;&amp;quot; for i := range s { if i+1 &amp;lt; len(s) { if s[i] == s[i+1] { charCount++ } else { look += fmt.</description>
    </item>
    
    <item>
      <title>Use Byte Slice Instead of Strings</title>
      <link>https://skarlso.github.io/2015/12/29/use-byte-slice-instead-of-strings/</link>
      <pubDate>Tue, 29 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2015/12/29/use-byte-slice-instead-of-strings/</guid>
      <description>Hello Folks.
This is just a quick post on the topic and a reminder for myself and everybody to ALWAYS USE []BYTE INSTEAD OF STRINGS.
[]Byte is marginally faster than a simple Strings. In fact, I would say using []byte should be the standard instead of strings.
Sample code:
package solutions import &amp;quot;fmt&amp;quot; const ( //INPUT input INPUT = &amp;quot;1321131112&amp;quot; //LIMIT limit LIMIT = 50 ) //LookAndSay translates numbers according to Look and Say algo func LookAndSay(s string, c chan string) { charCount := 1 look := &amp;quot;&amp;quot; for i := range s { if i+1 &amp;lt; len(s) { if s[i] == s[i+1] { charCount++ } else { look += fmt.</description>
    </item>
    
    <item>
      <title>Recursive Letter Frequency Count</title>
      <link>https://skarlso.github.io/2015/12/23/recursive-freq-count/</link>
      <pubDate>Wed, 23 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2015/12/23/recursive-freq-count/</guid>
      <description>Hello everybody!
I wanted to do a sort post about word frequency count. I did it many times now and I was curious as how a recursive solution would perform as opposed to looping.
So I wrote it up quickly and added a few benchmarks with different sized data.
First&amp;hellip;. The code:
var freqMap = make(map[string]int, 0) func countLettersRecursive(s string) string { if len(s) == 0 { return s } freqMap[string(s[0])]++ return countLettersRecursive(s[1:]) } func countLettersLoop(s string) { for _, v := range s { freqMap[string(v)]++ } }  Very simple.</description>
    </item>
    
    <item>
      <title>Go Development Environment</title>
      <link>https://skarlso.github.io/2015/12/08/go-development-environment/</link>
      <pubDate>Tue, 08 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2015/12/08/go-development-environment/</guid>
      <description>Hello folks.
Here is a little something I&amp;rsquo;ve put together, since I&amp;rsquo;m doing it a lot.
Go Development Environment
If I have a project I&amp;rsquo;d like to contribute, like GoHugo, I have to setup a development environment, because most of the times, I&amp;rsquo;m on a Mac. And on OSX things work differently. I like to work in a Linux environment since that&amp;rsquo;s what most of the projects are built on.</description>
    </item>
    
    <item>
      <title>Go JIRA API client</title>
      <link>https://skarlso.github.io/2015/11/20/go-jira-api-client/</link>
      <pubDate>Fri, 20 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2015/11/20/go-jira-api-client/</guid>
      <description>Hi folks.
So, I was playing around and created a client for JIRA written in Go. It was nice to do some JSON transformation. And sending POSTS was really trivial.
It&amp;#8217;s still in it&amp;#8217;s infancy and I have a couple of more features I want to implement, but, here is the code&amp;#8230;
  package main &amp;nbsp; import ( &#34;bytes&#34; &#34;encoding/json&#34; &#34;flag&#34; &#34;fmt&#34; &#34;io/ioutil&#34; &#34;log&#34; &#34;net/http&#34; &#34;os&#34; &amp;nbsp; &#34;github.com/BurntSushi/toml&#34; ) &amp;nbsp; var configFile = &#34;</description>
    </item>
    
    <item>
      <title>Go Progress Quest</title>
      <link>https://skarlso.github.io/2015/11/09/go-progress-quest/</link>
      <pubDate>Mon, 09 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2015/11/09/go-progress-quest/</guid>
      <description>Hi Folks.
I started to build a Progress Quest type of web app in Go.
If you&amp;#8217;d like to join, or just tag along, please drop by here =&amp;gt; Go Progress Quest and feel free to submit an issue if you have an idea, or would like to contribute!
I will try and document the Progress&amp;#8230;
Thank you for reading!
Gergely.</description>
    </item>
    
    <item>
      <title>Circular buffer in Go</title>
      <link>https://skarlso.github.io/2015/10/15/circular-buffer-in-go/</link>
      <pubDate>Thu, 15 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2015/10/15/circular-buffer-in-go/</guid>
      <description>I&amp;#8217;m proud of this one too. No peaking. I like how go let&amp;#8217;s you do this kind of stuff in a very nice way.
  package circular &amp;nbsp; import &#34;fmt&#34; &amp;nbsp; //TestVersion testVersion const TestVersion = 1 &amp;nbsp; //Buffer buffer type type Buffer struct { buffer []byte full int size int s, e int } &amp;nbsp; //NewBuffer creates a new Buffer func NewBuffer(size int) *Buffer { return &amp;Buffer{buffer: make([]byte, size), s: , e: , size: size, full: } } &amp;nbsp; //ReadByte reads a byte from b Buffer func (b *Buffer) ReadByte() (byte, error) { if b.</description>
    </item>
    
    <item>
      <title>DataMunger Kata with Go</title>
      <link>https://skarlso.github.io/2015/10/04/datamunger-kata-with-go/</link>
      <pubDate>Sun, 04 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2015/10/04/datamunger-kata-with-go/</guid>
      <description>Quickly wrote up the Data Munger code kata in Go.
Next time, I want better abstractions. And a way to select columns based on their header data. For now, this is not bad.
  package main &amp;nbsp; import ( &#34;bufio&#34; &#34;fmt&#34; &#34;log&#34; &#34;math&#34; &#34;os&#34; &#34;regexp&#34; &#34;strconv&#34; &#34;strings&#34; ) &amp;nbsp; //Data which is Data type Data struct { columnName string compareOne float64 compareTwo float64 } &amp;nbsp; func main() { // datas := []Data{WeatherData{}, FootballData{}} fmt.</description>
    </item>
    
    <item>
      <title>Sieve of Eratosthenes in Go</title>
      <link>https://skarlso.github.io/2015/07/30/sieve-of-eratosthenes-in-go/</link>
      <pubDate>Thu, 30 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2015/07/30/sieve-of-eratosthenes-in-go/</guid>
      <description>I&amp;#8217;m pretty proud of this one as well.
  package sieve &amp;nbsp; //Sieve Uses the Sieve of Eratosthenes to calculate primes to a certain limit func Sieve(limit int) []int { var listOfPrimes []int markers := make([]bool, limit) &amp;nbsp; for i := 2; i &amp;lt; limit; i++ { if !markers[i] { for j := i + i; j &amp;lt; limit; j += i { markers[j] = true } listOfPrimes = append(listOfPrimes, i) } } &amp;nbsp; return listOfPrimes }     </description>
    </item>
    
  </channel>
</rss>