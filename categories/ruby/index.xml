<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ruby on Ramblings of a build engineer</title>
    <link>https://skarlso.github.io/categories/ruby/</link>
    <description>Recent content in Ruby on Ramblings of a build engineer</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 06 Oct 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://skarlso.github.io/categories/ruby/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>RScrap scraper</title>
      <link>https://skarlso.github.io/2016/10/06/rscrap-ruby-scraping-with-cronjob-scripts</link>
      <pubDate>Thu, 06 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/10/06/rscrap-ruby-scraping-with-cronjob-scripts</guid>
      <description>

&lt;h1 id=&#34;intro:3859b786e5fbfbb427877ae525b50427&#34;&gt;Intro&lt;/h1&gt;

&lt;p&gt;Hey folks.&lt;/p&gt;

&lt;p&gt;So, there is this project called &lt;a href=&#34;https://github.com/cantino/huginn&#34;&gt;Huginn&lt;/a&gt; which I absolutely love.&lt;/p&gt;

&lt;p&gt;But the thing is, that for a couple of scrappers ( at least for me ), I don&amp;rsquo;t want to spin up a whole rails app.&lt;/p&gt;

&lt;p&gt;Hence, I&amp;rsquo;ve come up with &lt;a href=&#34;https://github.com/Skarlso/rscrap&#34;&gt;RScrap&lt;/a&gt;. Which is a bunch of Ruby scripts run as cron jobs on a raspberry pi. And because I dislike emails as well, and most of the time, I don&amp;rsquo;t read them, I opted for a nicer solution. Enter the world of &lt;a href=&#34;https://telegram.org&#34;&gt;Telegram&lt;/a&gt;. They provide you with the ability to create bots. You basically get an API key, and than using that key, you can send private messages, or even create an interactive bot which you can send messages too.&lt;/p&gt;

&lt;p&gt;In my simple example, I&amp;rsquo;m using it to send private messages to myself, but I could just as well, make it interactive and than tell it to run one of the scripts.&lt;/p&gt;

&lt;h1 id=&#34;the-code:3859b786e5fbfbb427877ae525b50427&#34;&gt;The Code&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at what we got.&lt;/p&gt;

&lt;h2 id=&#34;the-main-scraper:3859b786e5fbfbb427877ae525b50427&#34;&gt;The main scraper&lt;/h2&gt;

&lt;p&gt;The main scraper, is simply bunch of convenience methods that wrap handling and working with the database and the telegram bot. That&amp;rsquo;s all. It&amp;rsquo;s very simple. Very short. The Telegram part is just this bit:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def send_message(text)
  Telegram::Bot::Client.run(@token) do |bot|
    bot.api.send_message(chat_id: @id, text: text)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Straightforward. Creating an interactive bot, would look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#!/usr/bin/env ruby
require &#39;telegram/bot&#39;

token = &#39;YOUR_TELEGRAM_BOT_API_TOKEN&#39;

Telegram::Bot::Client.run(token) do |bot|
  bot.listen do |message|
    case message.text
    when &#39;/start&#39;
      bot.api.send_message(chat_id: message.chat.id, text: &amp;quot;Hello, #{message.from.first_name}&amp;quot;)
    when &#39;/stop&#39;
      bot.api.send_message(chat_id: message.chat.id, text: &amp;quot;Bye, #{message.from.first_name}&amp;quot;)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, it will listen, and than you can send it messages and based on the parsed &lt;code&gt;message.text&lt;/code&gt; you can define functions to call. For example, for rscrap I could define something like &lt;code&gt;run_script(script)&lt;/code&gt;. And the command would be: &lt;code&gt;/run reddit&lt;/code&gt;. Which will execute my reddit script. The possibilities are endless.&lt;/p&gt;

&lt;h2 id=&#34;the-scripts:3859b786e5fbfbb427877ae525b50427&#34;&gt;The scripts&lt;/h2&gt;

&lt;p&gt;The scripts use nokogiri to parse a web page, and than return a URL which will be sent by the TelegramBot. They are also saved in the database so that when a new comic strip comes out, I know that it&amp;rsquo;s new. For reddit, I&amp;rsquo;m saving a timestamp as well, and I collect everything after that timestamp through the reddit API as JSON, and send it as a bundled message with shortified links to the posts using bit.ly.&lt;/p&gt;

&lt;p&gt;The scraping is most of the times the same for every comic. Thus, there is a helper method for it. The script itself, is very short. For example, lets look at gunnerkrigg court.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require_relative &#39;../rscrap&#39;
require &#39;nokogiri&#39;
require &#39;open-uri&#39;

url = &#39;http://www.gunnerkrigg.com&#39;
scrap = Rscrap.new
page = Nokogiri::HTML(open(url))
comic_id = page.css(&#39;img.comic_image&#39;)[0].select { |e| e if e[0] == &#39;src&#39; }[0][1]
new_comic = &amp;quot;#{url}#{comic_id}&amp;quot;
scrap.send_new_comic(url, new_comic)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The interesting part of it is this bit: &lt;code&gt;comic_id = page.css(&#39;img.comic_image&#39;)[0].select { |e| e if e[0] == &#39;src&#39; }[0][1]&lt;/code&gt;. It extracts the URL for the comic image, and stores it as an &amp;ldquo;id&amp;rdquo; of the comic. This than, is sent as a message which Telegram will embed. There is no need to visit the web page, the image is in your feed and you can view it directly. Just like an RSS ready.&lt;/p&gt;

&lt;h2 id=&#34;cron:3859b786e5fbfbb427877ae525b50427&#34;&gt;Cron&lt;/h2&gt;

&lt;p&gt;These scripts are best used in a cron job. The comics are usually running with a daily frequency, where as the reddit gatherer is running with an hour frequency. Basically, I&amp;rsquo;m receiving updates on an hourly basis if there are new posts by then. Running ruby from cron was a bit tricky. I&amp;rsquo;m using bundler for the environment, and came up with this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;0 6-23 * * * /bin/bash -l -c &#39;cd /home/&amp;lt;youruser&amp;gt;/rubyproj/rscrap &amp;amp;&amp;amp; bundle exec ruby scripts/reddit.rb&#39;
0 8,22 * * * /bin/bash -l -c &#39;cd /home/&amp;lt;youruser&amp;gt;/rubyproj/rscrap &amp;amp;&amp;amp; bundle exec ruby scripts/gunnerkrigg.rb&#39;
0 8,22 * * * /bin/bash -l -c &#39;cd /home/&amp;lt;youruser&amp;gt;/rubyproj/rscrap &amp;amp;&amp;amp; bundle exec ruby scripts/aws_blog.rb&#39;
0 5,23 * * * /bin/bash -l -c &#39;cd /home/&amp;lt;youruser&amp;gt;/rubyproj/rscrap &amp;amp;&amp;amp; bundle exec ruby scripts/goblinscomic.rb&#39;
0 6,20 * * * /bin/bash -l -c &#39;cd /home/&amp;lt;youruser&amp;gt;/rubyproj/rscrap &amp;amp;&amp;amp; bundle exec ruby scripts/xkcd.rb&#39;
0 7,19 * * * /bin/bash -l -c &#39;cd /home/&amp;lt;youruser&amp;gt;/rubyproj/rscrap &amp;amp;&amp;amp; bundle exec ruby scripts/commitstrip.rb&#39;
0 8 * * * /bin/bash -l -c &#39;cd /home/&amp;lt;youruser&amp;gt;/rubyproj/rscrap &amp;amp;&amp;amp; bundle exec ruby scripts/sequiential_art.rb&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And a telegram message for all these things, looks like this:
Reddit:
&lt;img src=&#34;https://github.com/Skarlso/rscrap/raw/master/shorten.png&#34; alt=&#34;TelegramIMReddit&#34; /&gt;

Comics:
&lt;img src=&#34;https://github.com/Skarlso/rscrap/raw/master/rscrap2.png&#34; alt=&#34;TelegramIMComics&#34; /&gt;
&lt;/p&gt;

&lt;h1 id=&#34;conclusion:3859b786e5fbfbb427877ae525b50427&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;That&amp;rsquo;s it folks. Adding a new scraper is easy. I added the aws blog as a new entry as well by just copying the comics scripts. And I&amp;rsquo;m also getting Weather Reports delivered every morning to me.&lt;/p&gt;

&lt;p&gt;Have fun. Any questions, please feel free to leave a comment!&lt;/p&gt;

&lt;p&gt;Thanks,
Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ruby Sieve</title>
      <link>https://skarlso.github.io/2016/07/12/ruby-sieve</link>
      <pubDate>Tue, 12 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/07/12/ruby-sieve</guid>
      <description>&lt;p&gt;Though it could be done better, I&amp;rsquo;m sure, but I&amp;rsquo;m actually pretty satisfied with this one. It loops only twice as opposed to filtered ranges and whatnot other solutions to the sieve. I was thinking of rather creating a list and deleting elements from it, but that&amp;rsquo;s already three loops.&lt;/p&gt;

&lt;p&gt;Maybe I&amp;rsquo;ll do a benchmark later on more solutions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Sieve contains a function to return a set of primes
class Sieve
  def initialize(n)
    @n = n
  end

  # Returns a list of primes up to a certain limit
  # @param n limit
  # @return list of primes
  def primes
    marked = []
    primes = []
    (2..@n).each do |e|
      unless marked.include?(e)
        primes.push e
        (e..@n).step(e) { |s| marked.push s }
      end
    end
    primes
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cheers,
Gergely.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>