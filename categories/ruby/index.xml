<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ruby on Ramblings of a cloud engineer</title>
    <link>https://skarlso.github.io/categories/ruby/</link>
    <description>Recent content in Ruby on Ramblings of a cloud engineer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 12 Apr 2019 08:01:00 +0100</lastBuildDate><atom:link href="https://skarlso.github.io/categories/ruby/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Living with a new Parser for a year</title>
      <link>https://skarlso.github.io/2019/04/12/living-with-a-parser/</link>
      <pubDate>Fri, 12 Apr 2019 08:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2019/04/12/living-with-a-parser/</guid>
      <description type="html"><![CDATA[<p>Hi folks!</p>
<p><img src="/img/parser/hi.jpg" alt="hi"></p>
<p>Today’s post is a retrospective. I would like to gather some thoughts about living with the new parser that I wrote for <a href="https://github.com/joshbuddy/jsonpath/">JsonPath</a>.</p>
<p>After a little over a year, some interesting problems surfaced that I thought I’d share for people who also would like to endeavor on this path. Let’s begin.</p>
<h1 id="previously">Previously</h1>
<p>About, two years ago, I took over managing / fixing / improving this ruby gem: <a href="https://github.com/joshbuddy/jsonpath">Json Parser</a>. It&rsquo;s a json parser in ruby. Amongst other problems, it used <code>eval</code> in the background to evaluate expressions. It was a security risk to use this gem to its full extent. Something had to be done about that.</p>
<p>I proceeded to write a semi-language parser which replaced eval that can be found here: <a href="https://github.com/joshbuddy/jsonpath/blob/master/lib/jsonpath/parser.rb">Parser</a>. The basic intention was to replace the bare minimum of the eval behavior, and so, it was lacking some serious logic. That got improved as time went by.</p>
<p>This is a one year retrospective on living with a self-written parser. Enjoy some of the quirks I faced so you don&rsquo;t have to.</p>
<h1 id="ast">AST</h1>
<p><img src="/img/parser/ast.jpg" alt="ast"></p>
<p>AST is short for <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a>. It’s a data structure that is ideal for representing and parsing language syntax. All major lexers use some kind of AST in the background like this old Ruby language parser gem: <a href="https://github.com/whitequark/parser">Whitequark Parser</a>. This parser is used by projects like Rubocop and line coverage reports. It&rsquo;s usage is not trivial right out of the box. But as you move along you get a firm grasp of true potential.</p>
<p>I decided to not use that parser a year ago mainly because I thought it’s too much for what I’m trying to accomplish. Maybe I was right, maybe not. I tried to play with Parser recently but it’s none trivial nature and lack of documentation makes it cumbersome to use.</p>
<h1 id="the-first-problems">The first problems</h1>
<p><img src="/img/parser/infinity.jpg" alt="infinity"></p>
<p>What was then the first trouble that arose after I replaced eval? The parser back then was dumbed down a lot. The bug I faced was a simple infinite loop. The parser works like a lexer. It identifies tokens of certain type and tries to parse them into variables. This lexing had an error.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="o">-</span>        <span class="k">elsif</span> <span class="n">t</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/(\s+)?&#39;?(\w+)?[.,]?(\w+)?&#39;?(\s+)?/</span><span class="p">)</span> <span class="c1"># @TODO: At this point I should trim somewhere...</span>
<span class="o">+</span>        <span class="k">elsif</span> <span class="n">t</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/(\s+)?&#39;?.*&#39;?(\s+)?/</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>It was caught by this Json Path:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$.acceptNewTasks.[?(@.taskEndpoint == &#34;mps/awesome&#34;)].lastTaskPollTime
</code></pre></td></tr></table>
</div>
</div><p>The culprit was the <code>/</code> character. The tokenizer wasn’t prepared…</p>
<p>Eval would have no problem but the parser is using strict regex-s. This is where an AST would have had more luck.</p>
<h1 id="numbers">Numbers</h1>
<p><img src="/img/parser/twins1.jpg" alt="twins1"></p>
<p>The second problem was the fact that the parser is using strings. Who would have thought that the string <code>2.0</code> in fact does not equal to string <code>2</code>? In Ruby the simplest way of making sure a variable is a Number is by casting the variable to Number or Float. In case it’s not a Number we rescue and move on.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="n">el</span> <span class="o">=</span> <span class="nb">Float</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="k">rescue</span> <span class="n">el</span>
</code></pre></td></tr></table>
</div>
</div><p>Incidentally this also solved the problem where the json path contained a number but since everything is a string this, also did not equal: <code>'1' == 1</code>.</p>
<p>Since first the string needed to be a Number.</p>
<h1 id="supporting-regexes">Supporting regexes</h1>
<p><img src="/img/parser/bouncer1.jpg" alt="bouncer1"></p>
<p>Next came supported operators. The parser only supported the basic operators: <code>&lt;&gt;=</code>. It was missing <code>=~</code> from this. Which meant people who would use regexes to filter JSON would no longer be able to do so. This was only a tiny modification actually:</p>
<p>First, the operator filter needed to be aware&hellip;</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="o">-</span> <span class="k">elsif</span> <span class="n">t</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/(\s+)?[&lt;&gt;=][=&lt;&gt;]?(\s+)?/</span><span class="p">)</span>
<span class="o">+</span> <span class="k">elsif</span> <span class="n">t</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/(\s+)?[&lt;&gt;=][=~]?(\s+)?/</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>With that done, we just <code>.to_regexp</code> it with the power of ruby and <code>send</code> would automatically pick it up. And of course test coverage.</p>
<h1 id="regression">Regression</h1>
<p>Once the parser was introduced I knew that it would create problems, since eval did many things that the parser could not handle. And they started to arrive slowly. One-by-one.</p>
<h2 id="booleans">Booleans</h2>
<p><img src="/img/parser/twins2.jpg" alt="twins2"></p>
<p>Aka, the story of <code>true == 'true'</code>&hellip; Inherently working with strings here makes it difficult to detect when the type boolean is meant or a string which happens to say <code>true</code>. This one was easy to solve as well in the end:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="n">operand</span> <span class="o">=</span> <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="s1">&#39;true&#39;</span>
            <span class="kp">true</span>
        <span class="k">elsif</span> <span class="n">t</span> <span class="o">==</span> <span class="s1">&#39;false&#39;</span>
            <span class="kp">false</span>
        <span class="k">else</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">strip</span> <span class="o">==</span> <span class="s1">&#39;=~&#39;</span> <span class="p">?</span> <span class="n">t</span><span class="o">.</span><span class="n">to_regexp</span> <span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">%r{^&#39;|&#39;$}</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span> <span class="c1"># We also handle regexp here.</span>
        <span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div><p>Ignoring the regex part, this was all it needed.</p>
<h2 id="syntax">Syntax</h2>
<p><img src="/img/parser/bouncer3.jpg" alt="bouncer3"></p>
<p>Some smaller tid-bits here and there also started to crop up. Things that eval did not mind at all, but my poor Parser couldn&rsquo;t handle. The regex started out tightly tied. This meant that certain characters weren&rsquo;t properly detected. Characters like the underscore, or <code>@</code> or <code>/</code>&hellip; All these weren&rsquo;t picked up by my tight regexp. I had to widen it a bit using .* at certain places.</p>
<h2 id="number-formatting">Number formatting</h2>
<p>Formatting and comparing numbers gave me a lot of headache. I had to detect whether I’m dealing with a number or a string parsed as a number or a number but that was converted into string or a string that happened to be a number. Geez…</p>
<p>I ended up making it simple like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="n">el</span> <span class="o">=</span> <span class="nb">Float</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="k">rescue</span> <span class="n">el</span>
<span class="n">operand</span> <span class="o">=</span> <span class="nb">Float</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span> <span class="k">rescue</span> <span class="n">operand</span>
</code></pre></td></tr></table>
</div>
</div><p>Basically everything is a number. Doesn’t matter where it came from, what it was in the past… It’s a number if it can be converted. This, of course, also means that a test like this one fails:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby">  <span class="k">def</span> <span class="nf">test_number_match</span>
    <span class="n">json</span> <span class="o">=</span> <span class="p">{</span>
      <span class="ss">channels</span><span class="p">:</span><span class="o">[</span>
        <span class="p">{</span>
          <span class="ss">elem</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="ss">elem</span><span class="p">:</span> <span class="s1">&#39;1&#39;</span>
        <span class="p">}</span>
      <span class="o">]</span>
    <span class="p">}</span><span class="o">.</span><span class="n">to_json</span>

    <span class="n">assert_equal</span> <span class="o">[</span><span class="p">{</span> <span class="s1">&#39;elem&#39;</span> <span class="o">=&gt;</span> <span class="mi">1</span> <span class="p">}</span><span class="o">]</span><span class="p">,</span> <span class="no">JsonPath</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">json</span><span class="p">,</span> <span class="s2">&#34;$..channels[?(@.elem == 1)]&#34;</span><span class="p">)</span>
  <span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div><p>Both will match… Even though you’d expect it only to match one. Luckily though… this is exactly how <a href="http://jsonpath.com/">http://jsonpath.com/</a> works as well. An AST would detect that it’s a number type… But since I’m parsing strings here, that would be almost impossible a feat to accomplish in a nice manner.</p>
<h2 id="groups">Groups</h2>
<p><img src="/img/parser/bouncer2.jpg" alt="bouncer2"></p>
<p>And finally, the biggest one… Groups in conditions. A query like this one for example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$..book[?((@[&#39;author&#39;] == &#39;Evelyn Waugh&#39; || @[&#39;author&#39;] == &#39;Herman Melville&#39; &amp;&amp; (@[&#39;price&#39;] == 33 || @[&#39;price&#39;] == 9))]
</code></pre></td></tr></table>
</div>
</div><p>Something like this was never parsed correctly. Since the parser didn’t understand grouping and order of evaluation. Let’s break it down. How do we get from a monstrous like that one above to something that can be handled? We take it one group at a time.</p>
<h3 id="parentheses">Parentheses</h3>
<p>As a first step, we make sure that the parentheses match. It’s possible that someone didn’t pay attention and left out a closing parentheses. Now, there are a couple of way of doing that in Ruby, but I went for the most plain blatant one.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby">    <span class="k">def</span> <span class="nf">check_parenthesis_count</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
      <span class="k">return</span> <span class="kp">true</span> <span class="k">unless</span> <span class="n">exp</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="s2">&#34;(&#34;</span><span class="p">)</span>
      <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="n">exp</span><span class="o">.</span><span class="n">chars</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span>
          <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elsif</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;)&#39;</span>
          <span class="n">depth</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">end</span>
      <span class="k">end</span>
      <span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div><p>A basic depth counter. We do this first, to avoid parsing an invalid query.</p>
<h3 id="breaking-it-down">Breaking it down</h3>
<p>Next we break down this complex thing into a query that makes more sense to the parser. To do that, we take each group and extract the operation in them and replace it with the value they provide. Meaning a query like the one above essentially should look like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">((false || false) &amp;&amp; (false || true))
</code></pre></td></tr></table>
</div>
</div><p>Neat. This is handled by this code segment: <a href="https://github.com/joshbuddy/jsonpath/blob/b2525b8e8c596ddf1c8b40982529300b5a98132b/lib/jsonpath/parser.rb#L112">Parser</a>.</p>
<p>The parsing function is called over and over again until there are no parentheses left in the expression. Aka, a single true or false or number remains.</p>
<p>Now, who can spot an issue with that? The function <code>bool_or_exp</code> is there to return a float or a boolean value. If it returns a float, we still &amp;&amp;= -it together with the result&hellip; Thus, if there is a query like this one for example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$..book[?(@.length-5 &amp;&amp; @.type == &#39;asdf&#39;)]
</code></pre></td></tr></table>
</div>
</div><p>This would fail horribly. Which means, asking for a specific index in a json in a grouped expression is not supported at the moment.</p>
<h3 id="return-value">Return Value</h3>
<p>The parser doesn’t just return a bool value and call it a day. It also returns indexes like you read above. Indexes in cases when there is a query that returns the location of an item in the node and not if the node contains something or matches some data. For example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$..book[(@.length-5)]
</code></pre></td></tr></table>
</div>
</div><p>Returns the length-5-th book.</p>
<h1 id="outstanding-issues">Outstanding issues</h1>
<p>Right now there are two outstanding issues. The one mentioned above, where you can’t nest indexes and true/false notations. And the other is a submitted issue in which it’s described that it’s not possible to use something like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$.phoneNumbers[?(@[0].type == &#39;home&#39;)]
</code></pre></td></tr></table>
</div>
</div><p>Which basically boils down to the fact that Jsonpath can’t handle nested lists like these:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;phoneNumbers&#34;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">[{</span>
      <span class="nt">&#34;type&#34;</span>  <span class="p">:</span> <span class="s2">&#34;iPhone&#34;</span><span class="p">,</span>
      <span class="nt">&#34;number&#34;</span><span class="p">:</span> <span class="s2">&#34;0123-4567-8888&#34;</span>
    <span class="p">}],</span>
    <span class="p">[{</span>
      <span class="nt">&#34;type&#34;</span>  <span class="p">:</span> <span class="s2">&#34;home&#34;</span><span class="p">,</span>
      <span class="nt">&#34;number&#34;</span><span class="p">:</span> <span class="s2">&#34;0123-4567-8910&#34;</span>
    <span class="p">}]</span>
  <span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>That isn’t actually the problem of the parser, but Jsonpath itself.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Like a good marriage, living with a Parser is a lot of compromise and ironing out edges and working on making it better for both parties involved. I have no doubt that there are more bugs in this code, but I&rsquo;m trying to keep it concise and clear to read as much as possible.</p>
<p>I hope this was as fun to read as it was to write.</p>
<p>Thank you for reading,</p>
<p>Gergely.</p>
]]></description>
    </item>
    
    <item>
      <title>Keep your git forks updated all the time</title>
      <link>https://skarlso.github.io/2018/06/08/fork-updater/</link>
      <pubDate>Fri, 08 Jun 2018 08:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2018/06/08/fork-updater/</guid>
      <description type="html"><![CDATA[<p>Hi folks.</p>
<p>Today&rsquo;s is a quick tip for keeping your forks updated.</p>
<p>If you are like me, and have at least a 100 forks in your repository because:
* You would like to contribute at some point
* Save it for yourself because you are afraid that it disappears
* Would like to make modifications for your own benefit
* Whatever the reason</p>
<p>&hellip;then you probably have a lot of trouble keeping them updated and making sure you always see the latest change.</p>
<p>Upstream can change a lot especially if it&rsquo;s a busy repository.</p>
<p>Fret not. Help is here. This little ruby script will solve your troubles:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby">
<span class="c1">#!/usr/bin/env ruby</span>

<span class="nb">require</span> <span class="s1">&#39;octokit&#39;</span>
<span class="nb">require</span> <span class="s1">&#39;logger&#39;</span>

<span class="vi">@logger</span> <span class="o">=</span> <span class="no">Logger</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&#34;output.log&#34;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">update_fork</span><span class="p">(</span><span class="n">repo</span><span class="p">)</span>
  <span class="n">repo_name</span> <span class="o">=</span> <span class="n">repo</span><span class="o">.</span><span class="n">name</span>
  <span class="c1"># clone the repository -- octokit doesn&#39;t provide this feature as it&#39;s a github api library</span>
  <span class="vi">@logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;cloning into </span><span class="si">#{</span><span class="n">repo</span><span class="o">.</span><span class="n">ssh_url</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
  <span class="nb">system</span><span class="p">(</span><span class="s2">&#34;git clone </span><span class="si">#{</span><span class="n">repo</span><span class="o">.</span><span class="n">ssh_url</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">repo_name</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
  <span class="c1"># setup upstream for updating</span>
  <span class="vi">@logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;setup upstream to </span><span class="si">#{</span><span class="n">repo</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">ssh_url</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
  <span class="nb">system</span><span class="p">(</span><span class="s2">&#34;cd </span><span class="si">#{</span><span class="n">repo_name</span><span class="si">}</span><span class="s2"> &amp;&amp; git remote add upstream </span><span class="si">#{</span><span class="n">repo</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">ssh_url</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
  <span class="c1"># do the update</span>
  <span class="vi">@logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;doing the update with push&#34;</span><span class="p">)</span>
  <span class="nb">system</span><span class="p">(</span><span class="s2">&#34;cd </span><span class="si">#{</span><span class="n">repo_name</span><span class="si">}</span><span class="s2"> &amp;&amp; git fetch upstream &amp;&amp; git rebase upstream/master &amp;&amp; git push origin&#34;</span><span class="p">)</span>
<span class="k">ensure</span>
  <span class="c1"># ensure that the folder is cleaned up</span>
  <span class="vi">@logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;cleanup: removing the repository folder&#34;</span><span class="p">)</span>
  <span class="nb">system</span><span class="p">(</span><span class="s2">&#34;rm -fr </span><span class="si">#{</span><span class="n">repo_name</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">client</span> <span class="o">=</span> <span class="no">Octokit</span><span class="o">::</span><span class="no">Client</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:access_token</span> <span class="o">=&gt;</span> <span class="no">ENV</span><span class="o">[</span><span class="s1">&#39;GIT_TOKEN&#39;</span><span class="o">]</span><span class="p">,</span> <span class="ss">per_page</span><span class="p">:</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">repos</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">repos</span><span class="p">({},</span> <span class="ss">query</span><span class="p">:</span> <span class="p">{</span><span class="ss">type</span><span class="p">:</span> <span class="s1">&#39;owner&#39;</span><span class="p">,</span> <span class="ss">sort</span><span class="p">:</span> <span class="s1">&#39;asc&#39;</span><span class="p">})</span>

<span class="c1"># Go through all the pages and add them to the list of repositories.</span>
<span class="n">repos</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">client</span><span class="o">.</span><span class="n">last_response</span><span class="o">.</span><span class="n">rels</span><span class="o">[</span><span class="ss">:next</span><span class="o">].</span><span class="n">get</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

<span class="n">repos</span> <span class="o">=</span> <span class="n">repos</span><span class="o">.</span><span class="n">select</span><span class="p">{</span> <span class="o">|</span><span class="n">r</span><span class="o">|</span> <span class="n">r</span><span class="o">.</span><span class="n">fork</span> <span class="p">}</span>

<span class="vi">@logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;going to update &#39;</span><span class="si">#{</span><span class="n">repos</span><span class="o">.</span><span class="n">length</span><span class="si">}</span><span class="s2">&#39; repositories&#34;</span><span class="p">)</span>

<span class="n">repos</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">repo</span><span class="o">|</span>
  <span class="c1"># get the repositories information</span>
  <span class="vi">@logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;updating </span><span class="si">#{</span><span class="n">repo</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">repository</span><span class="p">(</span><span class="n">repo</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
  <span class="n">update_fork</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div><p>This script is also available as a Gist located <a href="https://gist.github.com/Skarlso/fd5bd5971a78a5fa9760b31683de690e">here</a>.</p>
<p>Put this into a cron job, or a Jenkins job on a schedule and you should be good to go.</p>
<p>Note two things:
First: <code>ENV['GIT_TOKEN']</code> this should be set to a token which you can acquire by navigating to
<a href="https://github.com/settings/tokens">tokens</a>. Add a token which has <code>repo</code> access.</p>
<p>Second: Obviously this script will push to your local repository. So wherever you run this, make sure git is set-up and can push
to your repository via SSH. This script is using <code>ssh_url</code> for the repositories. It won&rsquo;t ask for a username or a password.</p>
<p>That&rsquo;s it. Enjoy and keep updating.</p>
<p>Thanks for reading</p>
<p>Gergely.</p>
]]></description>
    </item>
    
    <item>
      <title>Replacing Eval with Object.send and a self written Parser</title>
      <link>https://skarlso.github.io/2017/05/28/replace-eval-with-object-send-and-a-parser/</link>
      <pubDate>Sun, 28 May 2017 19:23:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2017/05/28/replace-eval-with-object-send-and-a-parser/</guid>
      <description type="html"><![CDATA[<h1 id="intro">Intro</h1>
<p>A while ago, I was added as a curator for a Gem called <a href="https://github.com/joshbuddy/jsonpath">JsonPath</a>. It&rsquo;s a small but very useful and brilliant gem. It had a couple of problems which I fixed, but the hardest to eliminate proved to be a series of evals throughout the code.</p>
<p>You could opt in using <code>eval</code> with a constructor parameter, but generally, it was considered to be unsafe. Thus, normally when a project was using it, like <a href="https://github.com/huginn/huginn">Huginn</a> they had to opt out by default, thus missing out on sweet parsing like this: <code>$..book[?(@['price'] &gt; 20)]</code>.</p>
<h2 id="eval">Eval</h2>
<p>In order to remove eval, first I had to understand what it is actually doing. I had to take it apart.</p>
<p><img src="/img/takeevalapart.jpg" alt="apart"></p>
<p>After much digging and understanding the code, I found, all it does is perform the given operations on the current node. And if the operation is true, it will select that node, otherwise, return false, and ignore that node.</p>
<p>For example <code>$..book[?(@['price'] &gt; 20)]</code> could be translated to:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="k">return</span> <span class="vi">@_current_node</span><span class="o">[</span><span class="s1">&#39;price&#39;</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">20</span>
</code></pre></td></tr></table>
</div>
</div><p>Checking first if <code>'price'</code> is even a key in <code>@_current_node</code>. Once I&rsquo;ve understood this part, I set on trying to fix eval.</p>
<h3 id="safe--4">SAFE = 4</h3>
<p>In ruby, you could extract the part where you Eval and put it into its own proc and set <code>SAFE = 4</code> which will disable some things like system calls.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="nb">proc</span> <span class="k">do</span>
  <span class="no">SAFE</span> <span class="o">=</span> <span class="mi">4</span>
  <span class="nb">eval</span><span class="p">(</span><span class="n">some_expression</span><span class="p">)</span>
<span class="k">end</span><span class="o">.</span><span class="n">call</span>
</code></pre></td></tr></table>
</div>
</div><p>SAFE levels:</p>
<p>$SAFE	Description
0	No checking of the use of externally supplied (tainted) data is performed. This is Ruby&rsquo;s default mode.</p>
<blockquote>
<p>= 1	Ruby disallows the use of tainted data by potentially dangerous operations.
= 2	Ruby prohibits the loading of program files from globally writable locations.
= 3	All newly created objects are considered tainted.
= 4	Ruby effectively partitions the running program in two. None - tainted objects may not be modified. Typically, this will be used to create a sandbox: the program sets up an environment using a lower $SAFE level, then resets $SAFE to 4 to prevent subsequent changes to that environment.</p>
</blockquote>
<p>This has the disadvantage that anything below 4 is just, meh. But nothing above 1 will actually work with JsonPath so&hellip; scratch that.</p>
<h3 id="sandboxing">Sandboxing</h3>
<p>We could technically try and sandbox eval into it&rsquo;s own process with a PID and whitelist methods which are allowed to be called.</p>
<p>Not bad, and there are a few gems out there which are trying to do that like <a href="https://github.com/ukutaht/safe_ruby">SafeRuby</a>. But all of these project have been abandoned years ago for a good reason.</p>
<h3 id="objectsend">Object.send</h3>
<p><img src="/img/nobodylikesyou.jpg" alt="nobodylikesyou"></p>
<p><code>Object.send</code> is the best way to get some flexibility while still being safe. You basically just call methods on objects by describing said method on an object and giving parameters to it, like:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="mi">1</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="ss">:+</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="mi">3</span>
</code></pre></td></tr></table>
</div>
</div><p>This is a very powerful tool in our toolbox which we will exploit immensely.</p>
<p>So let&rsquo;s get to it.</p>
<h1 id="writing-a-parser">Writing a parser</h1>
<p>Writing a parser in Ruby is a very fluid experience. It has nice tools which support that, and the one I used is <code>StringScanner</code>. It has the ability to track where you are currently at in a string and move a pointer along with regex matches. In fact, JsonPath already employs this method when parsing a json expression. So reusing that logic was in fact&hellip; elementary.</p>
<h2 id="the-expression">The expression</h2>
<p>How do we get from this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$..book<span class="o">[</span>?<span class="o">(</span>@<span class="o">[</span><span class="s1">&#39;price&#39;</span><span class="o">]</span> &lt; 20<span class="o">)]</span>
</code></pre></td></tr></table>
</div>
</div><p>To this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="vi">@_current_node</span><span class="o">[</span><span class="s1">&#39;price&#39;</span><span class="o">]</span> <span class="o">&lt;</span> <span class="mi">20</span>
</code></pre></td></tr></table>
</div>
</div><p>Well. By simple elimination. There are a couple of problems along the way of course. Because this wouldn&rsquo;t be a parser if it couldn&rsquo;t handle ALL the other cases&hellip;</p>
<h3 id="removing-clutter">Removing Clutter</h3>
<p>Some of this we don&rsquo;t need. Like, <code>$..book</code> part.</p>
<p><img src="/img/dontneed1.jpg" alt="dontneed1"></p>
<p>The other things we don&rsquo;t need are all the <code>'[]?()</code></p>
<p><img src="/img/dontneed2.jpg" alt="dontneed2"></p>
<p>Once this is done, we can move to isolating the important bits.</p>
<p><img src="/img/takingaim.jpg" alt="takingaim"></p>
<h3 id="breakdown">BreakDown</h3>
<h4 id="elements">Elements</h4>
<p>How does an expression actually look like?</p>
<p>Let&rsquo;s break it down.</p>
<p><img src="/img/confused.jpg" alt="confused"></p>
<p>So, this is a handful. Operations can be <code>&lt;=,&gt;=,&lt;,&gt;,==,!=</code> and operands can be either numbers, or words, and element accessor can be nested since something like this is perfectly valid: <code>$..book[?(@.written.year == 1997)]</code>.</p>
<p><img src="/img/feedline.jpg" alt="feedline"></p>
<p>To avoid being overwhelmed, ruby has our back with a method called <code>dig</code>.</p>
<p><img src="/img/dig.jpg" alt="dig"></p>
<p>This, basically lets us pass in some parameters into a dig function on a hash or an array with variadic parameters, which will go on and access those elements in order how they were supplied. Until it either returns a <code>nil</code> or an end result.</p>
<p>For example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="mi">2</span><span class="o">.</span><span class="mi">3</span><span class="o">.</span><span class="mi">1</span> <span class="p">:</span><span class="mo">001</span> <span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="ss">a</span><span class="p">:</span> <span class="p">{</span><span class="ss">b</span><span class="p">:</span> <span class="s1">&#39;c&#39;</span><span class="p">}}</span>
 <span class="o">=&gt;</span> <span class="p">{</span><span class="ss">:a</span><span class="o">=&gt;</span><span class="p">{</span><span class="ss">:b</span><span class="o">=&gt;</span><span class="s2">&#34;c&#34;</span><span class="p">}}</span>
<span class="mi">2</span><span class="o">.</span><span class="mi">3</span><span class="o">.</span><span class="mi">1</span> <span class="p">:</span><span class="mo">002</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">dig</span><span class="p">(</span><span class="ss">:a</span><span class="p">,</span> <span class="ss">:b</span><span class="p">)</span>
 <span class="o">=&gt;</span> <span class="s2">&#34;c&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>Easy. However&hellip; Dig was only added after ruby 2.3 thus, I had to write my own dig for now, until I stop supporting anything below 2.3.</p>
<p>At first, I wanted to add it to the hash class, but it proved to be a futile attempt if I wanted to do it nicely, thus the parser got it as a private method.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby">    <span class="k">def</span> <span class="nf">dig</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">hash</span><span class="p">)</span>
      <span class="k">return</span> <span class="nb">hash</span> <span class="k">unless</span> <span class="nb">hash</span><span class="o">.</span><span class="n">is_a?</span> <span class="no">Hash</span>
      <span class="k">return</span> <span class="kp">nil</span> <span class="k">unless</span> <span class="nb">hash</span><span class="o">.</span><span class="n">key?</span><span class="p">(</span><span class="n">keys</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>
      <span class="k">return</span> <span class="nb">hash</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">keys</span><span class="o">.</span><span class="n">first</span><span class="p">)</span> <span class="k">if</span> <span class="n">keys</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span>
      <span class="n">prev</span> <span class="o">=</span> <span class="n">keys</span><span class="o">.</span><span class="n">shift</span>
      <span class="n">dig</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">hash</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">prev</span><span class="p">))</span>
    <span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div><p>And the corresponding regex behind getting a multitude of elements is as follows:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="o">...</span>
<span class="k">if</span> <span class="n">t</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/\[&#39;\w+&#39;\]+/</span><span class="p">)</span>
<span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="operator">Operator</h4>
<p>Selecting the operator is another interesting part as it can be a single one or multiple and all sorts. Until I realized that no&hellip; it can actually be only a couple.</p>
<p><img src="/img/whatone.jpg" alt="whatone"></p>
<p><img src="/img/whattwo.jpg" alt="whattwo"></p>
<p>Also, after a bit of fiddling and doing and doing a silly case statement first:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="k">case</span> <span class="n">op</span>
<span class="k">when</span> <span class="s1">&#39;&gt;&#39;</span>
  <span class="n">dig</span><span class="p">(</span><span class="vi">@_current_node</span><span class="p">,</span> <span class="o">*</span><span class="n">elements</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">operand</span>
<span class="k">when</span> <span class="s1">&#39;&lt;&#39;</span>
  <span class="n">dig</span><span class="p">(</span><span class="vi">@_current_node</span><span class="p">,</span> <span class="o">*</span><span class="n">elements</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">operand</span>
<span class="o">...</span>
<span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div><p>&hellip;I promptly saw that this is not how it should be done.</p>
<p>And here comes Object.send.</p>
<p><img src="/img/send.jpg" alt="send"></p>
<p>This gave me the opportunity to write this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="n">dig</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="vi">@_current_node</span><span class="p">)</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">operand</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Much better. Now I could send all the things in the way of a node.</p>
<p><img src="/img/sendtwo.jpg" alt="send"></p>
<p>Parsing an op be like:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="k">elsif</span> <span class="n">t</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/\s+[&lt;&gt;=][&lt;&gt;=]?\s+?/</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="operand">Operand</h4>
<p>Now comes the final piece. The value which we are comparing. This could either be a simple integer, a floating number, or a word. Hah. So coming up with a regex which fits this tightly took a little fiddling, but eventually I ended up with this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="k">elsif</span> <span class="n">t</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/(\s+)?&#39;?(\w+)?[.,]?(\w+)?&#39;?(\s+)?/</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Without StackOverflow I would say this is fine ((although I need to remove all those space check, shees)). What are all the question marks? Basically, everything is optional. Because an this expression <code>$..book[?(@.price)]</code> is valid. Which is basically just asserting if a given node has a price element.</p>
<h4 id="logical-operators">Logical Operators</h4>
<p>The last thing that remains is logical operators, which if you are using eval, is pretty straight forward. It takes care of anything that you might add in like <code>&amp;&amp;, ||, |, &amp;, ^</code> etc etc.</p>
<p>Now, that&rsquo;s something I did with a case though. Until I find a nicer solution. Since we can already parse a single expression it&rsquo;s just a question of breaking down a multi structure expression as the following one: <code>$..book[?(@['price'] &gt; 20 &amp;&amp; @.written.year == 1998)]</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="n">exps</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sr">/(&amp;&amp;)|(\|\|)/</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>This splits up the string by either <code>&amp;&amp;</code> or <code>||</code> and the usage of groups () also includes the operators. Than I evaluate the expressions and save the whole thing in an array like <code>[true, '&amp;&amp;', false]</code>. You know what could immediately resolve this? Yep&hellip;</p>
<p><img src="/img/saynotoeval.jpg" alt="saynotoeval">.</p>
<p>I&rsquo;d rather just parse it although technically an eval at this stage wouldn&rsquo;t be that big of a problem&hellip;</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
  <span class="n">exps</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sr">/(&amp;&amp;)|(\|\|)/</span><span class="p">)</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">parse_exp</span><span class="p">(</span><span class="n">exps</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span>
  <span class="n">exps</span><span class="o">.</span><span class="n">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">item</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
    <span class="k">case</span> <span class="n">item</span>
    <span class="k">when</span> <span class="s1">&#39;&amp;&amp;&#39;</span>
      <span class="n">ret</span> <span class="o">&amp;&amp;=</span> <span class="n">parse_exp</span><span class="p">(</span><span class="n">exps</span><span class="o">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span><span class="p">)</span>
    <span class="k">when</span> <span class="s1">&#39;||&#39;</span>
      <span class="n">ret</span> <span class="o">||=</span> <span class="n">parse_exp</span><span class="p">(</span><span class="n">exps</span><span class="o">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="n">ret</span>
<span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="closing-words">Closing words</h1>
<p>That&rsquo;s it folks. The parser is done. And there is no eval being used. There are some more things here that are interesting. Like, array indexing is allowed in jsonpath which is solved by sending <code>.length</code> to a current node. For example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="k">if</span> <span class="n">scanner</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/\./</span><span class="p">)</span>
  <span class="n">sym</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/\w+/</span><span class="p">)</span>
  <span class="n">op</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/./</span><span class="p">)</span>
  <span class="n">num</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/\d+/</span><span class="p">)</span>
  <span class="k">return</span> <span class="vi">@_current_node</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">to_sym</span><span class="p">)</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">to_sym</span><span class="p">,</span> <span class="n">num</span><span class="o">.</span><span class="n">to_i</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div><p>If an expression begins with a <code>.</code>. So you see that using <code>send</code> will help a lot, and understanding what eval is trying to evaluate and rather writing your own parser, isn&rsquo;t that hard at all using ruby.</p>
<p>I hope you enjoyed reading this little tid-bit as much as I enjoyed writing and drawing it. Leave a comment if your liked the drawings or if you did not and I should never do them again (( I don&rsquo;t really care, this is my blog haha. )). Note to self: I shouldn&rsquo;t draw on the other side of the drawing because of bleed-through.</p>
<p>Thank you!
Gergely.</p>
]]></description>
    </item>
    
    <item>
      <title>RScrap scraper</title>
      <link>https://skarlso.github.io/2016/10/06/rscrap-ruby-scraping-with-cronjob-scripts/</link>
      <pubDate>Thu, 06 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/10/06/rscrap-ruby-scraping-with-cronjob-scripts/</guid>
      <description type="html"><![CDATA[<h1 id="intro">Intro</h1>
<p>Hey folks.</p>
<p>So, there is this project called <a href="https://github.com/cantino/huginn">Huginn</a> which I absolutely love.</p>
<p>But the thing is, that for a couple of scrappers ( at least for me ), I don&rsquo;t want to spin up a whole rails app.</p>
<p>Hence, I&rsquo;ve come up with <a href="https://github.com/Skarlso/rscrap">RScrap</a>. Which is a bunch of Ruby scripts run as cron jobs on a raspberry pi. And because I dislike emails as well, and most of the time, I don&rsquo;t read them, I opted for a nicer solution. Enter the world of <a href="https://telegram.org">Telegram</a>. They provide you with the ability to create bots. You basically get an API key, and than using that key, you can send private messages, or even create an interactive bot which you can send messages too.</p>
<p>In my simple example, I&rsquo;m using it to send private messages to myself, but I could just as well, make it interactive and than tell it to run one of the scripts.</p>
<h1 id="the-code">The Code</h1>
<p>Let&rsquo;s take a look at what we got.</p>
<h2 id="the-main-scraper">The main scraper</h2>
<p>The main scraper, is simply bunch of convenience methods that wrap handling and working with the database and the telegram bot. That&rsquo;s all. It&rsquo;s very simple. Very short. The Telegram part is just this bit:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">send_message</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
  <span class="no">Telegram</span><span class="o">::</span><span class="no">Bot</span><span class="o">::</span><span class="no">Client</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="vi">@token</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">bot</span><span class="o">|</span>
    <span class="n">bot</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="ss">chat_id</span><span class="p">:</span> <span class="vi">@id</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="n">text</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div><p>Straightforward. Creating an interactive bot, would look something like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="ch">#!/usr/bin/env ruby</span>
<span class="nb">require</span> <span class="s1">&#39;telegram/bot&#39;</span>

<span class="n">token</span> <span class="o">=</span> <span class="s1">&#39;YOUR_TELEGRAM_BOT_API_TOKEN&#39;</span>

<span class="no">Telegram</span><span class="o">::</span><span class="no">Bot</span><span class="o">::</span><span class="no">Client</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">bot</span><span class="o">|</span>
  <span class="n">bot</span><span class="o">.</span><span class="n">listen</span> <span class="k">do</span> <span class="o">|</span><span class="n">message</span><span class="o">|</span>
    <span class="k">case</span> <span class="n">message</span><span class="o">.</span><span class="n">text</span>
    <span class="k">when</span> <span class="s1">&#39;/start&#39;</span>
      <span class="n">bot</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="ss">chat_id</span><span class="p">:</span> <span class="n">message</span><span class="o">.</span><span class="n">chat</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s2">&#34;Hello, </span><span class="si">#{</span><span class="n">message</span><span class="o">.</span><span class="n">from</span><span class="o">.</span><span class="n">first_name</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
    <span class="k">when</span> <span class="s1">&#39;/stop&#39;</span>
      <span class="n">bot</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="ss">chat_id</span><span class="p">:</span> <span class="n">message</span><span class="o">.</span><span class="n">chat</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s2">&#34;Bye, </span><span class="si">#{</span><span class="n">message</span><span class="o">.</span><span class="n">from</span><span class="o">.</span><span class="n">first_name</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div><p>Basically, it will listen, and than you can send it messages and based on the parsed <code>message.text</code> you can define functions to call. For example, for rscrap I could define something like <code>run_script(script)</code>. And the command would be: <code>/run reddit</code>. Which will execute my reddit script. The possibilities are endless.</p>
<h2 id="the-scripts">The scripts</h2>
<p>The scripts use nokogiri to parse a web page, and than return a URL which will be sent by the TelegramBot. They are also saved in the database so that when a new comic strip comes out, I know that it&rsquo;s new. For reddit, I&rsquo;m saving a timestamp as well, and I collect everything after that timestamp through the reddit API as JSON, and send it as a bundled message with shortified links to the posts using bit.ly.</p>
<p>The scraping is most of the times the same for every comic. Thus, there is a helper method for it. The script itself, is very short. For example, lets look at gunnerkrigg court.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="n">require_relative</span> <span class="s1">&#39;../rscrap&#39;</span>
<span class="nb">require</span> <span class="s1">&#39;nokogiri&#39;</span>
<span class="nb">require</span> <span class="s1">&#39;open-uri&#39;</span>

<span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;http://www.gunnerkrigg.com&#39;</span>
<span class="n">scrap</span> <span class="o">=</span> <span class="no">Rscrap</span><span class="o">.</span><span class="n">new</span>
<span class="n">page</span> <span class="o">=</span> <span class="no">Nokogiri</span><span class="o">::</span><span class="no">HTML</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">url</span><span class="p">))</span>
<span class="n">comic_id</span> <span class="o">=</span> <span class="n">page</span><span class="o">.</span><span class="n">css</span><span class="p">(</span><span class="s1">&#39;img.comic_image&#39;</span><span class="p">)</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span> <span class="k">if</span> <span class="n">e</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="s1">&#39;src&#39;</span> <span class="p">}</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span>
<span class="n">new_comic</span> <span class="o">=</span> <span class="s2">&#34;</span><span class="si">#{</span><span class="n">url</span><span class="si">}#{</span><span class="n">comic_id</span><span class="si">}</span><span class="s2">&#34;</span>
<span class="n">scrap</span><span class="o">.</span><span class="n">send_new_comic</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">new_comic</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The interesting part of it is this bit: <code>comic_id = page.css('img.comic_image')[0].select { |e| e if e[0] == 'src' }[0][1]</code>. It extracts the URL for the comic image, and stores it as an &ldquo;id&rdquo; of the comic. This than, is sent as a message which Telegram will embed. There is no need to visit the web page, the image is in your feed and you can view it directly. Just like an RSS ready.</p>
<h2 id="cron">Cron</h2>
<p>These scripts are best used in a cron job. The comics are usually running with a daily frequency, where as the reddit gatherer is running with an hour frequency. Basically, I&rsquo;m receiving updates on an hourly basis if there are new posts by then. Running ruby from cron was a bit tricky. I&rsquo;m using bundler for the environment, and came up with this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="m">0</span> 6-23 * * * /bin/bash -l -c <span class="s1">&#39;cd /home/&lt;youruser&gt;/rubyproj/rscrap &amp;&amp; bundle exec ruby scripts/reddit.rb&#39;</span>
<span class="m">0</span> 8,22 * * * /bin/bash -l -c <span class="s1">&#39;cd /home/&lt;youruser&gt;/rubyproj/rscrap &amp;&amp; bundle exec ruby scripts/gunnerkrigg.rb&#39;</span>
<span class="m">0</span> 8,22 * * * /bin/bash -l -c <span class="s1">&#39;cd /home/&lt;youruser&gt;/rubyproj/rscrap &amp;&amp; bundle exec ruby scripts/aws_blog.rb&#39;</span>
<span class="m">0</span> 5,23 * * * /bin/bash -l -c <span class="s1">&#39;cd /home/&lt;youruser&gt;/rubyproj/rscrap &amp;&amp; bundle exec ruby scripts/goblinscomic.rb&#39;</span>
<span class="m">0</span> 6,20 * * * /bin/bash -l -c <span class="s1">&#39;cd /home/&lt;youruser&gt;/rubyproj/rscrap &amp;&amp; bundle exec ruby scripts/xkcd.rb&#39;</span>
<span class="m">0</span> 7,19 * * * /bin/bash -l -c <span class="s1">&#39;cd /home/&lt;youruser&gt;/rubyproj/rscrap &amp;&amp; bundle exec ruby scripts/commitstrip.rb&#39;</span>
<span class="m">0</span> <span class="m">8</span> * * * /bin/bash -l -c <span class="s1">&#39;cd /home/&lt;youruser&gt;/rubyproj/rscrap &amp;&amp; bundle exec ruby scripts/sequiential_art.rb&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>And a telegram message for all these things, looks like this:
Reddit:
<img src="https://github.com/Skarlso/rscrap/raw/master/shorten.png" alt="TelegramIMReddit">
Comics:
<img src="https://github.com/Skarlso/rscrap/raw/master/rscrap2.png" alt="TelegramIMComics"></p>
<h1 id="conclusion">Conclusion</h1>
<p>That&rsquo;s it folks. Adding a new scraper is easy. I added the aws blog as a new entry as well by just copying the comics scripts. And I&rsquo;m also getting Weather Reports delivered every morning to me.</p>
<p>Have fun. Any questions, please feel free to leave a comment!</p>
<p>Thanks,
Gergely.</p>
]]></description>
    </item>
    
    <item>
      <title>Ruby Sieve</title>
      <link>https://skarlso.github.io/2016/07/12/ruby-sieve/</link>
      <pubDate>Tue, 12 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/07/12/ruby-sieve/</guid>
      <description type="html"><![CDATA[<p>Though it could be done better, I&rsquo;m sure, but I&rsquo;m actually pretty satisfied with this one. It loops only twice as opposed to filtered ranges and whatnot other solutions to the sieve. I was thinking of rather creating a list and deleting elements from it, but that&rsquo;s already three loops.</p>
<p>Maybe I&rsquo;ll do a benchmark later on more solutions.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="c1"># Sieve contains a function to return a set of primes</span>
<span class="k">class</span> <span class="nc">Sieve</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="vi">@n</span> <span class="o">=</span> <span class="n">n</span>
  <span class="k">end</span>

  <span class="c1"># Returns a list of primes up to a certain limit</span>
  <span class="c1"># @param n limit</span>
  <span class="c1"># @return list of primes</span>
  <span class="k">def</span> <span class="nf">primes</span>
    <span class="n">marked</span> <span class="o">=</span> <span class="o">[]</span>
    <span class="n">primes</span> <span class="o">=</span> <span class="o">[]</span>
    <span class="p">(</span><span class="mi">2</span><span class="o">..</span><span class="vi">@n</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span>
      <span class="k">unless</span> <span class="n">marked</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">primes</span><span class="o">.</span><span class="n">push</span> <span class="n">e</span>
        <span class="p">(</span><span class="n">e</span><span class="o">..</span><span class="vi">@n</span><span class="p">)</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span> <span class="n">marked</span><span class="o">.</span><span class="n">push</span> <span class="n">s</span> <span class="p">}</span>
      <span class="k">end</span>
    <span class="k">end</span>
    <span class="n">primes</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div><p>Cheers,
Gergely.</p>
]]></description>
    </item>
    
  </channel>
</rss>