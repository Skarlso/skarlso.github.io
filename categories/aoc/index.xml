<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>aoc on Ramblings of a cloud engineer</title>
    <link>https://skarlso.github.io/categories/aoc/</link>
    <description>Recent content in aoc on Ramblings of a cloud engineer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 07 Dec 2021 01:01:00 +0100</lastBuildDate><atom:link href="https://skarlso.github.io/categories/aoc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Advent Of Code - Day 7</title>
      <link>https://skarlso.github.io/2021/12/07/aoc-day7/</link>
      <pubDate>Tue, 07 Dec 2021 01:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2021/12/07/aoc-day7/</guid>
      <description><![CDATA[<h1 id="advent-of-code---day-7">Advent Of Code - Day 7</h1>
<h2 id="day-7---part-1">Day 7 - Part 1</h2>
<p>Today we got a bit of respite with an easy one. Sort of like a Dark Souls bonfire.</p>
<p><img src="/img/2021/12/07/bonfire.jpeg" alt="campfire"></p>
<p>Let&rsquo;s list our constraints.</p>
<p>Today, we face a giant whale and some crabs in submarines which are less than effective. If they only move horizontally
I have no idea how they&rsquo;ve gotten as far as you. Maybe they pivot from time to time. Or they are indigenous to this
region only.</p>
<p>In any case, the crab want to rescue you by blasting a giant hole into the ground in which you can escape. For that they
need to <em>align to a position</em>. We&rsquo;ll have to try each position for the crabs to align to to find the one which requires
the least amount of fuel ( steps ) to get to from each of the crabs.</p>
<ul>
<li>least amount of fuel</li>
<li>from each position of the crabs</li>
</ul>
<p>Okay, this isn&rsquo;t so bad. This is a simple <code>min</code> search from <code>a</code> to <code>b</code>. Which is basically the lowest crab position to
the highest crab position. We&rsquo;ll try each one of them and which ever produced the least steps for each crab to take,
wins.</p>
<p>Let&rsquo;s see some code. First, we parse the input. Just a <code>strings.Split(line, &quot;,&quot;)</code> this time. Then, we get the min and
the max of the values to look for. This is simply a <code>for ... if v &lt; min ; if v &gt; max</code>. Nothing serious.</p>
<p>Then we get to the meat. From the minimum, to the maximum, we calculate how much it would take to move to that position.
The fuel is basically, the distance taken from a to b as an absolute value. <code>abs(a-b)</code>. This is how that looks like:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">min</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">max</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">currFuel</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">crab</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">crabs</span> <span class="p">{</span>
			<span class="nx">v</span> <span class="o">:=</span> <span class="nf">abs</span><span class="p">(</span><span class="nx">i</span> <span class="o">-</span> <span class="nx">crab</span><span class="p">)</span>
			<span class="nx">currFuel</span> <span class="o">+=</span> <span class="nx">v</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">currFuel</span> <span class="p">&lt;</span> <span class="nx">minFuel</span> <span class="p">{</span>
			<span class="nx">minFuel</span> <span class="p">=</span> <span class="nx">currFuel</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>We add all that together as our fuel and compare it to the smallest we found so far. And that&rsquo;s it. We have the solution
for part1. Bring it on part 2!</p>
<h2 id="day-7---part-2">Day 7 - Part 2</h2>
<p>Okay, now we get to the fun stuff. Turns out, we actually have no idea how crab submarines work. Surprise, surprise. But
they tell us that for each move they use +1 fuel. So 1 or the first, 2 for the second, 3 for the third, etc. We do some
quick thinking and find that basically, each move requires +1 compared to the previous move. Now&hellip; You might be tempted
to change around your looping. But remember. Look for patterns! 1, 2, 3, 4&hellip;. this is a base number sequence. And what
you need is add 1, then 2, then 3, then 4 to the final sum for each move. So basically just sum the number sequence and
add it to the end result.</p>
<p>Here, the novice might be tempted to add the numbers with a for loop. But, if you remember your math class, there is a
formula for that. It&rsquo;s called the Gauss formula. But that&rsquo;s just a fancy pants words for a base number sequence sum.
It&rsquo;s (n*(1+n))/2. Or better, (n*(a1+a2))/2. You can look it up further <a href="https://mathbitsnotebook.com/Algebra2/Sequences/SSGauss.html">here</a>.</p>
<p>With that, we simply create a small function value to calculate this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">	<span class="nx">sum</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nx">n</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>And we change our loop a tiny bit:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">min</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">max</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">currFuel</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">crab</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">crabs</span> <span class="p">{</span>
			<span class="nx">v</span> <span class="o">:=</span> <span class="nf">sum</span><span class="p">(</span><span class="nf">abs</span><span class="p">(</span><span class="nx">i</span> <span class="o">-</span> <span class="nx">crab</span><span class="p">))</span> <span class="c1">// change this to add sum
</span><span class="c1"></span>			<span class="nx">currFuel</span> <span class="o">+=</span> <span class="nx">v</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">currFuel</span> <span class="p">&lt;</span> <span class="nx">minFuel</span> <span class="p">{</span>
			<span class="nx">minFuel</span> <span class="p">=</span> <span class="nx">currFuel</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>And that&rsquo;s it! With that, we have our number. Submit to AOC and that&rsquo;s another star in the bag!</p>
<p>The repository for all my solutions for AOC 2021 can be found <a href="https://github.com/Skarlso/aoc2021">here</a>.</p>
<p>Thank you for reading!</p>
<p>Gergely.</p>
]]></description>
    </item>
    
    <item>
      <title>Advent Of Code - Day 6</title>
      <link>https://skarlso.github.io/2021/12/06/aoc-day6/</link>
      <pubDate>Mon, 06 Dec 2021 01:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2021/12/06/aoc-day6/</guid>
      <description><![CDATA[<h1 id="advent-of-code---day-6">Advent Of Code - Day 6</h1>
<p>Alright. This time, we are going to learn something that AOC does from time to time&hellip; Let&rsquo;s break it down.</p>
<h2 id="day-6---part-1">Day 6 - Part 1</h2>
<p>We start off really easy. We venture around in the sea, looking for nothing but trouble. We have our squid friend with
us, whom we were telling everything about vents on the sea floor. Which happen to line up perfectly straight for some
weird reason.</p>
<p>And then we encounter a bunch of fish. Like&hellip; a LOT of fish. Nothing to worry about, right? But just in case, we map
how these fish reproduce. AOC tells us here that they might be reproducing in an exponential. And in hindsight, this
should have given us a clue on part 2. But I get ahead of myself.</p>
<p>First, let&rsquo;s list our constraints, or rules. We read the text and it&rsquo;s not a 100% clear yet. We see some text in bold,
usually those mean something. And with the number <strong>7</strong> we have our first rule.</p>
<ul>
<li>fish reproduce every 7 day</li>
</ul>
<p>We read on and we see that there is a behavior example there. Reading this requires a bit of understanding. But what
comes out of it is that..</p>
<ul>
<li>A fish has an internal clock which decreases each day.</li>
<li>When it hits 0 a new fish is created with initial timer of <strong>8</strong>.</li>
<li>The fish&rsquo;s timer is then reset to <strong>6</strong>.</li>
</ul>
<p>And that&rsquo;s it. The rest is just basically telling us that then all fish will have their timer move. The rest of the text
is basically fluff after this. We read things like, why it&rsquo;s reset to 6 and not 7. But we already know that in computer
science everything starts from 0 anyways. And it&rsquo;s usually hinted if not. Then we have some more information that the
new fish&rsquo;s timer only ticks on the new day and <strong>not</strong> on the day it was born. That&rsquo;s all fine.</p>
<p>Then we have our first example. Cool, looks really nice. Let&rsquo;s take it on.</p>
<p>Now, here I decided that upon reading this, I&rsquo;m going to create a fish struct and track the internal timer. Further, I
decided that I&rsquo;m going to let the fish take care of the <code>tick</code> event on each new day.</p>
<p>This looks like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">fish</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">timer</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">fish</span><span class="p">)</span> <span class="nf">tick</span><span class="p">()</span> <span class="o">*</span><span class="nx">fish</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nx">timer</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">f</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="mi">6</span>
		<span class="k">return</span> <span class="nf">newFish</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">timer</span><span class="o">--</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newFish</span><span class="p">()</span> <span class="o">*</span><span class="nx">fish</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">fish</span><span class="p">{</span>
		<span class="nx">timer</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Basically, once it hits 0 we create a new fish with timer 8 and reset the timer back to 6. Pretty easy.</p>
<p>We loop this in a 80 day cycle, and the length of the created list is how many fish we&rsquo;ll have. We always tick each fish
on each day ( this should have raised an alarm flag here, but I was typing fast&hellip; ).</p>
<p>The main loop looks like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">	<span class="nx">days</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">days</span> <span class="p">&lt;</span> <span class="nx">max</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">fishes</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">fish</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nf">tick</span><span class="p">();</span> <span class="nx">fish</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">fishes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">fishes</span><span class="p">,</span> <span class="nx">fish</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">days</span><span class="o">++</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Sweet. We list the length of the list, and indeed, that&rsquo;s the correct answer. We wrote a solution in about a minute or
so. Little did we know that we were about to hit in the face with a giant fish shaped fist.</p>
<h2 id="day-6---part-2">Day 6 - Part 2</h2>
<p>So, AOC does this sometimes. It present you with a simple problem and then says, okay, now do this times 1000000. And
you sit there using your machine as a heating device for the next couple days while your solution is calculating.</p>
<p>Obviously, that&rsquo;s not the right way to do it. When you face something like this, there is ALWAYS a solution which will
run withing a couple seconds. There are two solutions. You either need caching, or you need to math that sh*t out.</p>
<p>I don&rsquo;t see an obvious way of caching here, so we&rsquo;ll have to be a bit clever about it.</p>
<p>Let&rsquo;s try to think about this a bit. What is the most difficult part in this that runs to longest? Checking each and
every fish and ticking them individually. We cannot do that. That will never ever be possible. There are way too many
fish. We have to find a different angle to the problem. If we can&rsquo;t track the fishes what can we track? We can track the
number of days. But does that help us in any way?</p>
<p>Let&rsquo;s look at the example and try to see if we can find some kind of pattern as we go.</p>
<p>The ticks of the fish are the numbers of days it has left until it gives birth. All of the numbers will be in the range
of 0-8.</p>
<p>Initial day looks like this: <code>3, 4, 3, 1, 2</code>. From the example. Sometimes it helps me to sort these numbers, see if I
can make out a pattern. <code>1, 2, 3, 3, 4</code>. Okay, we see there are two fishes which are on the same cycle. If, like we said,
we are trying to track the days instead of the fish, take a look how many fishes on a day there are.</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Okay, let&rsquo;s manually go and one-by-one increase the days and count the fish. Maybe we&rsquo;ll see an emerging pattern.</p>
<p>Day 1:</p>
<p><code>After  1 day:  2,3,2,0,1</code></p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Immediately we see something very cool. The numbers all remained the same, but <strong>they shifted by one to the left</strong>.</p>
<p>Let&rsquo;s keep going.</p>
<p><code>After  2 days: 1,2,1,6,0,8</code></p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Now we get to one of the rules. Once a fish reaches <code>0</code>, there is a new fish and we reset the current fish to <code>6</code>.
What does that mean in our little table? Who was <code>0</code> before will be a <code>6</code> and an <code>8</code> now. Which means on the next
day we can see that it will be <code>2, 0, 0, 0, 0, 1, 1, 1, 1</code> without even checking. Because our two <code>1</code>s will be <code>0</code>s
on the next day and our one <code>2</code> will be a <code>1</code> and we get a new fish because we had a <code>0</code>. But let&rsquo;s check to make sure.</p>
<p><code>After  3 days: 0,1,0,5,6,7,8</code></p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>And indeed, our assumption was right. But how do we track the increase? <code>6</code>s will increase and <code>8</code>s will track the new
number of incoming fish.</p>
<p>So what does this tell us? It will help us keep track of the count of fish
on each days. How do we get the total number of fish then? We&rsquo;ll just sum up the numbers in this list.</p>
<p>Let&rsquo;s see some code. We start off by creating our initial list with the right number of fish from our input:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">	<span class="nx">days</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">fishes</span> <span class="p">{</span>
		<span class="nx">days</span><span class="p">[</span><span class="nx">f</span><span class="p">]</span><span class="o">++</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This will produce our starting numbers. Now, what&rsquo;s our cycle? Each day our fishes shift one to the left. With
one tiny rule that the <code>0</code>s will become <code>8</code>s and <code>6</code>s. Because they birth a new fish and they reset their timer
back to <code>6</code>. Shifting the numbers is easy, we just assign the next item to the current item. But we save the <code>0</code>
first. And we create as many <code>6</code>s and <code>8</code>s as there were <code>0</code>s.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">max</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">first</span> <span class="o">:=</span> <span class="nx">days</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">days</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">days</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="nx">days</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">first</span> <span class="c1">// we add them because there might be `6`s from the previous day too we don&#39;t want to override those.
</span><span class="c1"></span>		<span class="nx">days</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="p">=</span> <span class="nx">first</span> <span class="c1">// there are as many new fish as there were `0`s on the previous day
</span><span class="c1"></span>	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Next, we sum up the numbers:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">days</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">f</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;number of fish: &#34;</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>And we are done. We run on our input, and this produces the right number pretty quickly instead of a year or a thousand.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Phew, this one was a nice one! It prepared us for thinking a bit instead of blindly following the rules on the first part.
It helps to take a look at the numbers and draw them out one by one on a piece of paper or on the computer or anywhere. Just
trace the numbers by hand, which will surely make you see a pattern in all of it.</p>
<p>And remember, that there is always a solution which will run fast. Whether it&rsquo;s caching or a bit of math. And again, don&rsquo;t be
afraid to ask for clues! The people in the reddit forum are super nice and they will give you hints without spoiling the end
result.</p>
<p>The repository for all my solutions for AOC 2021 can be found <a href="https://github.com/Skarlso/aoc2021">here</a>.</p>
<p>Thank you for reading!</p>
<p>Gergely.</p>
]]></description>
    </item>
    
    <item>
      <title>Advent Of Code - Day 5</title>
      <link>https://skarlso.github.io/2021/12/05/aoc-day5/</link>
      <pubDate>Sun, 05 Dec 2021 01:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2021/12/05/aoc-day5/</guid>
      <description><![CDATA[<h1 id="advent-of-code---day-5">Advent of Code - Day 5</h1>
<p>Alright. Today, we are going to learn something that will be useful to us in the coming days.</p>
<p>Let&rsquo;s see what we are dealing with.</p>
<h2 id="day-5---part-1">Day 5 - Part 1</h2>
<p>We deal with vents today. The sea is a dangerous place after all. Fortunately for us, these vents line up perfectly so
Santa can dodge them easily. We get a bunch of coordinates which form lines basically. The wording is pretty weird, says one
end and the other. But these are just begin and end coordinates in a 2D grid.</p>
<p>We see the example, and it&rsquo;s a 2D grid with lines drawn over. Let&rsquo;s list our rules.</p>
<ul>
<li>lines with start x, y coordinates and end x, y coordinates</li>
<li>only consider vertical and horizontal lines</li>
<li>count the number of points where lines intersect</li>
</ul>
<p>Now, this seems like a problem for which you can use a 2D matrix. A coordinate system. But what if I tell you that you
don&rsquo;t need that. Why? Let&rsquo;s think about this problem for a little bit. What do you need? You need a way to track some
points. You need a way to see if <code>a</code> point already occurred or not&hellip; Aka, was an intersection point of two or more lines.
What could help you track if a certain point, a certain data, was already encountered or not? What could be something
that could we could use to easily and quickly access a value using another value? Have a little think. Go on, I&rsquo;ll wait.</p>
<p>Okay, here we go. It&rsquo;s a <code>map</code>. Or a <code>dict</code>. Or an <code>associative array</code>. That&rsquo;s right, that&rsquo;s all we need. A map which
can track if we encountered a point before. The map key is <code>x, y</code> together and the value is a simple count.</p>
<p>In Go, we use a <code>struct</code> for that like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">point</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>And then our map is like this: <code>seaFloor := make(map[point]int)</code>.</p>
<p>Alright let&rsquo;s scan our input. We use our trusty <code>Sscanf</code> function again, because the input follows a nice format:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">l</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">split</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="p">(</span>
			<span class="nx">x1</span><span class="p">,</span> <span class="nx">x2</span> <span class="kt">int</span>
			<span class="nx">y1</span><span class="p">,</span> <span class="nx">y2</span> <span class="kt">int</span>
		<span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Sscanf</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="s">&#34;%d,%d -&gt; %d,%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">x1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">y1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">x2</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">y2</span><span class="p">)</span>

		<span class="nx">lines</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">lines</span><span class="p">,</span> <span class="nx">line</span><span class="p">{</span>
			<span class="nx">begin</span><span class="p">:</span> <span class="nx">point</span><span class="p">{</span><span class="nx">x</span><span class="p">:</span> <span class="nx">x1</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="nx">y1</span><span class="p">},</span>
			<span class="nx">end</span><span class="p">:</span>   <span class="nx">point</span><span class="p">{</span><span class="nx">x</span><span class="p">:</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="nx">y2</span><span class="p">},</span>
		<span class="p">})</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Now, I know that we said, that a map is enough and you don&rsquo;t need a 2D map. But how do we check horizontally and
vertically then? Well, what is horizontal vertical? We check the sample.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">0,9 -&gt; 5,9
8,0 -&gt; 0,8
9,4 -&gt; 3,4
2,2 -&gt; 2,1
7,0 -&gt; 7,4
6,4 -&gt; 2,0
0,9 -&gt; 2,9
3,4 -&gt; 1,4
0,0 -&gt; 8,8
5,5 -&gt; 8,2
</code></pre></td></tr></table>
</div>
</div><p>Out of these, horizontal and vertical only mean that ONE OF THE COORDINATES EQUALS. And the other either increases or
decreases.</p>
<p>Okay, so we track if we need to add or subtract 1 to a number. Because &ldquo;drawing a line&rdquo; is literally just increasing
the coordinate. One of them at least.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">l</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">lines</span> <span class="p">{</span>
    <span class="nx">addx</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="nx">addy</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><p>So when do we increase x and when y? If one of them is greater or smaller than the other.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">l</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">lines</span> <span class="p">{</span>
    <span class="nx">addx</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="nx">addy</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">begin</span><span class="p">.</span><span class="nx">x</span> <span class="p">&gt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">end</span><span class="p">.</span><span class="nx">x</span> <span class="p">{</span>
        <span class="nx">addx</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">begin</span><span class="p">.</span><span class="nx">x</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">end</span><span class="p">.</span><span class="nx">x</span> <span class="p">{</span>
        <span class="nx">addx</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>We do that with y as well. But&hellip; This will result in both x and y increasing at the same time if neither of them equal.
That would be&hellip; diagonal! We ignore that. We could say at the begin, something like, if neither of them equal, <code>continue</code>.</p>
<p>For now I just skip if both addx and addy are not 0. Then comes our for loop. We have to &ldquo;draw a line&rdquo; from a starting
point to and end point. So we just start adding the <code>addN</code> to the respective number until they match the end coordinate.</p>
<p>And once we have a new coordinate we save that in our map. And if the map already contains it, we just increase that by
one. In Go, that&rsquo;s easy, because things in the map have a default value. For <code>int</code> that&rsquo;s 0. Which is perfect for us.</p>
<p>Our for loop looks like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">		<span class="k">for</span> <span class="nx">startX</span> <span class="o">!=</span> <span class="nx">targetX</span> <span class="o">||</span> <span class="nx">startY</span> <span class="o">!=</span> <span class="nx">targetY</span> <span class="p">{</span>
			<span class="nx">seaFloor</span><span class="p">[</span><span class="nx">point</span><span class="p">{</span><span class="nx">x</span><span class="p">:</span> <span class="nx">startX</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="nx">startY</span><span class="p">}]</span><span class="o">++</span>

			<span class="nx">startX</span> <span class="o">+=</span> <span class="nx">addX</span>
			<span class="nx">startY</span> <span class="o">+=</span> <span class="nx">addY</span>
		<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Easy. Except I had a small bug here, where I forgot to add the last item as well.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">		<span class="nx">seaFloor</span><span class="p">[</span><span class="nx">point</span><span class="p">{</span><span class="nx">x</span><span class="p">:</span> <span class="nx">startX</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="nx">startY</span><span class="p">}]</span><span class="o">++</span>
</code></pre></td></tr></table>
</div>
</div><p>Now, we are ready to count overlaps. Which will just be going through the map and doing a <code>count++</code> in case a value in
the map is greater than 1.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">	<span class="nx">overlaps</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">seaFloor</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">v</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="nx">overlaps</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;overlaps: &#34;</span><span class="p">,</span> <span class="nx">overlaps</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>And done! That&rsquo;s all. No need for a 2D map or tracking coordinates or walking around with nested for loops.</p>
<p>We run this on the test and our sample input and we got the right result!</p>
<h2 id="day-5---part-2">Day 5 - Part 2</h2>
<p>We check part 2 and guess what!! The only change is that we have to also run diagonally. What luck!?</p>
<p>I just remove the <code>addx</code> and <code>addy</code> check and we have part 2 done.</p>
<h2 id="conclusion">Conclusion</h2>
<p>And that&rsquo;s it! We are done for today. We learned that we don&rsquo;t always need a matrix to solve problems with coordinates.
We have to keep an open mind and find the right data to represent our problem. The right data will solve 50% of the puzzle.</p>
<p>The repository for all my solutions for AOC 2021 can be found <a href="https://github.com/Skarlso/aoc2021">here</a>.</p>
<p>Thank you for reading!</p>
<p>Gergely.</p>
]]></description>
    </item>
    
    <item>
      <title>Advent Of Code - Day 4</title>
      <link>https://skarlso.github.io/2021/12/04/aoc-day4/</link>
      <pubDate>Sat, 04 Dec 2021 01:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2021/12/04/aoc-day4/</guid>
      <description><![CDATA[<h1 id="advent-of-code---day-4">Advent of Code - Day 4</h1>
<p><strong>Disclaimer</strong>: There is surely a better solution than this one. But I&rsquo;m fairly okay with this one. And I wrote it, so&hellip;</p>
<p>Okay, this day was a bit more complex now. But not in understanding what needed to be done, but implementing it. And
then, part two of course.</p>
<h2 id="day-4---part-1">Day 4 - Part 1</h2>
<p>We met a squid this day and decided to play a round of Bingo with it. Because, why not? Bingo is a simple game. You have
several papers on which there are a couple numbers in a square. Someone draws a number, and you need to find that number
on your boards, cards, slips, whatevers. Once you have marked 5 numbers in a row, or a column ( or, in the original game
diagonal also goes ) you win.</p>
<p>Easy. You have a matrix. Get a number. Mark the numbers in the matrix which equal to the drawn number.</p>
<p>I&rsquo;m gonna follow this logic. There might be better ones where you can calculate things based on some math, I encourage
you to look at different solutions as well.</p>
<p>First, we parse the input. Get the first line, and then skip the first two so we can get to the numbers.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">l</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">split</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">l</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="nx">boards</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">boards</span><span class="p">,</span> <span class="nx">board</span><span class="p">)</span>
			<span class="nx">board</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="nx">nums</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Fields</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span>
		<span class="nx">n</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">number</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span> <span class="p">{</span>
			<span class="nx">i</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">number</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">n</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">board</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">board</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This should do it. Now, there is a small surprise here. The numbers in the matrix are not separated by just a single
space. They are separated by multiple ones. This is just a small extra to mess with your head. Lucky for us, Go has us
covered with <a href="https://pkg.go.dev/strings#Fields">strings.Fields</a>. This will retrieve just the numbers without the spaces.</p>
<p>Now, we get to the main logic&hellip; Draw, mark, see if we have a winning board, calculate score.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span> <span class="p">{</span>
		<span class="nf">markBoards</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">boards</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">winner</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">hasWinner</span><span class="p">(</span><span class="nx">boards</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;winner score: &#34;</span><span class="p">,</span> <span class="nf">calculateScore</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">winner</span><span class="p">))</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;winner board: &#34;</span><span class="p">,</span> <span class="nx">winner</span><span class="p">)</span>
			<span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Pretty easy. Marking the board is just going through all the boards in the list of boards and do a <code>for i, for j</code> to get
at the right number and change that number to <code>-1</code>. Why does <code>-1</code> work? Because if we read on, the score is calculated by
going through the board and adding up UNMARKED numbers. So we don&rsquo;t need any special way to keep track of marked numbers.
We just care about the unmarked ones.</p>
<p>Now, <code>hasWinner</code> is a bit more complex, but just because we need to check horizontally and vertically. And we have to
remember that we have to stop immediately once we found a winner.</p>
<p>I&rsquo;m sure there is a better way to do this, but I just went for two loops:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">hasWinner</span><span class="p">(</span><span class="nx">boards</span> <span class="p">[][][]</span><span class="kt">int</span><span class="p">)</span> <span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">board</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">boards</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">board</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// check vertically
</span><span class="c1"></span>			<span class="nx">rowWon</span> <span class="o">:=</span> <span class="kc">true</span>
			<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
					<span class="nx">rowWon</span> <span class="p">=</span> <span class="kc">false</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">rowWon</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">board</span><span class="p">,</span> <span class="kc">true</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// these are 5x5 and not varring in size.
</span><span class="c1"></span>		<span class="nx">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">board</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">for</span> <span class="nx">col</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">col</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">col</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">colWon</span> <span class="o">:=</span> <span class="kc">true</span>
			<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">board</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">col</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
					<span class="nx">colWon</span> <span class="p">=</span> <span class="kc">false</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">colWon</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">board</span><span class="p">,</span> <span class="kc">true</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>And then the calculation is just again going through and doing the adding and then the multiplication.</p>
<p>We run it on our test data and input and it works. Fantastic. On to part 2!</p>
<h2 id="day-4---part-2">Day 4 - Part 2</h2>
<p>Part 2 is just about finding the last winning board. Great! We are already geared towards that. Once we find a winning
board we remove that board and begin again. We do this until there are no boards left. I&rsquo;m not sure how that will make
sure that the squid wins, I don&rsquo;t understand that part to be honest, but that&rsquo;s not our goal.</p>
<p>For this, we slightly alter our main loop like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">boards</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span> <span class="p">{</span>
			<span class="nf">markBoards</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">boards</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">loc</span><span class="p">,</span> <span class="nx">winner</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">hasWinner</span><span class="p">(</span><span class="nx">boards</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;winner score: number: %d, score: %d, loc: %d\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nf">calculateScore</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">winner</span><span class="p">),</span> <span class="nx">loc</span><span class="p">)</span>
				<span class="nx">boards</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">boards</span><span class="p">[:</span><span class="nx">loc</span><span class="p">],</span> <span class="nx">boards</span><span class="p">[</span><span class="nx">loc</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This will display all boards which win. I don&rsquo;t really care about that, again, I could have just checked the last, or
save all or when <code>len==1</code> check it. But this was the fastest, easiest way to do it. And as I said in the begin, these are
small scripts which I will probably never look at again, so I don&rsquo;t care about maintainability. I care that it&rsquo;s
efficient, fast and easy to read / write.</p>
<p>We run this, and it works on the test and the input. And that&rsquo;s it for part 2!</p>
<h2 id="conclusion">Conclusion</h2>
<p>We learned again that reading things and understanding can be hard. The samples can be daunting, but don&rsquo;t let yourself
be intimidated. And never be afraid to ask questions, look at what other people are doing especially if you just started
doing AOC this year.</p>
<p>But most importantly, have fun with it!</p>
<p>The repository for all my solutions for AOC 2021 can be found <a href="https://github.com/Skarlso/aoc2021">here</a>.</p>
<p>Thank you for reading!</p>
<p>Gergely.</p>
]]></description>
    </item>
    
    <item>
      <title>Advent Of Code - Day 3</title>
      <link>https://skarlso.github.io/2021/12/03/aoc-day3/</link>
      <pubDate>Fri, 03 Dec 2021 01:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2021/12/03/aoc-day3/</guid>
      <description><![CDATA[<h1 id="advent-of-code---day-3">Advent Of Code - Day 3</h1>
<p>Here we go for day 3!</p>
<p>This day was a tiny bit more complex. A lot of more things to read for sure! But all the more exciting!</p>
<p>Let&rsquo;s get to it!</p>
<h2 id="day-3---part-1">Day 3 - Part 1</h2>
<p>We are dealing with binary numbers. At fist glance it can be daunting, but it&rsquo;s actually not that complicated.
We have to find two numbers. <code>gamma rate</code> and <code>epsilon rate</code>. To do that, we have to parse some binary numbers
and then convert them to decimal. The two numbers can be found by looking for the most common bit at a given
position in all of the numbers and the least common one at a given position in all of the given numbers. Better
put, as we read on, find the bit that occurs most of the time and the one that occurs least of the time in all
numbers and put them together. That&rsquo;s your new number.</p>
<p>As always, let&rsquo;s write out our constraints first!</p>
<ul>
<li>we have a list of binary numbers</li>
<li>we have to go through all of them and check a certain position for all of them</li>
<li>find the most occurring number ( either 0, or 1 ) that occurs at position <code>n</code></li>
<li>append this number to a new number that is being constructed <code>result</code></li>
</ul>
<p>Okay, so&hellip; loop through the numbers, as we loop, check all of the numbers at position 0, 1, 2, 3&hellip; and check
which digit occurs most and least. Add the most one to the <code>gamma rate</code> and the least one to the <code>epsilon rate</code>.</p>
<p>This needs a bit of a brain wrap. We will loop through all the numbers, but we will also loop through all the numbers
again but check a certain position. Meanwhile, we track the number of zeros and ones we count.</p>
<p>This will result in two loops. The first loop goes as long as the numbers are. And the second goes as many times
as many numbers there are.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">    <span class="c1">// Loop as much as long the numbers are...
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">zeros</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="nx">ones</span> <span class="o">:=</span> <span class="mi">0</span>

        <span class="c1">// loop through all the numbers and check digit location.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
            <span class="c1">// count ones and zeros
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span> <span class="p">{</span>
				<span class="nx">zeros</span><span class="o">++</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">ones</span><span class="o">++</span>
			<span class="p">}</span>
		<span class="p">}</span>

        <span class="c1">// if zeros are larger gamma is 0 epsilon is 1.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">zeros</span> <span class="p">&gt;</span> <span class="nx">ones</span> <span class="p">{</span>
			<span class="nx">gamma</span> <span class="o">+=</span> <span class="s">&#34;0&#34;</span>
			<span class="nx">epsilon</span> <span class="o">+=</span> <span class="s">&#34;1&#34;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// if ones are larger, gamma is 1 epsilon is 0.
</span><span class="c1"></span>			<span class="nx">gamma</span> <span class="o">+=</span> <span class="s">&#34;1&#34;</span>
			<span class="nx">epsilon</span> <span class="o">+=</span> <span class="s">&#34;0&#34;</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This will result in the right gamma and epsilon numbers, but we aren&rsquo;t done yet there. We have to convert
this to decimal. Lucky for us, Go provides tools for this. We simple call <code>strconv.ParseInt</code> like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">	<span class="nx">g</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nx">gamma</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
	<span class="nx">e</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nx">epsilon</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;result: &#34;</span><span class="p">,</span> <span class="nx">g</span> <span class="o">*</span> <span class="nx">e</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>And that&rsquo;s it. We have our power consumption. On to Part 2!</p>
<h2 id="day-3---part-2">Day 3 - Part 2</h2>
<p>Now that&rsquo;s a doozy! That is a LOT of text&hellip; Let&rsquo;s try breaking it down. AOC now will teach you how to read.
This is actually an important skill to acquire. A lot of times you will have to parse a lot of text and try
to figure out what the actual task is.</p>
<p>Again, we are looking for two numbers. <code>oxygen generator rating</code> and <code>CO2 scrubber rating</code>. Now, it&rsquo;s important
again, to identify certain aspects here. Like last time I talked about that there are things which you can
take for granted. Things and rules which will make it easier to find something or will define an exit criteria
for a search or a filter. Reading here, we find such an exit criteria:</p>
<blockquote>
<p>process that involves filtering out values until only one remains.</p>
</blockquote>
<p>We have to filter the numbers <strong>until only one remains</strong>. This is important. You can be sure that the result
will always be a single number out of the list of numbers. That&rsquo;s your exit criteria. You can stop once your
list is filtered to a single number.</p>
<p>The next sentence I actually find confusing.</p>
<blockquote>
<p>Before searching for either rating value, start with the full list of binary numbers from your diagnostic
report and consider just the first bit of those numbers.</p>
</blockquote>
<p>For me this implies that I would have to do something with the numbers before I start search. This is not true.
It&rsquo;s actually just outlining what you filter criteria will be&hellip; which is:</p>
<ul>
<li>start with the first bit</li>
<li>selected numbers based on a predicate (described later as <em>bit criteria</em>)</li>
<li>if you have one number left, stop</li>
<li>continue with the next bit</li>
</ul>
<p>So what are the bit criteria?</p>
<p>Each number has its own definition of criteria that it needs.</p>
<p><strong>oxygen generator rating</strong>:</p>
<ul>
<li>the most common value in a bit position</li>
<li>if equal keep the 1s</li>
</ul>
<p><strong>CO2 scrubber rating</strong>:</p>
<ul>
<li>the least common value in a bit position</li>
<li>if equal keep the 0s</li>
</ul>
<p>Then we have a nice and detailed example for both of the values. Basically, we&rsquo;ll have two loops and we duplicate
our list of numbers. Both loops will delete numbers based on the predicate until only a single number remains. All
the while going through the bit positions until it&rsquo;s done.</p>
<p>The basic algorithm looks like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">filter</span><span class="p">(</span><span class="nx">list</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">pred</span> <span class="kd">func</span><span class="p">(</span><span class="nx">zeros</span><span class="p">,</span> <span class="nx">ones</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="c1">// Start at position zero.
</span><span class="c1"></span>	<span class="nx">bitPosition</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="c1">// until there is only a single left...
</span><span class="c1"></span>	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nx">zeros</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="nx">ones</span> <span class="o">:=</span> <span class="mi">0</span>

        <span class="c1">// same as before, we count the ones and zeros
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">o</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">list</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">o</span><span class="p">[</span><span class="nx">bitPosition</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span> <span class="p">{</span>
				<span class="nx">zeros</span><span class="o">++</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">ones</span><span class="o">++</span>
			<span class="p">}</span>
		<span class="p">}</span>

        <span class="c1">// we decide which number / position to keep
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">bit</span> <span class="kt">byte</span>
        <span class="c1">// based on the predicate, ones and zeros, decide which number will be kept.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nf">pred</span><span class="p">(</span><span class="nx">zeros</span><span class="p">,</span> <span class="nx">ones</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">bit</span> <span class="p">=</span> <span class="sc">&#39;1&#39;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">bit</span> <span class="p">=</span> <span class="sc">&#39;0&#39;</span>
		<span class="p">}</span>
        <span class="c1">// remove the numbers which are not needed
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">list</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">list</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">bitPosition</span><span class="p">]</span> <span class="o">==</span> <span class="nx">bit</span> <span class="p">{</span>
				<span class="nx">list</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">list</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span> <span class="nx">list</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span>
				<span class="nx">i</span><span class="o">--</span>
			<span class="p">}</span>
		<span class="p">}</span>
        <span class="c1">// check the next bit position
</span><span class="c1"></span>		<span class="nx">bitPosition</span><span class="o">++</span>
	<span class="p">}</span>
    <span class="c1">// return
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>And our predicates look like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">	<span class="nx">oxygen</span> <span class="o">:=</span> <span class="nf">filter</span><span class="p">(</span><span class="nx">oxygens</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">zeros</span><span class="p">,</span> <span class="nx">ones</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">zeros</span> <span class="p">&gt;</span> <span class="nx">ones</span>
	<span class="p">})</span>
	<span class="nx">co2</span> <span class="o">:=</span> <span class="nf">filter</span><span class="p">(</span><span class="nx">co2s</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">zeros</span><span class="p">,</span> <span class="nx">ones</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">zeros</span> <span class="p">&lt;</span> <span class="nx">ones</span> <span class="o">||</span> <span class="nx">zeros</span> <span class="o">==</span> <span class="nx">ones</span>
	<span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>For oxygens, we are looking for most common values, otherwise it&rsquo;s not needed. And for co2s we
are looking for the least common values and if they equal, we want the zeros.</p>
<p>And that&rsquo;s pretty much it. Parsing and finding and understanding the problem was a bit harder this time
around, but it will get a lot more convoluted after this.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We got a taste of what longer and more convoluted descriptions will look like. We got prepared for reading.
We learned a bit about <code>strconv.ParseInt</code>. Maybe it will be handy later.</p>
<p>BTW this is something that is called trivially parallel. We could easily call these in a Go routine. But it
wouldn&rsquo;t matter since our sample size is rather small. Just keep in mind to keep an eye out for these.</p>
<p>The repository for all my solutions for AOC 2021 can be found <a href="https://github.com/Skarlso/aoc2021">here</a>.</p>
<p>Thank you for reading!</p>
<p>Happy coding!</p>
<p>Gergely.</p>
]]></description>
    </item>
    
    <item>
      <title>Advent Of Code - Day 2</title>
      <link>https://skarlso.github.io/2021/12/02/aoc-day2/</link>
      <pubDate>Thu, 02 Dec 2021 01:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2021/12/02/aoc-day2/</guid>
      <description><![CDATA[<h1 id="advent-of-code---day-2">Advent Of Code - Day 2</h1>
<p>Here we go for day 2!</p>
<p>These first couple of problems prepare you on how to deal with input mainly. Learn and get used to parsing lines, and
get comfortable with data structures.</p>
<h2 id="day-2---part-1">Day 2 - Part 1</h2>
<p>We continue the story of Santa and the submarine. This time, he has the task of trying to steer the thing.
The task is straightforward. You get a couple of instructions and based on a value you increase or decrease a positions.</p>
<p>We have a choice to make here. The wording says horizontal position and depth. Considering the future of these exercises
we could go with variable names <code>horizontal</code> and <code>depth</code>. But I choose <code>x</code> and <code>y</code>. Why did I do that? That sounds like
I&rsquo;m not considering the right variable names. But I&rsquo;m preparing for the inevitable 2D coordinates that will definitely
come. You might as well get comfortable dealing with them now.</p>
<p>So, what are our constraints?</p>
<p>This time, it&rsquo;s quite clear and neatly packaged:</p>
<ul>
<li>forward X increases the horizontal position by X units.</li>
<li>down X increases the depth by X units.</li>
<li>up X decreases the depth by X units.</li>
</ul>
<p>Now comes a sentence I think is there only to confuse you. It might be not, but I swear I had to take a second look at
that. The above constraints are clear and easy to follow. And then comes this sentence and makes me take spend a little
bit more time on parsing them:</p>
<blockquote>
<p>Note that since you&rsquo;re on a submarine, down and up affect your depth, and so they have the opposite result of what you might expect.</p>
</blockquote>
<p>No, they are not. According to the constraints I expect down to increase depth and up to decrease depth. It&rsquo;s clearly
written there. I believe this sentence should just be ignored.</p>
<p>Let&rsquo;s get to solving this thing. We read the rest of the thing, and get to our test input.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">forward 5
down 5
forward 8
up 3
down 8
forward 2
</code></pre></td></tr></table>
</div>
</div><p>What comes now, is trying to parse the input. In Go, <code>Scanf</code> is an option. In other languages, you might want to just
<code>Split(s, &quot; &quot;)</code> split by space. In Go I&rsquo;m using this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">		<span class="kd">var</span> <span class="p">(</span>
			<span class="nx">op</span> <span class="kt">string</span>
			<span class="nx">v</span>  <span class="kt">int</span>
		<span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Sscanf</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">l</span><span class="p">),</span> <span class="s">&#34;%s %d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">v</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>What&rsquo;s happening here is that <code>l</code> is a line from the above sample in a file ( reading line by line ). <code>&quot;%s %d&quot;</code> is saying
scan for strings and then scan for a number. And the <code>&amp;op, &amp;v</code> just puts the result in their respective values.</p>
<p>We have the result now in values. Let&rsquo;s implement the above three rules.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">switch</span> <span class="nx">op</span> <span class="p">{</span>
<span class="k">case</span> <span class="s">&#34;forward&#34;</span><span class="p">:</span>
    <span class="nx">x</span> <span class="o">+=</span> <span class="nx">v</span>
<span class="k">case</span> <span class="s">&#34;up&#34;</span><span class="p">:</span>
    <span class="nx">y</span> <span class="o">-=</span> <span class="nx">v</span>
<span class="k">case</span> <span class="s">&#34;down&#34;</span><span class="p">:</span>
    <span class="nx">y</span> <span class="o">+=</span> <span class="nx">v</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Pretty neat. Could be an <code>if</code>. Could be made tidier. Doesn&rsquo;t really matter as long as it solves the problem at hand. Competitive
scripts usually are not meant to be maintainable masterpieces.</p>
<p>It gets the job done. Then we continue by reading what the actual result should be and we see that we just have to multiple
horizontal position with depth. Which is <code>x * y</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;mult: &#34;</span><span class="p">,</span> <span class="nx">x</span><span class="o">*</span><span class="nx">y</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>This gets us the right test value and, in fact, the right value to our input as well.</p>
<p>Here, I would like to mention that you always have to deal with things like empty new lines, and spaces after a line. So always
<code>trim</code> and make sure you don&rsquo;t accidentally parse an empty line as a valid input.</p>
<h2 id="day-2---part-2">Day 2 - Part 2</h2>
<p>Now, things get a bit more complex. Turns out we aren&rsquo;t actually parsing the coordinates correctly, so there are some
new constraints. What are they?</p>
<p>We have a new value, <code>aim</code>. And a new set of constraints:</p>
<ul>
<li>down X increases your aim by X units.</li>
<li>up X decreases your aim by X units.</li>
<li>forward X does two things:
<ul>
<li>It increases your horizontal position by X units.</li>
<li>It increases your depth by your aim multiplied by X.</li>
</ul>
</li>
</ul>
<p>Again, just ignore the fluff around this this time, because it&rsquo;s more distracting than helpful. Sometimes it contains some weird extra
info, but this time, I found them to be a bit misleading. The actual problem is super simple.</p>
<p>We change our implementation to increase decrease <code>aim</code> and do the thing for <code>x</code> and <code>y</code> a bit differently.</p>
<p>Following the rules we get to this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">switch</span> <span class="nx">op</span> <span class="p">{</span>
<span class="k">case</span> <span class="s">&#34;forward&#34;</span><span class="p">:</span>
    <span class="nx">x</span> <span class="o">+=</span> <span class="nx">v</span>
    <span class="nx">y</span> <span class="o">+=</span> <span class="p">(</span><span class="nx">aim</span> <span class="o">*</span> <span class="nx">v</span><span class="p">)</span>
<span class="k">case</span> <span class="s">&#34;up&#34;</span><span class="p">:</span>
    <span class="nx">aim</span> <span class="o">-=</span> <span class="nx">v</span>
<span class="k">case</span> <span class="s">&#34;down&#34;</span><span class="p">:</span>
    <span class="nx">aim</span> <span class="o">+=</span> <span class="nx">v</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Then we carefully read what has to be done to get the result and we see that it actually did not change.
We still multiple <code>x</code> and <code>y</code>.</p>
<p>And indeed, this is the correct result for our test, so we run it for our input and that should yield the right value.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This day now showed you that input comes in various forms and formats which you need to be prepared to parse correctly.
We made sure that we skip empty new lines and always trim possible spaces. And we got to know <code>Sscanf</code> which can be handy
at times if the format is strict enough.</p>
<p>We also learned to read important information and disregard things which can distract from the actual goal.</p>
<p>The repository for all my solutions for AOC 2021 can be found <a href="https://github.com/Skarlso/aoc2021">here</a>.</p>
<p>Thank you for reading!</p>
<p>Happy coding!</p>
<p>Gergely.</p>
]]></description>
    </item>
    
    <item>
      <title>Advent Of Code - Day 1</title>
      <link>https://skarlso.github.io/2021/12/01/aoc-day1/</link>
      <pubDate>Wed, 01 Dec 2021 01:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2021/12/01/aoc-day1/</guid>
      <description><![CDATA[<h1 id="advent-of-code---day-1">Advent Of Code - Day 1</h1>
<p>Since 2015, <a href="https://adventofcode.com/">Advent Of Code</a> has been a part of my life. I&rsquo;ve done various posts on it already, but this year will be different.
I&rsquo;m going to blog every day every solution, why and how I&rsquo;ve gotten to that solution.</p>
<p>This isn&rsquo;t going to be ever December, because I&rsquo;m usually unable to solve a problem on a single day in the later days from day 10 or so. It takes more time then I have.
But I will solve all of them. At the time of this writing, I have completed almost all puzzles except for year 2019 which I didn&rsquo;t much enjoy to be honest.</p>
<p><img src="/img/2021/12/01/stars.png" alt="Events"></p>
<h2 id="a-bit-of-history-before-we-begin">A bit of history before we begin</h2>
<p>I first heard of Advent Of Code when I joined <a href="https://cheppers.com/">Cheppers</a> back in 2015. It was a great journey, and I loved every moment if it, but eventually I moved on.
Advent of code, however, stayed with me over these past years. As someone without a formal CS education, I&rsquo;m using these puzzles to catch up things I might have missed out. Everything I know I learned either by my self, or from books or videos or on the job. I begun coding at an early year and it stuck with me.</p>
<p>I really struggled with some of these problems, and I haven&rsquo;t been able to completely solve a single year so far without seeking help. Every year, I&rsquo;m getting closer and closer to solving all of the days, but it hasn&rsquo;t happened yet.</p>
<p>It was amazing in identifying my weak areas. Things like, geometry problems ( I have forgotten everything from school ) ( asteroids had to be shot down going in a circle on a 2d matrix ), permutation problems, graph traversal, BFS, DFS, backtracking&hellip; As someone who never really had to deal with these things, I really lacked the know how.</p>
<p>As the years went by, and I solved all of the puzzles this way or that, and looked at what other people were cooking up, I begun to see that I started to improve in some of these areas.</p>
<p>I know why I didn&rsquo;t improve in the areas I would have liked to improve in. And that is, lack of reflection. What do I mean by that? I solved the problem, read someone&rsquo;s solution, then went on with my life. The way to get better at something is through reflection and recall though. And I didn&rsquo;t do either.</p>
<p>So this year, I&rsquo;m going to reflect and recall all my solutions, and even though I might need help in the later days, I will never use anyone else&rsquo;s code. I will always write my own. And then, reflect upon it, by writing a post and talking about why this solution works or how I&rsquo;ve gotten to it.</p>
<p>I also decided to finally create an SDK with all the common functions I&rsquo;m using.</p>
<h2 id="day-1">Day 1</h2>
<p>History out of the way, let&rsquo;s break down day 1.</p>
<h3 id="part-1">Part 1</h3>
<p>As usual, the first couple days are warmup. Easy problems to get your brain started into the right move and set up the story. Which is my favorite thing in all of this! Reasons why AOC is so awesome, is that it has an actual story!
It isn&rsquo;t just leetcode, or spoj or codewars or whatever. There is an actual story and it&rsquo;s hilarious and a good read. And the problems aren&rsquo;t just, solve x, solve y. They usually are diverse in some sense.</p>
<p>Part 1 this year, sets us up on a wild ride under the sea. The keys dropped into the water and we hopped into a submarine to go after it.</p>
<p>Let&rsquo;s examine the problem.</p>
<p>How do I read AOC problems? First, I&rsquo;m reading the story. I&rsquo;m not in a hurry. I don&rsquo;t want to be on the leader board. That&rsquo;s not gonna happen. Then, I&rsquo;m examining the problems and write down all the constraints ( aka, rules ).</p>
<p>For Part 1:</p>
<ul>
<li>we have a set of numbers</li>
<li>they are all positive integers ranging from 100 - 9999 ( it&rsquo;s important to identify your working sample as your solution depends on it )
<ul>
<li>which means we can assume that there won&rsquo;t be any negative numbers, floats, complex numbers, etc. ( narrows down the solution sample size )</li>
</ul>
</li>
</ul>
<blockquote>
<p>The first order of business is to figure out how quickly the depth increases, just so you know what you&rsquo;re dealing with - you never know if the keys will get carried into deeper water by an ocean current or a fish or something.</p>
</blockquote>
<ul>
<li>we need depth increases ( what does this mean? ) ( we read on to find out more )</li>
</ul>
<blockquote>
<p>To do this, count <strong>the number of times a depth measurement increases</strong> from the previous measurement.</p>
</blockquote>
<p>It&rsquo;s important to see what things are in <strong>bold</strong>. They provide rules, hints and further clues. It&rsquo;s also important to read and re-read every sentence PROPERLY AND THOROUGHLY. Because sometimes they are confusing on purpose. From the above we gather the following rule:</p>
<ul>
<li>count the number of times a number in the list increases compared to the previous one (numbers[n+1] &gt; numbers[n])</li>
</ul>
<p>And here is a tiny tidbit that I&rsquo;m sure folks will glance over and yet it&rsquo;s very important! In parentheses!</p>
<blockquote>
<p>(There is no measurement before the first measurement.)</p>
</blockquote>
<p>Meaning, you don&rsquo;t compare the first one. This could cause a <a href="https://en.wikipedia.org/wiki/Off-by-one_error">off by one error</a> in part 2. It&rsquo;s important to pay attention.</p>
<p>Then we have the example, and we are off.</p>
<h4 id="code">Code</h4>
<p>Essentially we just loop through all numbers that we gathered, and if there is a bigger number as the current one we increase a counter.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">counter</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">n</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">n</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
    <span class="nx">counter</span><span class="o">++</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Number of increases:&#34;</span><span class="p">,</span> <span class="nx">counter</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>That&rsquo;s it. We test it on the test which should yield the right number then we run it on our input, which also should yield the right number.
This runs at a reasonable pace, so I think we are fine on optimization.</p>
<p>Onwards to&hellip;</p>
<h3 id="part-2">Part 2</h3>
<p>As usually, with part 2, things get a bit more complex here. We now need to solve a sliding window of threes. This a bit confusing to read at first,
but essentially, we just need to sum up groups and compare the sums. We have to still do that same thing as before, but now, we track a previous
sum and we need to check the next 2 numbers in the list not just the current, and current + 1.</p>
<p>The term <code>sliding-window</code> can be a bit confusing here. It just means that we will compare a slice of the numbers. The A B C notation looks also weird
to me. This one is a bit better:</p>
<p>Consider a list like this <code>1, 2, 3, 4, 5, 6</code>. We compare <code>[1+2+3], [2+3+4], [3+4+5], [4+5+6]</code>.</p>
<p>So the sliding window is basically a set of three numbers counted from your current number. Instead of <code>numbers[n] and numbers[n+1]</code> we will look at
<code>numbers[n] + numbers[n+1] + numbers[n+2]</code>.</p>
<p>Following that the code changes a tiny bit:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">counter</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="nx">prevsum</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">n</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">n</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">n</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">prevsum</span> <span class="p">{</span>
    <span class="nx">counter</span><span class="o">++</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Number of increases:&#34;</span><span class="p">,</span> <span class="nx">counter</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Why did I add the <code>math.MaxInt</code>? Because we don&rsquo;t count the first one, as pointed out by the previous sentence in parentheses!</p>
<p>This should give us the right value and both <strong>star</strong>s.</p>
<h2 id="closing-words">Closing words</h2>
<p>So this is it for day 1. This one was an easy day. It prepared you to read the problem description. Understand it, and prase out the rules of
engagement.</p>
<p>The repository for all my solutions for AOC 2021 can be found <a href="https://github.com/Skarlso/aoc2021">here</a>.</p>
<p>Thanks for reading,</p>
<p>Gergely.</p>
]]></description>
    </item>
    
  </channel>
</rss>