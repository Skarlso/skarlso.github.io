<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>functional-options on Ramblings of a cloud engineer</title>
    <link>https://skarlso.github.io/categories/functional-options/</link>
    <description>Recent content in functional-options on Ramblings of a cloud engineer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 01 Jul 2024 01:01:00 +0100</lastBuildDate><atom:link href="https://skarlso.github.io/categories/functional-options/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Discoverable functional options pattern</title>
      <link>https://skarlso.github.io/2024/07/01/discoverable-functional-options/</link>
      <pubDate>Mon, 01 Jul 2024 01:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2024/07/01/discoverable-functional-options/</guid>
      <description>Hello.
Today&amp;rsquo;s will be a quick post. Everyone knows and loves/hates functional options1 in Go.
The biggest gripe people get with it is, that the options aren&amp;rsquo;t discoverable and that there is no IDE support for nicely auto-completing options.
My thought about this was that, what if we would just hang it on a struct? Let&amp;rsquo;s see how that looks.
Consider this normal server builder with options:
type Server struct { Name string Address string Port int } func WithName(name string) ServerOptFn { return func(s *Server) { s.</description>
    </item>
    
  </channel>
</rss>
