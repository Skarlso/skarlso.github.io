<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>books on Ramblings of a cloud engineer</title>
    <link>https://skarlso.github.io/categories/books/</link>
    <description>Recent content in books on Ramblings of a cloud engineer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 21 Dec 2021 01:01:00 +0100</lastBuildDate><atom:link href="https://skarlso.github.io/categories/books/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Providers Pattern</title>
      <link>https://skarlso.github.io/2021/12/21/providers-pattern/</link>
      <pubDate>Tue, 21 Dec 2021 01:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2021/12/21/providers-pattern/</guid>
      <description><![CDATA[<p>Hello Dear readers.</p>
<p>Today, I would like to write about a project design pattern I&rsquo;ve been using successfully over the past years for
various projects. It has many variations and it has some design patterns that are commonly found in the wild, so there
is nothing really special about it.</p>
<p>Let&rsquo;s begin.</p>
<h1 id="providers-pattern">Providers Pattern</h1>
<p>What is this pattern anyways? It&rsquo;s a pattern I learned while working at <a href="https://www.arangodb.com/">ArangoDB</a>. It&rsquo;s
quite nice and defines package abstractions wonderfully. It somewhat resembles the Repository pattern from DDD and also
uses Chain of Responsibility to setup multiple providers for a given functionality. Like a fallback, in case a Provider
does not understand the current thing it got. In that case, it will delegate to <code>Next</code>.</p>
<p>I&rsquo;m going to demonstrate all of the pattern&rsquo;s capabilities through a sample project which is hopefully a sensible thing
and not just dummy functionality.</p>
<h2 id="tldr">TL;DR</h2>
<p>A Provider is like the <a href="https://martinfowler.com/eaaCatalog/repository.html">Repository pattern</a> from DDD combined with
<a href="https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern">Chain Of Responsibility</a>. Basically, set up a Provider
using an <code>interface</code> as a definition. Give that as dependency to another provider and call it&rsquo;s function. If the
Provider doesn&rsquo;t understand the type its supposed to work on, it will call <code>Next</code> in the chain delegating the function
to the following Provider. For a detailed use of this pattern, check out
<a href="https://github.com/Skarlso/providers-example">Providers Example</a> project on GitHub.</p>
<h2 id="the-project">The Project</h2>
<p><a href="https://github.com/Skarlso/providers-example">Providers Example</a> is the project I&rsquo;ll be using to demonstrate this
pattern. It&rsquo;s pretty simple; yet, I hope, it presents a useful function to be show off this pattern&rsquo;s capabilities.</p>
<p>In essence, this is a plugin executor. We have a CLI which can register plugins to execute. These plugins can either be
bare metal (as in a simple executable living somewhere), or a docker container, in which case it will use Docker to
execute the plugin. It will forward all possible parameters and display any outputs.</p>
<p>Simple, yet there are a couple things that we can extract into Providers such as:</p>
<ol>
<li><del>Dealing with the archive ( so we can test the Tar function )</del> (sorry, I scrapped this, to keep things simple)</li>
<li>Selecting the executing environment ( bare metal, container ) which we can chain</li>
<li>Output formatting ( possibly, thing like, JSON, Table, etc. )</li>
<li>Saving things into a Database ( we will save what kind of plugins exist using sqlite )
4.1. We&rsquo;ll just save the name and the type for simplicity</li>
</ol>
<h2 id="basics">Basics</h2>
<p>Let&rsquo;s take a look at the folder structure here.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">➜  providers-example git:(main) tree
.
├── LICENSE
├── Makefile
├── README.md
├── bin
├── cmd
│   ├── add.go
│   ├── list.go
│   ├── remove.go
│   ├── root.go
│   └── run.go
├── example
│   └── echo_plugin
│       └── Dockerfile
├── go.mod
├── go.sum
├── main.go
├── pkg
│   ├── commands
│   │   └── add.go
│   ├── models
│   │   └── plugin.go
│   └── providers
│       ├── archiver.go
│       ├── bare
│       │   └── bare_runner.go
│       ├── container
│       │   ├── container_runner.go
│       │   └── container_runner_test.go
│       ├── fakes
│       │   └── fake_storer_client.go
│       ├── runner.go
│       ├── storage.go
│       ├── storer
│       │   └── storer.go
│       └── tar
│           ├── tar.go
│           ├── tar_test.go
│           └── testdata
│               └── test.tar.gz
└── tests
    └── integration
        ├── init_test.go
        └── plugin_store_test.go

18 directories, 29 files
</code></pre></td></tr></table>
</div>
</div><p>What are we looking at? We have some standard packages, like <code>pkg</code>, <code>cmd</code> and <code>tests</code>. What&rsquo;s &ldquo;new&rdquo; is <code>pkg/providers</code>.
I ended up not using archiver, but I left it in for prosperity. There are 3 interfaces under <code>providers</code>. Each support
a simple functionality. Let&rsquo;s go over them.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Archiver can extract files from an archive.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Archiver</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Untar</span><span class="p">(</span><span class="nx">content</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>My initial plan was to implement the bare metal as an ability to download an archive and then untar that. But I scrapped
that idea for a simpler one. This provider would have been an <code>untarer</code>.</p>
<p>Next up is storage.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ListOpts defines options for listing plugins.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ListOpts</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">TypeFilter</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// Storer can store information about the plugins that were created.
</span><span class="c1">//go:generate go run github.com/maxbrunsfeld/counterfeiter/v6 -generate
</span><span class="c1">//counterfeiter:generate -o fakes/fake_storer_client.go . Storer
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Storer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Init</span><span class="p">()</span> <span class="kt">error</span>
	<span class="nf">Create</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">plugin</span> <span class="o">*</span><span class="nx">models</span><span class="p">.</span><span class="nx">Plugin</span><span class="p">)</span> <span class="kt">error</span>
	<span class="nf">Get</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">models</span><span class="p">.</span><span class="nx">Plugin</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nf">Delete</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
	<span class="nf">List</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">opts</span> <span class="nx">ListOpts</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">models</span><span class="p">.</span><span class="nx">Plugin</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>A simple CRUD interface, with an Init action. Whatever that init is. Currently, I&rsquo;m using sqlite3, so the live store init
is simply creating the database file and bootstrapping it with the <code>plugins</code> table. I&rsquo;m using counterfeiter to generate
a mock which I&rsquo;ll be using in tests to mock this provider where I don&rsquo;t care about it.</p>
<p>And the runner&hellip;</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Runner runs a plugin.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Runner</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Run</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This is the single method a runner needs to be able to provide / do. A runner simply takes a name and some arguments
and based on the plugin&rsquo;s type, runs it.</p>
<p>These interfaces are then implemented by real providers. For example, the storage has its implementation under <code>storer</code>.
Which has code for sqlite. The runner has two implementations. One for container and one for bare metal. And now, let&rsquo;s
see how the chain works.</p>
<h2 id="dependency-injection-and-usage">Dependency Injection and Usage</h2>
<p>Take a closer look at the container implementation for example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Config defines parameters for the Runner.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Config</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">DefaultMaximumCommandRuntime</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// Dependencies defines the provider dependencies this provider has.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Dependencies</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Next</span>   <span class="nx">providers</span><span class="p">.</span><span class="nx">Runner</span>
	<span class="nx">Storer</span> <span class="nx">providers</span><span class="p">.</span><span class="nx">Storer</span>
    <span class="nx">Logger</span> <span class="nx">zerolog</span><span class="p">.</span><span class="nx">Logger</span>
<span class="p">}</span>

<span class="c1">// Runner implements the Run interface for container based runtimes.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Runner</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Config</span>
	<span class="nx">Dependencies</span>

	<span class="nx">cli</span>    <span class="nx">client</span><span class="p">.</span><span class="nx">APIClient</span>
<span class="p">}</span>

<span class="c1">// NewRunner creates a new container based runtime.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewRunner</span><span class="p">(</span><span class="nx">cfg</span> <span class="nx">Config</span><span class="p">,</span> <span class="nx">deps</span> <span class="nx">Dependencies</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Runner</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">cli</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">NewClientWithOpts</span><span class="p">(</span><span class="nx">client</span><span class="p">.</span><span class="nx">FromEnv</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">deps</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Debug</span><span class="p">().</span><span class="nf">Err</span><span class="p">(</span><span class="nx">err</span><span class="p">).</span><span class="nf">Msg</span><span class="p">(</span><span class="s">&#34;Failed to create docker client.&#34;</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Runner</span><span class="p">{</span>
		<span class="nx">Config</span><span class="p">:</span>       <span class="nx">cfg</span><span class="p">,</span>
		<span class="nx">Dependencies</span><span class="p">:</span> <span class="nx">deps</span><span class="p">,</span>
		<span class="nx">cli</span><span class="p">:</span>          <span class="nx">cli</span><span class="p">,</span>
	<span class="p">},</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This is the main structure of a provider. It gets Configuration options via the <code>Config</code> struct. Things like,
<code>DefaultMaximumCommandRuntime</code> which is a configuration value for maximum wait time. And it gets dependencies, other
providers and third party things, like logger, through the <code>Dependencies</code> struct. We also wire things up that we are
going to use later on, like a client for Docker. Later on, in the tests, I can inject a mock for it.</p>
<p>Notice the field in the <code>Dependencies</code> struct called <code>Next</code>. This is the chain&rsquo;s first stop. In <code>root.go</code> we wired up
next to be the bare metal type plugin like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">	<span class="nx">barePlugin</span> <span class="o">:=</span> <span class="nx">bare</span><span class="p">.</span><span class="nf">NewBareRunner</span><span class="p">(</span><span class="nx">bare</span><span class="p">.</span><span class="nx">Config</span><span class="p">{},</span> <span class="nx">bare</span><span class="p">.</span><span class="nx">Dependencies</span><span class="p">{</span>
		<span class="nx">Logger</span><span class="p">:</span> <span class="nx">log</span><span class="p">,</span>
		<span class="nx">Storer</span><span class="p">:</span> <span class="nx">store</span><span class="p">,</span>
	<span class="p">})</span>
	<span class="nx">containerPlugin</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">container</span><span class="p">.</span><span class="nf">NewRunner</span><span class="p">(</span><span class="nx">container</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span>
		<span class="nx">DefaultMaximumCommandRuntime</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
	<span class="p">},</span> <span class="nx">container</span><span class="p">.</span><span class="nx">Dependencies</span><span class="p">{</span>
		<span class="nx">Storer</span><span class="p">:</span> <span class="nx">store</span><span class="p">,</span>
		<span class="nx">Next</span><span class="p">:</span>   <span class="nx">barePlugin</span><span class="p">,</span>
		<span class="nx">Logger</span><span class="p">:</span> <span class="nx">log</span><span class="p">,</span>
	<span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>And then, when calling <code>Run</code> we check the type of the plugin we got, and if we know it, we execute it, if not, we call
the <code>Next</code> thing in the chain. Simple.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Run implements the container based runtime details, using Docker as an engine.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cr</span> <span class="o">*</span><span class="nx">Runner</span><span class="p">)</span> <span class="nf">Run</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">// Find the plugin, get the location, find the type, if it&#39;s not container, call next.
</span><span class="c1"></span>	<span class="nx">cmd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cr</span><span class="p">.</span><span class="nx">Storer</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;plugin not found: %w&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">cmd</span><span class="p">.</span><span class="nx">Type</span> <span class="o">!=</span> <span class="nx">models</span><span class="p">.</span><span class="nx">Container</span> <span class="p">{</span>
		<span class="nx">cr</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Info</span><span class="p">().</span><span class="nf">Msg</span><span class="p">(</span><span class="s">&#34;Unknown plugin type, calling next in line.&#34;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">cr</span><span class="p">.</span><span class="nx">Next</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;no next provider configured&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">cr</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cr</span><span class="p">.</span><span class="nf">runCommand</span><span class="p">(</span><span class="nx">cmd</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">cmd</span><span class="p">.</span><span class="nx">Container</span><span class="p">.</span><span class="nx">Image</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;failed to run command: %w&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>And that&rsquo;s it! But wait a second. How is this different from just calling the thing? Well, this makes it so that in the
actual code, we only have to call the top level element in the chain and call <code>Run</code> on it. A default if you will.
By default, our plugins are of <code>container</code> type. This way, you can avoid a type switch for example. Or avoid having
implementation choosing logic in the code when deciding what runner to use.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">containerPlugin</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">runArgs</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="nx">runArgs</span><span class="p">.</span><span class="nx">args</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Error</span><span class="p">().</span><span class="nf">Err</span><span class="p">(</span><span class="nx">err</span><span class="p">).</span><span class="nf">Msg</span><span class="p">(</span><span class="s">&#34;Failed to run plugin&#34;</span><span class="p">)</span>
		<span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>I&rsquo;m just calling <code>containerPlugin</code>&rsquo;s Run and the rest will just work. With generics coming in 1.18 this will be even
more easier to use.</p>
<h2 id="testability">Testability</h2>
<p>The great thing about these providers are that they enclose ( you might say, encapsulate ) a single functionality. They
provide some kind of behavior to another behavior. Because that behavior is defined by an interface, and the dependency
requires an interface, it&rsquo;s trivial to unit test the actual provider. For example, the storage. You see above, that the
storage is defined as <code>Storer providers.Storer</code>. And we already have a fake. So in the tests we can set it up such as:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">    <span class="nx">fakeStorer</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">fakes</span><span class="p">.</span><span class="nx">FakeStorer</span><span class="p">{}</span>
    <span class="nx">fakeStorer</span><span class="p">.</span><span class="nf">GetReturns</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">models</span><span class="p">.</span><span class="nx">Plugin</span><span class="p">{</span>
        <span class="nx">ID</span><span class="p">:</span>   <span class="mi">1</span><span class="p">,</span>
        <span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;test&#34;</span><span class="p">,</span>
        <span class="nx">Type</span><span class="p">:</span> <span class="nx">models</span><span class="p">.</span><span class="nx">Container</span><span class="p">,</span>
        <span class="nx">Container</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">models</span><span class="p">.</span><span class="nx">ContainerPlugin</span><span class="p">{</span>
            <span class="nx">Image</span><span class="p">:</span> <span class="s">&#34;test-image&#34;</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">},</span> <span class="kc">nil</span><span class="p">)</span>
<span class="o">...</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">Runner</span><span class="p">{</span>
		<span class="nx">Dependencies</span><span class="p">:</span> <span class="nx">Dependencies</span><span class="p">{</span>
			<span class="nx">Storer</span><span class="p">:</span> <span class="nx">fakeStorer</span><span class="p">,</span>
			<span class="nx">Logger</span><span class="p">:</span> <span class="nx">logger</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="nx">Config</span><span class="p">:</span> <span class="nx">Config</span><span class="p">{</span>
			<span class="nx">DefaultMaximumCommandRuntime</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="nx">cli</span><span class="p">:</span> <span class="nx">apiClient</span><span class="p">,</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>After that, we can use it to return errors and various bits and pieces to test our actual plugin runner and not care
about storage.</p>
<h2 id="pros-and-cons">Pros and Cons</h2>
<p>The pros are obvious. Separation, testability, chaining, fallback logic, encapsulated behavior, etc.</p>
<p>But what about the cons? The downside could be the following things:</p>
<ul>
<li>naming gets hard and packages can get prolific</li>
<li>interfaces will be binding, changing them might result in changing a bunch of implementations</li>
<li>some implementations might not use some parameters from the interface if they don&rsquo;t provide that functionality ( this
might be mitigated by a very restrictive interface design )</li>
<li>it&rsquo;s a bit verbose ( this can be mitigated by not calling it dependencies or passing in a single struct instead of two)</li>
<li>wiring up all the dependencies can lead to a long set up function if there are several providers ( this can be
mitigated by having defaults and smaller setup functions )</li>
</ul>
<p>Still, I think the benefits easily out weight these problems. And many other package designs have similar issues.</p>
<h2 id="other-providers">Other providers</h2>
<p>This is just an example. Another couple of examples include:</p>
<ul>
<li>fallback authentication; start with Auth0, then SSH, username/password, finally localhost and fail</li>
<li>output parsing; what does the struct provide, use that, otherwise, fallback to table</li>
<li>github, gitlab, bitbucket handlers chained up and chosen based on url types</li>
</ul>
<h2 id="conclusions">Conclusions</h2>
<p>This is it. That&rsquo;s the provider pattern. It&rsquo;s a useful little tool in the box to have. With generics, the choosing type
will change, but the pattern can adapt to that too. It&rsquo;s a nice little thing to have. Of course it&rsquo;s not a solution to
all the problems ever. But I&rsquo;ve been using it for a while now, to good effect.</p>
<p>Thanks for reading,</p>
<p>Gergely.</p>
]]></description>
    </item>
    
    <item>
      <title>Summary of Programmer&#39;s Brain</title>
      <link>https://skarlso.github.io/2021/11/27/summary-of-programmers-brain/</link>
      <pubDate>Sat, 27 Nov 2021 01:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2021/11/27/summary-of-programmers-brain/</guid>
      <description><![CDATA[<h1 id="prologue">Prologue</h1>
<p>Hello all.</p>
<p>This is a summary of the book <a href="https://www.manning.com/books/the-programmers-brain">Programmer&rsquo;s Brain</a>. Let me begin by saying the book is fantastic and you should definitely read it. The research put into it is phenomenal, and the many linked notes, data and reference make for an amazing and compelling read!</p>
<p>Not to mention that it is fantastic that someone put actual effort and data into finding out how programmers operate, think and behave. And most of all, how our code behaves and reading, and dealing with code is not just about understanding algorithms and finding the best possible and most optimized code ever.</p>
<p>What does this summary contain? Information that I found useful about the book. It doesn&rsquo;t contain everything, just the distilled amalgamation of information that I hand picked and will try to convey using my own words.</p>
<p>Let&rsquo;s dive in.</p>
<h2 id="part-one---reading-code-better">Part One - Reading code better</h2>
<h3 id="understanding">Understanding</h3>
<p>We all know that we read code more than we write it. It&rsquo;s a basic premise, right? Yet, still we don&rsquo;t write code for reading at all! We have to make a conscious effort of it to write it in a readable, compact way. We optimize for speed, optimize for structure, but we rarely, if at all, optimize for readability. For understandability. To please the reader, instead of the writer. To look ahead an think, by whom and how will this code be read again?</p>
<p>This part offers a couple of solutions to alleviate this pain.</p>
<h4 id="confusion">Confusion</h4>
<p>It identifies three things. Lack of Knowledge, Lack of Information and Lack of Processing Power.</p>
<ul>
<li>lack of information - basically, you don&rsquo;t know enough about the project / code you are looking at</li>
<li>lack of knowledge - you lack knowledge about the thing you are doing, i.e.: some obscure language syntax you are unfamiliar with</li>
<li>lack of processing power - the code chunk you are looking at is too large, or you should break it down</li>
</ul>
<p>The book makes a point on how cognitive load works and why you should take care of it. I&rsquo;m not going to detail that part ( read the book! ). But it&rsquo;s basically all about how complex something looks until you have enough background in your long term memory to be able to decipher it instantly and not spending too much time on it.</p>
<p><em>Lack of processing power</em> is alleviated by taking notes, jotting down information and functions and variables about the code you are writing. By using a second brain (i.e. paper) you lighten the load on your current working memory. Further, it might be helpful to refactor into something that you do understand and are already familiar with. For example, exploding a Python list comprehension into a for loops until you understand the whole thing. Then put it back and read it again.</p>
<p><em>Lack of knowledge</em> is easy to mend. You read up on said topic / become better in it.</p>
<p><em>Lack of information</em> again, just read up on the stuff you are missing.</p>
<h4 id="reading">Reading</h4>
<p>The book then continues with helping you speed read code better. There are fascinating researches quoted about various things they tried with experts and junior programmers and chess masters vs beginners.</p>
<p>As much as Go people dislike talking about design patterns in Go, they exist for a reason. The reason is that there are common problems which have common, tried solutions. It&rsquo;s fare that these patterns apply differently in Go because of the structure available to us, but they still exist. And this is on which speed reading hinges. Patterns. The more patterns you recognize the faster you&rsquo;ll be able to read code.</p>
<p><code>for</code> loops, <code>if err != nil</code> checks. It&rsquo;s ingrained now into your memory and you recognize and can read it at a glance.</p>
<p>This means, in order to help the reading of your code, you should focus on things called Beacons. Beacons are small, understandable (at a glance) parts of your code. Comments, patterns like <code>if err != nil </code>, chains, proper function names; all of these are beacons which help in understanding and reading your code better.</p>
<p>For faster code reading speed, you have to know patterns and idioms at a glance. Practice until you know them by heart. For example, you don&rsquo;t have to look twice to identify a bridge above water, right? You know it&rsquo;s a bridge because it looks like a bridge. It could be above a street too it still would be a bridge.</p>
<p>To be able to learn faster, the book, and indeed many other research papers now-a-days, suggest spaced repetition, recall, and / or flashcards.</p>
<p>One of the best suggestions I&rsquo;ve gotten out of this book about reading and learning code, is if you have to Google something for the second time because you don&rsquo;t remember how that works, you are wasting time and are adding to your cognitive load. At that point, you should make an effort to remember it with the above suggested tips. Why, even for the first time. If you Google something or look it up on StackOverflow, at that moment, you should create a flash card for it and condense that information WITH YOUR OWN WORDS! Then use spaced repetition / recall to remember it.</p>
<p>In the future you will benefit from having that thing in the back of your head.</p>
<h2 id="part-two---thinking-about-code">Part Two - Thinking about code</h2>
<h3 id="reading-strategies">Reading strategies</h3>
<p>Then we get to reading and understanding code. Research backed data proves that mathematical knowledge will not make you better at understanding code. Linguistic proves backs programming skills more than mathematical understanding. Logical proves also helps a lot more.</p>
<p>Effective reading in general, can be broken down into the following sections:</p>
<ul>
<li>Activating &ndash; try remembering things which relate or are similar to the thing you are reading</li>
<li>Monitoring &ndash; check your understanding as you go</li>
<li>Determining importance &ndash; discard things that are of no interest to you</li>
<li>Inferring &ndash; understand things that the text only implies</li>
<li>Visualizing &ndash; draw things &ndash; only helps if you are visually inclined. I think you should do whatever helps you to understand</li>
<li>Questioning &ndash; without recall there is no remembering</li>
<li>Summarizing &ndash; write a summary IN YOUR OWN WORDS!!! ( I can&rsquo;t stress this enough )</li>
</ul>
<p>When you are reading code, you first will understand the code at hand, and then, a bigger picture understanding comes later. I&rsquo;m not sure about which comes first. I think everyone is different. Someone might understand the bigger picture a lot easier than actual code. In any case, mapping either to the other is a difficult process. Inferring code from patterns and inferring the bigger picture from code. It&rsquo;s a good exercise.</p>
<p>The book also separates variables based on behavior. This might help you understand the code better later, when you read it. It uses the following 11 categories:</p>
<ul>
<li>Follower</li>
<li>Stepper</li>
<li>Walker</li>
<li>Temporary</li>
<li>Counter/Gatherer</li>
<li>Container</li>
<li>Fixed value</li>
<li>Flag</li>
<li>Organizer</li>
<li>Most-recent Holder</li>
<li>Most-wanted Holder</li>
</ul>
<p>These are self-explanatory, but marking the variables might give you a hint on their purpose and maybe refactor them or name them appropriately.</p>
<p>Now, we come to the interesting sub-section of problem solving.</p>
<h3 id="problem-solving">Problem solving</h3>
<h4 id="mental-models">Mental Models</h4>
<p>The way you create a mental model about a problem will decide how you&rsquo;ll go about solving them. Which means, if your solution &ldquo;feels dirty&rdquo;, or is buggy and doesn&rsquo;t feel right, you just might need to change your mental model about the problem. Or the data representing it. Your mental model will decide how you tackle this problem. So you better make sure your mental model is correct. A couple of mental models can be, diagrams, a graph, a state machine&hellip; everything that can represent the logic of the code with a model.</p>
<p>Thinking with models about the logic of the code is an important skill. Abstracting the problem can give you a huge benefit in solving it.</p>
<p>There is an awesome quote from Rob Pike:</p>
<blockquote>
<p>A year or two after I’d joined the Labs, I was pair programming with Ken Thompson on an on-the-fly compiler for a little interactive graphics language designed by Gerard Holzmann. I was the faster typist, so I was at the keyboard and Ken was standing behind me as we programmed. We were working fast, and things broke, often visibly — it was a graphics language, after all. When something went wrong, I’d reflexively start to dig in to the problem, examining stack traces, sticking in print statements, invoking a debugger, and so on. But Ken would just stand and think, ignoring me and the code we’d just written. After a while I noticed a pattern: <strong>Ken would often understand the problem before I would, and would suddenly announce, “I know what’s wrong.” He was usually correct. I realized that Ken was building a mental model of the code and when something broke it was an error in the model. By thinking about <em>how</em> that problem could happen, he’d intuit where the model was wrong or where our code must not be satisfying the model.</strong></p>
<p><strong>Ken taught me that thinking before debugging is extremely important. If you dive into the bug, you tend to fix the local issue in the code, but if you think about the bug first, how the bug came to be, you often find and correct a higher-level problem in the code that will improve the design and prevent further bugs.</strong></p>
<p>I recognize this is largely a matter of style. Some people insist on line-by-line tool-driven debugging for everything. But I now believe that thinking — without looking at the code — is the best debugging tool of all, because it leads to better software.</p>
</blockquote>
<p>I love this. It shows that having a clear mental model of the code will help you in understanding it better. Work through the code, construct a model by following a call path. Understand and draw the entities which interact with each other through that path and construct a structure out of it. Draw that structure or put it into a state machine, write down how pieces and variables interact and you&rsquo;ll have a clear understanding of what&rsquo;s going on.</p>
<p>This is called following a focus point. A focus point is an entry to a system. Sometimes there are multiple focus points. They all represent a different path through the system but might use the same entities.</p>
<p>The more general mental models you store in your Long Term Memory, the easier it will be to identify and solve problems. Use flashcards to remember as many mental models as you can. Things like, tree traversal, sorting, data structures, thinking about architecture, layered architecture etc&hellip; If you can recall them from heart you&rsquo;ll be able to reason and understand code a lot better.</p>
<h4 id="notional-machines">Notional Machines</h4>
<p>The best way to describe a notional machine is an abstraction of the executing code. It&rsquo;s a kind of mental model, but it&rsquo;s always correct. A normal mental model can be incorrect. A notional machine always depicts what the machine is doing. I didn&rsquo;t really find them helpful, but they might be helpful to others. Notional machines help us understand how the machine works, how code runs. There are multiple machines which can work together. To learn more about them, either read the book, or read <a href="https://www.researchgate.net/publication/259998496_Notional_Machines_and_Introductory_Programming_Education">this</a> research paper on them.</p>
<h4 id="misconceptions">Misconceptions</h4>
<p>This one is interesting and certainly worth an explanation. Basically, you have to constantly check you biases about code, concepts and your mental models. Otherwise, you&rsquo;ll fall into the routine of using the wrong model all the time. This isn&rsquo;t always easy, because it might not be apparent at first. But never assume that what you know is always correct. Of course there are axioms like <code>1==1</code> which will always be true, but that doesn&rsquo;t mean that a concept you might know is an axiom.</p>
<p>Always read the documentation and the code of the current project you are working on with the care of checking your mental models. They might be outdated or incorrect.</p>
<h2 id="part-three---writing-better-code">Part Three - Writing better code</h2>
<h3 id="how-to-get-better-at-naming-things">How to get better at naming things</h3>
<p>This is a whole chapter in it&rsquo;s own about naming things. That is an important chapter to be sure because naming is the hardest. But I found that the advice there is basically, name things in the context they are in and regarding the behavior they represent. Naming things has always been important. A good name will sometimes solve the whole problem in its own!</p>
<p>There was one time where I was thinking about how to implement a particular feature. I&rsquo;ve spent a day on trying to come up with a nice solution. When I stepped back and thought about the problem without looking at the code. Building up a mental model, thinking about what I need and if there is a <code>thing</code> that can do that for me. When suddenly, the best name popped into my head based on the need, the circumstance and the behavior of the thing. Suddenly, the whole implementation laid itself out before me because I knew what I needed. I had a name for it.</p>
<p>Equally, a bad name will deprive the understanding you need and, in fact, will make it much harder to implement anything else in that context.</p>
<p>Amongst other things, the book suggests the three-step model. <a href="https://www.cs.huji.ac.il/~feit/papers/Names20TSE.pdf">How Developer&rsquo;s Choose Names</a>.</p>
<h3 id="avoid-bad-code-and-cognitive-load">Avoid bad code and cognitive load</h3>
<p>First, let&rsquo;s look at the cognitive load part. What does cognitive load mean? It means that you have to spend a lot of brain power / energy on understanding the actual code. Why is that? Is the code way too complex for what it&rsquo;s doing? Is it written badly? Does it smell? Do you not understand the domain? Do you not understand the syntax? There are many things you can do to alleviate some of the pain. The main three are:</p>
<h4 id="make-sure-you-completely-understand-the-domain">Make sure you completely understand the domain</h4>
<p>This one is easy to dismiss but is actually hugely important. You have to be absolutely crystal clear that you understand the domain that the code is dealing with. Otherwise, the code will either not make sense, or will be difficult to interpret in it&rsquo;s fullest. By understanding the domain, you&rsquo;ll be able to figure out the code, even more so, you&rsquo;ll be able to reason about the code. And maybe you&rsquo;ll actually find that the code is in fact, wrong. It doesn&rsquo;t actually implement the domain well.</p>
<h4 id="simplify-the-code">Simplify the code</h4>
<p>Sometimes the code is just written in an insane complex way for no apparent reason. Or there is a reason, you just don&rsquo;t see it yet. And that&rsquo;s okay! Start by refactoring the code in a way you understand or making it simpler. I, actually have a story about this.</p>
<p>There was a <a href="https://github.com/weaveworks/eksctl/issues/1275">ticket</a> in <a href="https://github.com/weaveworks/eksctl">eksctl</a> I picked up. Refactor the logging to expand nested task logging into a nice structure. Basically come from this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[ℹ]  3 sequential tasks: { delete nodegroup &#34;ng-5b8f2f94&#34;, 2 sequential sub-tasks: { 2 sequential sub-tasks: { delete IAM role for serviceaccount &#34;default/s3-reader&#34;, delete serviceaccount &#34;default/s3-reader&#34; }, delete IAM OIDC provider }, delete cluster control plane &#34;irp-test-5-manual&#34; [async] }
</code></pre></td></tr></table>
</div>
</div><p>to something like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[ℹ]  3 sequential tasks: {
  delete nodegroup &#34;ng-5b8f2f94&#34;, 2 sequential sub-tasks: {
    2 sequential sub-tasks: {
      delete IAM role for serviceaccount &#34;default/s3-reader&#34;, delete serviceaccount &#34;default/s3-reader&#34;
    }
    delete IAM OIDC provider
  }
  delete cluster control plane &#34;irp-test-5-manual&#34; [async]
}
</code></pre></td></tr></table>
</div>
</div><p>Looks easy, right? This was the result: <a href="https://github.com/weaveworks/eksctl/pull/4290">pr</a>. It took me two days! Turns out what parsed the log messages was so convoluted and recursive that it was difficult to unravel. Ultimately, what I did was, I begun re-writing bits of it and simplifying the whole thing, running the code over and over to see what it produced. It was a loose, semi-recursive structure, where you had no idea how deep you are at any given moment; thus you couldn&rsquo;t just indent things based on a counter or a tracker. It was always 1 or 0 deep.</p>
<p>Even so, I think this will sort of break apart if we ever go 4-5 nested tasks deep&hellip; but that&rsquo;s a story for another day.</p>
<p>The lesson here is, that simplifying and re-writing the code made me understand what&rsquo;s going on there a lot better and I was finally able to rewrite it.</p>
<p>Next, the book talks about how code smells increase the cognitive load many fold. Eliminating code smells will increase the understandability of the code. Code smells have been introduced by Kent Beck and become more known when Martin Fowler wrote about them. A brief description can be found <a href="https://martinfowler.com/bliki/CodeSmell.html">here</a>. The <code>Refactoring</code> book identifies these code smells:</p>
<ul>
<li>Long Methods</li>
<li>Long Parameter List</li>
<li>Switch statements</li>
<li>Alternative Classes with different Interfaces</li>
<li>Primitive obsession - Avoid the overuse of primitive types in a class</li>
<li>Incomplete Library class - Methods should not be added to random classes instead of to a library class.</li>
<li>Large Class</li>
<li>Lazy Class - doing too little</li>
<li>Data Class - just dealing with data</li>
<li>Temp fields</li>
<li>Data Clumps</li>
<li>Divergent Change | Shotgun surgery - change which results in unwanted change in different parts of the code</li>
<li>Feature Envy</li>
<li>Inappropriate intimacy - classes should not be connected to other classes extensively</li>
<li>Duplicate code or code clones</li>
<li>Superflouse comments</li>
<li>Message Chains - aka. train wrecks</li>
<li>Middle man - its only purpose is to delegate to other method calls</li>
<li>Refused bequest (inherit unused behavior)</li>
<li>Speculative generality - adding code &ldquo;just in case&rdquo;</li>
</ul>
<p>Some of these don&rsquo;t really apply in Go, especially the pieces about classes and inheritance. But some of them do apply and should be looked out for. They can really complicate the code unnecessarily. Further anti-patterns are Structural and Linguistic.</p>
<p><strong>Structural</strong>: Code is okay, but structured in a way that is difficult to understand and process -&gt; increases cognitive load.
<strong>Linguistic</strong>: Bad / misleading names lead to confusion and bugs.</p>
<h3 id="solving-complex-problems">Solving complex problems</h3>
<p>First, identify what the problem is. Re-write / re-formulate it in your own words. This will make sure that you understand the problem at hand properly. Then draw the problem out as much as possible and identify the individual constraints which exist. List them and examine them. If the problem is too complex, start removing or adding constraints until it is easier to think about the solution.</p>
<p>The book talks about State Space. A state space is all steps we could consider when solving the problem.</p>
<p>Now, the book says something I would like to quote word for word, because I believe this is profound and should be taken to heart.</p>
<blockquote>
<p>In 1945, Pólya wrote a short and famous book called How to Solve It. His book proposes a “system of thinking” to solve any problem involving three steps:
&gt; 1. Understanding the problem
&gt; 2. Devising a plan
&gt; 3. Carrying out the plan</p>
<p>However, despite the popularity of generic approaches, research has consistently shown that problem solving is neither a generic skill nor a cognitive process.</p>
</blockquote>
<p>Let me repeat this. <strong>However, despite the popularity of generic approaches, research has consistently shown that problem solving is neither a generic skill nor a cognitive process.</strong></p>
<p>There is no such thing as learning a base generic method of problem solving and then solve all possible problems. You have to exercise specific problems in order to be better at specific problems. Guess what this means on a broader aspect. Learning to play Chess will not make you smarter. It will make you good at chess. Playing games on Lumosity will not make you smarter. It will make you better at playing games on Lumosity.</p>
<p>What will definitely help you though is the following. &ldquo;Automate&rdquo; mundane algorithms. What this means in practice is that you exercise problems which include things like, tree traversal, graph building, stack based operations, breath first search, depth first search, etc. Practice them until you know these things by heart. The same way you learn to do math. You solve quadratic functions until you know by hearth what the solution is.</p>
<p>But you don&rsquo;t stop there!!! You also need to be able to evolve these. Apply them to similar problems and understand how a problem is similar, or break it down until you can make it similar. I&rsquo;d like to think about like when Miyagi thought Daniel son <strong>wax on wax off</strong> technique and then suddenly, Daniel knew how to do karate. That&rsquo;s a bit of stretch but you get the gist of the idea.</p>
<p>The main is that common things like, what is an optimistic or a pessimistic lock, have to be in your long term memory. Continuously Googling and looking at StackOverflow will not make you better at problem solving. That does not mean you shouldn&rsquo;t!!!!!!!! BUT! You should eventually learn from it! And now, let me repeat an important sentence. <strong>IT IS OKAY TO LOOK AT SOLUTIONS FROM OTHER PEOPLE!!</strong> Like, in art. You first learn by coping things. Things from real world, other artist&rsquo;s work. You study art from other people and drawing from masters. You understand how they did it, and replicate that until you know it by heart. On then do you begin to extend and find your own style.</p>
<p>And so, it&rsquo;s perfectly fine to look at other people&rsquo;s solutions to hard problems <strong>AS LONG AS YOU LEARN FROM THEM</strong>! Look at the solution. Study it. Understand it. Then write your own! That&rsquo;s how you&rsquo;ll learn.</p>
<p>The book goes into a lot of detail about what kind of memory influences these problems. But this, the above thing, was my biggest takeaway from all of that. Basically, automating things in your brain will free up cognitive load when thinking about code and solving problems.</p>
<h2 id="part-four---collaborating-on-code">Part Four - Collaborating on Code</h2>
<h3 id="writing-code">Writing code</h3>
<p>The book first starts off by listing all the different activities when writing code and sums them up into the following sub-sections:</p>
<p><strong>Searching</strong></p>
<p>Mostly reading and learning the code. Hard on short term memory. Helps to write down where you are, what you are looking for and what did you already found to off-load cognitive load. Leave breadcrumbs, change the code here and there, leave a TODO / anchor.</p>
<p><strong>Comprehension</strong></p>
<p>58% of our time is spent doing this activity. It&rsquo;s about understanding the code and trying to find out what it does and how. Changing / simplifying the code helps. Draw models and leave notes on structure which can help you continue your task later.</p>
<p><strong>Transcription</strong></p>
<p>&ldquo;Just coding&rdquo; where you know what you are going to write where and why.</p>
<p><strong>Incrementation</strong></p>
<p>Adding new feature. Is hard on everything&hellip;</p>
<p><strong>Exploration</strong></p>
<p>The final activity. Sketching with code. Vague idea but by writing code, your idea solidifies. Jot down your design, will help order your thoughts and free up mental space for other things.</p>
<p>Then the book continue to talk about interrupts and how they are not really helpful. We already know this&hellip;</p>
<h3 id="improving-the-design-of-large-systems">Improving the design of large systems</h3>
<p>This is an interesting chapter I completely misunderstood but I&rsquo;m glad I got perspective on. It makes you think about your system&rsquo;s design in terms of cognitive load and how hard it would be for other to find their way in it. Basically design your system with humans in mind. Is it easy to follow? Do package names make sense? Does that code have to live there? Your architecture might be awesome, and intricate, but if others can&rsquo;t read it, then it they won&rsquo;t collaborate on it. And if you are working in a team this is especially important. The book calls this CDCB ( cognitive dimension of codebases ).</p>
<p>CDCB identifies the following dimensions:</p>
<p><strong>Error Proneness</strong>
This one is mostly about type safety and how easy it is in your code to make errors.</p>
<p><strong>Consistency</strong>
How consistent is your code with itself. Naming, structure, where and why things are where they are. Paradigms, idioms being used&hellip;</p>
<p><strong>Diffuseness</strong>
How much space a programming construct takes. How long certain required syntaxes are. Things like for loops, and language structures. How compact or extent the code is.</p>
<p><strong>Hidden Dependencies</strong>
How visible are the code&rsquo;s dependencies. Are there hidden things the user needs but is not apparent and not documented?</p>
<p><strong>Provisionality</strong>
Exploring ideas can help when writing code. You start writing and that will give you ideas about how to proceed further. Your vague ideas become more concrete. Some language can be used better to do this because they don&rsquo;t get in your way. Like Python, JavaScript. Go is strictly typed and will scream at you if you make a mistake. That can hinder exploration.</p>
<p><strong>Viscosity</strong>
How resistant is your code to changes.</p>
<p><strong>Progressive Evaluation</strong>
Similar to Provisionality, this dimensions defines how hard it is to execute partial code.</p>
<p><strong>Role expressiveness</strong>
How easy it is to see what does what. Like, in Ruby it&rsquo;s difficult to see if something is a function call or a variable. <code>thing.other</code>. Other might be anything. Meanwhile in other languages it&rsquo;s easy to see that <code>thing()</code> is a function.</p>
<p><strong>Closeness of Mapping</strong>
How close your program is to the domain / problem that is solved.</p>
<p><strong>Hard Mental Operations</strong>
The code requires hard mental operations, such as, deciphering obscure syntax, or understanding hard idioms like monads and difficult to follow type systems. If your project requires hard mental operations, contributors are less likely to join it.</p>
<p><strong>Secondary Notation</strong>
This one is weird. Second meaning to code, such as comments and named parameters.</p>
<p><strong>Abstraction</strong>
Can users of your system create their own abstractions which are as powerful as built in abstractions. For example functions in a programming language. In Go I would say interfaces provide this abstraction since a user of a Library can create their own Interface over some functionality of a library and use that and pass in the libraries function.</p>
<p><strong>Visibility</strong>
How easy is it to see parts of the system. Is your folder structure following your architecture layers?</p>
<p>Playing around with these and improving one or the other might improve the overall design of your project. But there are trade-offs for everything.</p>
<h3 id="how-to-onboard-new-developers">How to onboard new developers</h3>
<p>This chapter is all about the differences between senior and newcomers and ties nicely back into all of the research being done about cognitive load, short term vs long term memory, sensory overload and information overload. It&rsquo;s an interesting read for sure if you do a lot of interviews I definitely encourage reading the whole thing in the book. I&rsquo;m going to summarize what I&rsquo;ve got out of it&hellip;</p>
<p><strong>Don&rsquo;t overload newcomers.</strong>
They need to learn a LOT about your environment, group dynamic, team procedures, issue handling, break routines&hellip; and I didn&rsquo;t even begin talking about code yet&hellip;</p>
<p><strong>Once you master something you forget how difficult it was.</strong>
This is a great point we tend to forget. You have a better view of the big picture. You know parts of the code better. Beginners tend to focus on detail more and don&rsquo;t see the big picture yet. You tend to think that that stuff is &ldquo;easy&rdquo;. Since you already forgot how difficult it is/was.</p>
<p><strong>Noticing patterns.</strong>
Even if you don&rsquo;t immediately have an answer to a problem you&rsquo;ll be faster in finding it. You can chunk code better, you can read code faster and spot certain patterns more efficiently since you already encountered them a hundred times over.</p>
<p><strong>Semantic Wave</strong>
This one is a really interesting concept. It depicts the ideal learning curve of a newcomer. Coin by Karl Maton. Read about it <a href="https://www.sciencedirect.com/science/article/abs/pii/S0898589812000678">here</a>.</p>
<p>Has three steps&hellip;</p>
<p>1: <em>understanding</em> - understand the generic concept</p>
<p>2: <em>unpacking</em> - this is the low of the curve where the beginner is ready to learn the details about the thing</p>
<p>3: <em>repacking</em> - get back to the generic concept on their own - meaning understand why the generic concept is useful and results in the concrete detail. This is when the information is actually internalized and ideally, completely remembered.</p>
<p>Following this there are three anti-patterns when not regarding this curve.</p>
<p>1: <em>high flatline</em> - only using abstract terms</p>
<p>2: <em>low flatline</em> - too much detail, not enough high level view on the <strong>why</strong></p>
<p>3: <em>funny enough this one doesn&rsquo;t have a fancy name</em> - starts with the abstract, goes to the detail but doesn&rsquo;t allow time for the internalization, the <em>repacking</em>. Let&rsquo;s call this one <em>the rush</em>.</p>
<p>The book has some more awesome suggestions and activities to follow with the newcomers, but I can spoil all the fun now can I.</p>
<h2 id="conclusions">Conclusions</h2>
<p>This has been it. Thank you for reading. I hope this was as fun to read as it was to write. It was a great journey reading this book and the citations and research that went into it.</p>
<p>Thanks for reading,
Gergely.</p>
]]></description>
    </item>
    
    <item>
      <title>Reader&#39;s Digest 2021-07</title>
      <link>https://skarlso.github.io/2021/07/31/readers-digest/</link>
      <pubDate>Sat, 31 Jul 2021 01:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2021/07/31/readers-digest/</guid>
      <description><![CDATA[<h1 id="readers-digest">Reader&rsquo;s Digest</h1>
<p>I thought it would a cool idea if I kept a summary of the things I&rsquo;ve read or listened to on a monthly
basis. Here is July of 2021 so far. Enjoy.</p>
<h1 id="ultimate-go">Ultimate Go</h1>
<p><a href="https://www.amazon.com/Ultimate-Go-Notebook-William-Kennedy/dp/1737384426/ref=sr_1_3?crid=3EYE58E3G0EO3&amp;dchild=1&amp;keywords=go+ultimate+notebook&amp;qid=1630309494&amp;sprefix=go+ultimate+%2Caps%2C244&amp;sr=8-3">This</a> book is a culmination of Bill Kennedy&rsquo;s <a href="https://www.oreilly.com/library/view/ultimate-go-programming/9780135261651/">Ultimate Go course</a> and notes
which were spawned from them by <a href="https://hoanhan.co/">Hoanh An</a>. Bill Kennedy set out to put everything together and create
a notebook which can be read and followed like the personal notes of a student.</p>
<p>It contains a great many code examples which has been reviewed again and again ( by me too! ) to ensure that
there are no bugs in them, and that they adhere to a high standard.</p>
<p>The book follows An as he follows the Ultimate Go course and takes notes from them. The course talks about
the language intricacies, inner workings of the scheduler, the GC, memory and CPU profiles usage and many, many more things.
It also touches up on the now incoming type parameters, aka generics, in Go 1.18. It&rsquo;s a great touch in the book
as it will eventually be a standard and better to begin understanding it sooner rather than later.</p>
<p>The first chapter sets up the reader&rsquo;s mind frame to the unusual way the book is written ( in first person ). With a
lovely and inspiring set of quotes from a great many people big in the tech industry.</p>
<p>I encourage everyone to have a read of it!</p>
<h1 id="go-with-domain">Go with Domain</h1>
<p>This book can be obtained by subscribing to ThreeDots' newsletter <a href="https://threedots.tech/go-with-the-domain/">here</a>.</p>
<p>It&rsquo;s a lengthy book describing a journey the authors (Milosz Smolka, Robert Laszczak) took in order to improve software
and therefor, the World. It&rsquo;s a great journey, but it&rsquo;s mostly about using DDD in a pragmatic way in Go.</p>
<p>My feelings about this book are mixed. On one hand, Go doesn&rsquo;t like convoluted patterns, and DDD IS convoluted. On the other
hand, patterns are there for a reason. They solve real problems in a generic way which has been already solved before us
a hundred thousand times. And Go has patterns, just different ones than other languages. And that&rsquo;s fine. Go promotes
simple implementations and simple solutions.</p>
<p>However, there is only so far that you can get with simple. Eventually, you&rsquo;ll be in an enterprise environment working with
a 100 other people and will try to put something together using poor communications, that&rsquo;s bound to fail. DDD at least
offers the ubiquitous language which provides common language across everyone who uses the product. That&rsquo;s definitely a
benefit. And Event storming is a good idea IMHO.</p>
<p>I offer this. It&rsquo;s a good read. It&rsquo;s incomplete as of this writing, missing the last few chapters. Everyone who reads it
should decide for themselves if the patterns offered make sense. But for sure, it should not be dismissed too hastily.</p>
<p>The authors are aware of the Go communities apprehension against bloated patterns and offer pragmatic solutions in many
cases. I really like that. It&rsquo;s not a 1:1 copy try of DDD, it&rsquo;s a clever try in adapting it and molding it to Go.</p>
<h1 id="texas-reckoners---lux">Texas Reckoners - Lux</h1>
<p>This one is again from Brandon Sanderson. I listened to it via an <a href="https://www.amazon.com/Lux-A-Texas-Reckoners-Novel/dp/B0979GXN82/ref=sr_1_1?crid=2I2N0HTFOKJ1C&amp;dchild=1&amp;keywords=texas+reckoners&amp;qid=1630309057&amp;sprefix=texas+rek%2Caps%2C242&amp;sr=8-1">AudioBook</a>. It was quiet enjoyable! I
already listened to all three of the Steelheart Reckoners and it was awesome to hear some references to that.
The end ties the timeline together, Calamity disappears from the sky, and it&rsquo;s left open with a massive Cliff Hanger.
I&rsquo;m looking forward to listening to #2.</p>
<p>The story follows a group of Texas reckoners which is another cell that Prof created. A fresh recruit call Jax is taken
into the care of this group and molded into a formidable Epic assassin. His brother is killed by an Epic call Lovestruck
in the early days and his whole family died when in Steelheart the bomber Epic destroyed a city.</p>
<p>He is set out for revenge to take down Lux, a floating city governed by an Epic called Lifeforce. He has the ability to
make anyone immortal. The floating city plunders around Texas, so the Reckoners set out to destroy it!</p>
<h2 id="conclusion">Conclusion</h2>
<p>That&rsquo;s it for these months. Next month I&rsquo;m planning on finishing two Go related books hopefully and will write some reviews
about those.</p>
<p>And as always,
Thanks for reading,
Gergely.</p>
]]></description>
    </item>
    
    <item>
      <title>Reader&#39;s Digest 2021-06</title>
      <link>https://skarlso.github.io/2021/06/30/readers-digest/</link>
      <pubDate>Wed, 30 Jun 2021 01:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2021/06/30/readers-digest/</guid>
      <description><![CDATA[<h1 id="readers-digest">Reader&rsquo;s Digest</h1>
<p>I thought it would a cool idea if I kept a summary of the things I&rsquo;ve read or listened to on a monthly
basis. Here is June of 2021 so far. Enjoy.</p>
<h2 id="hell-divers-6-allegiance">Hell Divers 6: Allegiance</h2>
<p>I love the Hell Divers series. I listened to this one on audible as always and it was fantastic, as always.
King Xavier Rodriguez. That sounds as bad ass as it is. We follow King Xavier and Rhino, his trusted subordinate into
battle with a new threat called Skin Walkers and of course the machines, the defectors which are trying to kill everyone.
Also, there is now a signal from a possible group of people who are surviving on the surface for more than 200 years!
Xavier hates being king but does anything to keep the peace and humanity alive. Sadly, not all of his people agree to that
especially not after what they did to their people. The people of the metal island, the cannibals are harsh people. And
they don&rsquo;t get along nicely all the time.</p>
<h2 id="go-typed-parameters-proposal">Go Typed Parameters Proposal</h2>
<p>The proposal can be found <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md">here</a> and it&rsquo;s quite lengthy.</p>
<p>The first example speaks worlds:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Print prints the elements of a slice.
</span><span class="c1">// It should be possible to call this with any slice value.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Print</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Just an example, not the suggested syntax.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>It is actually exciting that generics is coming to Go. And it&rsquo;s even in my life time. The introduction of generics back
in the old days to Java brought a lot of confusion into the land of Java but more importantly, it brought in the eagerness
of using generics for EVERYTHING. I&rsquo;m really hoping that this proposal will not affect the land of Go. But unfortunately,
it probably will. It is up to us to take care and apply generics WHEN IT&rsquo;S REALLY NECESSARY AND ONLY THEN!</p>
<p>Even so, the proposal is really solid and has some pretty nice scenarios. And there is this issue:
<a href="https://github.com/golang/go/issues/45955">Add generic slice package to Go</a>. Which talks about what the title says.
It has some really amazing feedback already and a gazillion view and an &ldquo;approve&rdquo; from Rob Pike! <a href="https://github.com/golang/go/issues/45955#issuecomment-861173504">Comment</a>.
Which just means he didn&rsquo;t vehemently object. This is really happening. Which is insane and exciting at the same time!</p>
<h2 id="horizon-zero-dawn">Horizon Zero Dawn</h2>
<p>This isn&rsquo;t a book, but a game on PS4 which I spent most of my time instead of reading. I do not regret it, because the
story is absolutely beautiful. When I play, I play for reading. Meaning I read every lore and listen to every story I
encounter and start looking for them as well. Now, let&rsquo;s step back, what is Horizon Zero Dawn?</p>
<p>If you&rsquo;ve been living under a rock these past years, or are just not into games that much let me break it down for you.
The year is&hellip;. X. We have no idea but it&rsquo;s somewhere around the 31st century. It&rsquo;s been several decades after some kind
of apocalypse ( what kind, we find out as we progress with the story ) which left the world in ruins. Small tribes of
humanity survived and segregated into the Nora, Oseram, Banuk and Carja mostly. The ones we know about that is.
Our protagonist is a Nora girl called Aloy.</p>
<p>But there is an interesting twist&hellip; Instead of mostly animals, we have giant Robots, which are animals / perform the tasks
animals perform. Like, hunting, scavenging, eating plant life, swimming in the waters&hellip; Etc.</p>
<p>And these people, hunt these machines. Usually, these machines are docile, but with time, they got more and more aggressive
and more and more machines came around which were always aggressive and effectively started to hunt people.</p>
<p><strong>SPOILER WARNING</strong>: Now, our girl grows up as an outcast, because she actually came into the world, not from a mother
but from the belly of a mountain called Mother&rsquo;s Heart. Mother&rsquo;s Heart is actually an ancient facility sealed shut, with
a biometric security system which they call All Mother. The story is REALLY long, but eventually, we find out the following&hellip;</p>
<p>A guy called Faro creates a company called Faro Automated Solutions which creates a bunch of semi-sentient machines which
are used as &ldquo;peacekeeping&rdquo; devices. They can self replicate and they &ldquo;eat biomass&rdquo; to sustain themselves indefinitely.
And of course, as these things are, there is a glitch and they become something called a Swarm which devourers everything
in their path. Until Dr. Elisabeth Sobeck comes along and saves the day with Project Zero Dawn.</p>
<p>And here comes the twist. Sobeck knows that the planet is doomed. There is a cryptographic thing where they need hundreds
of years to crack the machines encryption and shut them down. But humanity and anything that&rsquo;s a biomass doesn&rsquo;t have that
long. So she proposes to create Gaia. Which is a powerful AI that has various subroutine helpers called Hades, Apollo and
others. They contain the digitized version of everything living and after humanity and everything is gone, Gaia will
crack the code eventually in an underground shelter and repopulate the Earth with life. And that&rsquo;s where the robot animals
come in, they are basically terraforming. Making life possible.</p>
<p>But as these things go, something went wrong and Apollo, which contained all knowledge on Earth, has been destroyed and
the people reborn had no idea what&rsquo;s going on, where they are and how they are alive. The initial people were created
in tubes from zygotes.</p>
<p>And here comes Aloy. So Gaia had a subroutine called Hades, to destroy everything if terraforming failed or there was a
catastrophic event and the world needs resetting. Gaia can&rsquo;t do that because she is a fully featured, feeling, sentient
AI who is incapable of destruction and Hades is the opposite. It can take over, destroy, then give back control to Gaia.
Of course, Hades was corrupted and didn&rsquo;t want to give back control and started killing everything. Gaia created Aloy who
is a clone of Elisabeth Sobeck so she could access facilities with biometric scanners all over the place and find out the
truth about the world and fix Gaia and delete Hades.</p>
<p>It&rsquo;s quite the story! Incredibly well written with likable characters all along the way. It was well worth the time spent
on it, even if I didn&rsquo;t catch up on some reading. I regret nothing.</p>
<h2 id="conclusion">Conclusion</h2>
<p>That&rsquo;s it for these months. Next month I&rsquo;m planning on finishing two Go related books hopefully and will write some reviews
about those.</p>
<p>And as always,
Thanks for reading,
Gergely.</p>
]]></description>
    </item>
    
    <item>
      <title>Reader&#39;s Digest 2021-04</title>
      <link>https://skarlso.github.io/2021/04/21/readers-digest/</link>
      <pubDate>Wed, 21 Apr 2021 01:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2021/04/21/readers-digest/</guid>
      <description><![CDATA[<h1 id="readers-digest">Reader&rsquo;s Digest</h1>
<p>I thought it would a cool idea if I kept a summary of the things I&rsquo;ve read or listened to on a monthly
basis. Here is April of 2021 so far. Enjoy.</p>
<h2 id="invincible">Invincible</h2>
<p>After seeing it air on Amazon Prime, I had to go and read the comic. It&rsquo;s quite a lot, but I assure you it&rsquo;s worth it.
Some spoiler alerts&hellip;</p>
<p>Okay, so we follow this guy, Mark Grayson. He&rsquo;s Invincible. He is also and alien, called a Viltrumite. I can hardly
summaries over 3000 pages of comic books so I&rsquo;ll try to be brief.</p>
<p>The Viltrumites are a race of warrior people who wants to conquer the whole galaxy. They also have the power to do so.
They are virtually immortal, live for thousands of years and are very durable. They can fly, have super strength and
a bunch of other things. The stories are insane. We follow all kinds of people across multiverses, a lot of villains and
heroes. There is gore, sex, violance and immature jokes all around. It&rsquo;s fantastic.</p>
<p>There are better episodes and there are boring episodes as it goes with these things. The one thing that bothered me a lot
is that the Viltrumites, of course, have a weak spot. You have to remember that these are people who want to be eliminated
by a lot of other people in the whole galaxy. There is a literal coalition of planets who want to kill them.</p>
<p>And there are two main things which can kill / incapacitate them. The first one is a virus, which was developed by a
traiter Viltrumite which killed like 99.9% of them. And the other is the same weakness as the things have in the movie
called The quiet place. It&rsquo;s specific frequency sound. Granted, some very specific frequency, but it&rsquo;s sound. Because Viltrumites have a
delicate equilibrium because of their flying ability, if there is a specific frequency sound being emitted in close proximity
it can incapacitate or even kill a Viltrumite.</p>
<p>Which makes me wonder that for thousands of years in multiple, parallel universes and with thousands of alien races,
nobody even thought of doing that? It had to be Earth and Humans ( and a Dinosaur ) who came up with it? That&rsquo;s just
implausible really. And after being used only a couple of times, they don&rsquo;t use it again on a global scale!</p>
<p>Anyways. The story is still incredible and it has a lot of amazing content so I encourage comic lovers to read it all!</p>
<h2 id="conclusion">Conclusion</h2>
<p>That&rsquo;s it for this month. Some lengthy blog posts and Invincible pretty much took up my reading time.</p>
<p>And as always,
Thanks for reading,
Gergely.</p>
]]></description>
    </item>
    
    <item>
      <title>Reader&#39;s Digest 2021-03</title>
      <link>https://skarlso.github.io/2021/03/23/readers-digest/</link>
      <pubDate>Tue, 23 Mar 2021 01:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2021/03/23/readers-digest/</guid>
      <description><![CDATA[<h1 id="readers-digest">Reader&rsquo;s Digest</h1>
<p>I thought it would a cool idea if I kept a summary of the things I&rsquo;ve read or listened to on a monthly
basis. Here is March of 2021 so far. Enjoy.</p>
<h2 id="the-aurora-database-paper">The Aurora Database paper</h2>
<p>The paper about Aurora database from AWS can be found here: <a href="http://nil.csail.mit.edu/6.824/2020/papers/aurora.pdf">Paper</a>.
It details the design decision taken to support a highly available, fault tolerant, fast replicating
database. They take the following approach&hellip; They modified mysql database such as that they only send
around the redo log and the redo log is enough to recover / replicate in order to achieve write and
read consistency. They separate the data into Protected Groups and speed up terabytes of recovery by
doing 10 Gigabyte segments in parallel. The database IS the logs. By only replicating the log instead
of the data and the data page, they save millions in networks costs. The main gain however, is that
the storage was modified to understand the application. Instead of using General store they use a storage
which understand the data. In this case, decoupling storage from the database, as so many do, was actually
a drawback.</p>
<h2 id="gcatch-paper">GCatch paper</h2>
<p>This paper is a static concurrency bug analyser for Go found here <a href="https://songlh.github.io/paper/gcatch.pdf">Paper</a>.</p>
<p>It&rsquo;s ingenious! It&rsquo;s a static analyser which finds mostly blocking bugs using channels in Go. In Go, it&rsquo;s
really easy to write concurrent software using something called <a href="https://tour.golang.org/concurrency/2">Channels</a>.
They are basically coroutines multiplexed onto kernel threads and thus you can have a million of them
running around doing stuff. Go effectively made IO operators CPU bound with them. Coroutines aren&rsquo;t new,
however, it&rsquo;s really easy to mess up code with channels in subtle ways. Analyzers exist, however, GCatch
argues that they can&rsquo;t find the most subtle of bugs, only some surface bugs really.</p>
<p>This paper proposes a tool which does inter-procedural, path-sensitive analysis and uses Z3 to find paths
which can lead to deadlocks in code that uses locking primitives and channels. It also contains five other
prominent tools. It converts mutexes into channels internally with buffer size zero and sends on it on
Lock and reads from it on Unlock, then performs a bunch of path combinations and goes through those
suspicious paths and performs its analysis.</p>
<p>They found a hundred and something bugs in Docker and Kubernetes. Things like, sending on a channel in
<code>select</code> when in fact, a timeout already returned, thus that Go routine is not indefinitely stuck. Since
it can&rsquo;t send its output on the channel, the program didn&rsquo;t quit so it&rsquo;s not GC-d. A simple fix is to
make the channel of size 1 so even if there is a chance that the scope quit it can still send and quit.
Like Exec.</p>
<p>It&rsquo;s an interesting read and the tool is awesome, however&hellip;. It was written with Go 14 and it&rsquo;s proving to
be difficult to port to current version using modules. I would hate to see this tool getting left behind
because it can&rsquo;t be turned into a linter.</p>
<h2 id="rhythm-of-war---brandon-sanderson">Rhythm of War - Brandon Sanderson</h2>
<p><a href="https://www.amazon.com/Rhythm-War-Stormlight-Archive-Book-ebook/dp/B0826NKZHR">Amazon</a>.</p>
<p>An epic continuation of this saga with over a 1000 pages long and 54 hours of listening time on Audible.
This story has been ongoing for a while now. Brandon Sanderson came out with the first book back in 2010.
This is the continuation of the Stormlight Archive series. These are massive master pieces. I first came
along Brandon Sanderson when I read the Mistborn series. That was another epic novel. I love reading
Sanderson because he comes up with some unique ways of magic or magic like abilities which have some
divine sense in the end, or have some interesting explanation. And their abilities are almost always
used in interesting ways.</p>
<p>For example, a simple ability to pull or push metal. Turns out that results in things like, shooting
coins, or literally flying as the person tosses a coin to the ground and pushes on it, pushing themselves
upwards in the end.</p>
<p>I could write many many pages about each and every fantastic novel, but I&rsquo;m going to stick to this one
expecting that people know about the series.</p>
<p>I&rsquo;ve listened to this one as I&rsquo;m insane busy, I couldn&rsquo;t have read a 1000 something pages book.
The fantastic work of Micheal Kramer and Kate Reading is always a treat to listen too. They are both
excellent readers always making the characters live through their words.</p>
<p>SPOILERS:</p>
<p>This time we mostly follow Eshonai&rsquo;s and Venli&rsquo;s but we finally also get what we wanted all these years.
Finally, Kaladin and Shallan face their inner demons. And even though they aren&rsquo;t fully okay, Kaladin
speaks his fourth oat and Shallan remembers her past. As much as I love this story, I don&rsquo;t believe I
would have been able to listen or read another 1000 pages without these two resolving their problems.
You root for them so hard, it&rsquo;s exhausting.</p>
<p>I won&rsquo;t spoil everything but the twist at the end left me dumbstruck! It was such an amazing finish.</p>
<p>The story follows the fused as they invade Urithiru. There is a side story for Navani and Jasna
doing their own thing and we do root for Navani and her fantastic discoveries regarding light and powers,
but Jasna is a side character in this story. Another main character is Witt. We finally get to know
who he is and where he comes from. We also understand now that the Fused are actually from another planet
in the same system and Odium just wants to get off this system and fight a holy war with some ancient Gods
somewhere. A lot of things which made no sense are revealed finally. I recommend it if you have the time
to listen or read it.</p>
<h2 id="how-to-take-smart-notes">How to take smart notes</h2>
<p><a href="https://www.amazon.com/How-Take-Smart-Notes-Nonfiction-ebook/dp/B06WVYW33Y">Amazon</a>.</p>
<p>This one&rsquo;s review will be condensed because it would be rather lengthy otherwise. It&rsquo;s basically talking about
how to use the <a href="https://zettelkasten.de/">Zettelkasten</a> system. But it does so much more then that. It challenges
the way you think, the way you learn the way things are taught in school and the way you process and store
information. Condensed I would say these are the main points:</p>
<ul>
<li>Connect new information to existing information. Information without connection isn&rsquo;t worth much and will be
remembered poorly or not at all.</li>
<li>Always read with a pen in your hand and take notes about what you are reading.</li>
<li>Always use your own words and never just copy blindly; by doing this, you will better understand what you just
read. The same goes to things like, writing a blog in which you explain something you think you know. It reveals
the black holes in your knowledge which you didn&rsquo;t even know exist.</li>
<li>Don&rsquo;t try to group based on topics. That will result in forced connections and will leave you confined within
that topic. Topics should emerge from your notes and then gathered into indexes which contain links to related
notes and information.</li>
<li>Tags are useful but don&rsquo;t over do them. If you have a 1000 tags your information will be lost and hard to find
because things that are unrelated will show up in the searches. So go easy on the tags</li>
<li>Note taking is a chore. It&rsquo;s not something that you just do and it just works. Good note taking requires effort.
You take notes while you read then transcribe them into Zettelkasten and throw away the rest. Those are transient
notes. Zettelkasten notes focus on the gist of things. On the meat!</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>And that&rsquo;s all for this months. Rhythm of War, the papers and the note taking book pretty much took all my
time away, so not much else got done since January. But I still think this is a nice finish. Especially
considering Rhythm of War was such a huge epic.</p>
<p>And as always,
Thanks for reading,
Gergely.</p>
]]></description>
    </item>
    
    <item>
      <title>Reader&#39;s Digest 2021-01</title>
      <link>https://skarlso.github.io/2021/02/01/readers-digest/</link>
      <pubDate>Mon, 01 Feb 2021 01:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2021/02/01/readers-digest/</guid>
      <description><![CDATA[<h1 id="readers-digest">Reader&rsquo;s Digest</h1>
<p>I thought it would a cool idea if I kept a summary of the things I&rsquo;ve read or listened to on a monthly
basis. Here is January of 2021 so far. Enjoy.</p>
<h2 id="all-systems-red---murderbot">All systems red - Murderbot</h2>
<p>This book is SHORT. It&rsquo;s little over 3 hours of listening time. I&rsquo;m listening at 1.30 so it&rsquo;s just short of 2 hours.
But it&rsquo;s entertaining. The murderbot series is following a rouge security bot which hacked its own governor module
and is self aware and free. But&hellip; it kind of hates humans and interacting with them. It just calls itself murderbot
but has no intention of killing all humans. Instead, all its wants to do is basically&hellip; watch movies and various series on something called a Feed. In the first book of the series, this one, we follow Murderbot protect a few humans
that it gets to short of like after an attempt on their lives.</p>
<p>The narrator, Kevin R. Free, is doing a great job of impersonating the robot and you can feel the anxiety from his words when inevitably, the robot has to interact with humans. Whether it likes it or not&hellip;</p>
<h2 id="artificial-condition---murderbot">Artificial Condition - Murderbot</h2>
<p>Another short story following our Murderbot. This time, it wants to get to the bottom of a mystery involving its past.
In his past, the Murderbot, when it hacked its governor module, it went berserk and killed 80 people in the process. The company who owned it, covered it all up. Or so it thought. During its journey to find out what happened it met a new friend, Art. Art is a huge vessel capable of massive computing capacity, and happens to also love watching series.
They team up and help a rag-tag group of researchers while trying to find out what happened to Murderbot and those 80 people.</p>
<h2 id="rogue-protocol">Rogue Protocol</h2>
<p>Another fantastic episode of Murderbot. You can sense that the bot is slowly evolving into a more caring bot. Even though it&rsquo;s saying repeatedly that it doesn&rsquo;t case, it starts to care. This book was an action packed one. Lot&rsquo;s of tension and fear inducing moments. Silence then all out war! We also meet Micky, who is a &ldquo;pet bot&rdquo; for some humans. Their relationship starts off as rocky but after a while, Murderbot comes to appreciate Micky for another free soul. There are some open question in there once the story finishes.</p>
<h2 id="the-vexed-generation---magician-20">The vexed generation - Magician 2.0</h2>
<p>Being a programmer, I followed Magician 2.0 with an interest. I listen to all of the books in the series. It was fun at first, but then started to get a bit low in quality and repetitive. I don&rsquo;t really care about the people in it, and I don&rsquo;t really care about what&rsquo;s happening to them. And since they are effectively immortal there is no real danger to them at all. In this episode however, there was real danger at the end. And while the protagonist kids were kind of annoying, and it could have been narrated better and I felt like some of the characters weren&rsquo;t fully utilized, the story kind of still was fun to read. Definitely better than the previous one about dragons.</p>
<h2 id="heavens-river---bobiverse">Heaven&rsquo;s River - Bobiverse</h2>
<p>The latest addition to the Bobiverse universe. This time there is civil war amongst the Bobs and, of course, there is a new species to explore. The species was interesting, and the talk about mega-structures was also interesting, but I found that the lack of coding, and fighting and technical stuff ( what caught me on the first couple of Bob adventures ) left me wanting for more and left me with an empty feeling at the end. I really missed the proves of Bob and couldn&rsquo;t care less about Starfleet.</p>
<h2 id="armada">Armada</h2>
<p>This one was interesting. It talks about the same premise as The Last Starfighter ( there is a reference to that in there ) which I found fascinating as a child. It is about the fact that an alien race uses video games to find the best soldier for a mission to save the universe. This time though the Earth is doing the recruiting and it is against an alien invasion. And much like Ender&rsquo;s Game, it turns out that the threat is real and that all fighting on the video game that our protagonist did was preparing him for this situation. The twist was pretty good too.</p>
<h2 id="prometheus-up-and-running">Prometheus Up And Running</h2>
<p>This one has a larger post incoming.</p>
<p>That&rsquo;s all for this month.
Thanks for reading,
Gergely.</p>
]]></description>
    </item>
    
  </channel>
</rss>