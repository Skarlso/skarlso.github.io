<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Ramblings of a cloud engineer</title>
    <link>https://skarlso.github.io/categories/golang/</link>
    <description>Recent content in Golang on Ramblings of a cloud engineer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 17 Feb 2020 21:01:00 +0100</lastBuildDate>
    
	<atom:link href="https://skarlso.github.io/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>How to Make SPA refresh work with a Go backend</title>
      <link>https://skarlso.github.io/2020/02/17/making-spa-refresh-work-with-go-backend/</link>
      <pubDate>Mon, 17 Feb 2020 21:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2020/02/17/making-spa-refresh-work-with-go-backend/</guid>
      <description>Intro Hi folks.
Today I would like to share a quick &amp;ldquo;fix&amp;rdquo; for a problem I&amp;rsquo;ve seen popping up here and there.
That is, if you have a react frontend which is a SPA app but you still want refresh to work. What do I mean by that? Consider the following&amp;hellip;
The problem You have a SPA app with a react router which navigates the user around. The app calls to a backend api which serves content of some kind.</description>
    </item>
    
    <item>
      <title>Summary of Practical Go workshop from Dave Cheney</title>
      <link>https://skarlso.github.io/2019/10/10/practical-go-summary/</link>
      <pubDate>Thu, 10 Oct 2019 21:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2019/10/10/practical-go-summary/</guid>
      <description>Intro Hi folks.
So there is this workshop from Dave Cheney.
And I thought I&amp;rsquo;d draw a sort of summary of that workshop.
Right-click-&amp;gt;Open Image for higher resolution.
Cheers, Gergely.</description>
    </item>
    
    <item>
      <title>Efferent and Afferent metrics in Go</title>
      <link>https://skarlso.github.io/2019/04/21/efferent-and-afferent-metrics-in-go/</link>
      <pubDate>Sun, 21 Apr 2019 21:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2019/04/21/efferent-and-afferent-metrics-in-go/</guid>
      <description>Intro Hi folks!
Today I would like to write about a metric that I read in a book called Clean Architecture from Robert Cecil Martin ( Uncle Bob ).
Abstract The metrics I mean are Efferent and Afferent coupling in packages. So you, dear reader, don&amp;rsquo;t have to navigate away from this page, here are the descriptions pasted in:
 Afferent couplings (Ca): The number of classes in other packages that depend upon classes within the package is an indicator of the package&amp;rsquo;s responsibility.</description>
    </item>
    
    <item>
      <title>Go SSH with Host Key Verification</title>
      <link>https://skarlso.github.io/2019/02/17/go-ssh-with-host-key-verification/</link>
      <pubDate>Sun, 17 Feb 2019 21:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2019/02/17/go-ssh-with-host-key-verification/</guid>
      <description>Hi folks.
Following a long search and reading lots of debates and possibilities of doing SSH within Go, I was shocked to see that not a great many tools and people use SSH with host key verification. What I usually see is this:
HostKeyCallback: ssh.InsecureIgnoreHostKey() This is terrible. Now, I realise that doing HostKeyVerification can be tedious, but don&amp;rsquo;t fear. It&amp;rsquo;s actually easy now that the Go team provided the knownhosts subpackage in their crypto SSH package located here: KnownHosts.</description>
    </item>
    
    <item>
      <title>Extensive tutorial on go-plugin.</title>
      <link>https://skarlso.github.io/2018/10/29/go-plugin-tutorial/</link>
      <pubDate>Mon, 29 Oct 2018 07:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2018/10/29/go-plugin-tutorial/</guid>
      <description>Intro If you don&amp;rsquo;t know what go-plugin is, don&amp;rsquo;t worry, here is a small introduction on the subject matter:
Back in the old days when Go didn&amp;rsquo;t have the plugin package, HashiCorp was desperately looking for a way to use plugins.
In the old days, Lua plus Go wasn&amp;rsquo;t really a thing yet, and to be honest, nobody wants to write Lua ( joking!).
And thus Mitchell had this brilliant idea of using RPC over the local network to serve a local interface as something that could easily be implemented with any other language that supported RPC.</description>
    </item>
    
    <item>
      <title>Furnace with a new Plugin System</title>
      <link>https://skarlso.github.io/2018/09/17/furnace-plugin-update/</link>
      <pubDate>Mon, 17 Sep 2018 07:01:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2018/09/17/furnace-plugin-update/</guid>
      <description>Hi.
A quick update, but a very important and interesting one hopefully. Furnace just got a massive boost to its plugin system.
I&amp;rsquo;m using HashiCorp&amp;rsquo;s Go-Plugins system now to handle plugins. This means one of two things that are interesting to the plugin author.
One, plugins can be written in any language which is supported by Furnace and supports GRPC. Currently this means that plugins can be written in the following languages:</description>
    </item>
    
    <item>
      <title>Furnace - The building of an AWS CLI Tool for CloudFormation and CodeDeploy - Part 4</title>
      <link>https://skarlso.github.io/2017/04/16/building-furnace-part-4/</link>
      <pubDate>Sun, 16 Apr 2017 09:23:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2017/04/16/building-furnace-part-4/</guid>
      <description>Intro Hi folks.
Previously on this blog: Part 1. Part 2. Part 3.
In this part we are going to talk about Unit Testing Furnace and how to work some magic with AWS and Go.
Mock Stub Fake Dummy Canned  Unit testing in Go usually follows the Dependency Injection model of dealing with Mocks and Stubs.
## DI
Dependency Inject in short is one object supplying the dependencies of another object.</description>
    </item>
    
    <item>
      <title>Furnace - The building of an AWS CLI Tool for CloudFormation and CodeDeploy - Part 4</title>
      <link>https://skarlso.github.io/2017/04/16/building-furnace-part-4/</link>
      <pubDate>Sun, 16 Apr 2017 09:23:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2017/04/16/building-furnace-part-4/</guid>
      <description>Intro Hi folks.
Previously on this blog: Part 1. Part 2. Part 3.
In this part we are going to talk about Unit Testing Furnace and how to work some magic with AWS and Go.
Mock Stub Fake Dummy Canned  Unit testing in Go usually follows the Dependency Injection model of dealing with Mocks and Stubs.
## DI
Dependency Inject in short is one object supplying the dependencies of another object.</description>
    </item>
    
    <item>
      <title>Furnace - The building of an AWS CLI Tool for CloudFormation and CodeDeploy - Part 3</title>
      <link>https://skarlso.github.io/2017/03/22/building-furnace-part-3/</link>
      <pubDate>Wed, 22 Mar 2017 12:03:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2017/03/22/building-furnace-part-3/</guid>
      <description>Intro Hi folks.
Previously on this blog: Part 1. Part 2. Part 4.
In this part, I&amp;rsquo;m going to talk about the experimental plugin system of Furnace.
Go Experimental Plugins Since Go 1.8 was released, an exciting and new feature was introduced called a Plug-in system. This system works with dynamic libraries built with a special switch to go build. These libraries, .so or .dylib (later), are than loaded and once that succeeds, specific functions can be called from them (symbol resolution).</description>
    </item>
    
    <item>
      <title>Furnace - The building of an AWS CLI Tool for CloudFormation and CodeDeploy - Part 3</title>
      <link>https://skarlso.github.io/2017/03/22/building-furnace-part-3/</link>
      <pubDate>Wed, 22 Mar 2017 12:03:00 +0100</pubDate>
      
      <guid>https://skarlso.github.io/2017/03/22/building-furnace-part-3/</guid>
      <description>Intro Hi folks.
Previously on this blog: Part 1. Part 2. Part 4.
In this part, I&amp;rsquo;m going to talk about the experimental plugin system of Furnace.
Go Experimental Plugins Since Go 1.8 was released, an exciting and new feature was introduced called a Plug-in system. This system works with dynamic libraries built with a special switch to go build. These libraries, .so or .dylib (later), are than loaded and once that succeeds, specific functions can be called from them (symbol resolution).</description>
    </item>
    
  </channel>
</rss>