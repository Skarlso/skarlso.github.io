<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Hacking on CAPA - The journey of implementing a nontrivial feature in a barely known codebase | Ramblings of a cloud engineer</title>
<meta name="keywords" content="">
<meta name="description" content="Hacking on CAPA - The journey of implementing a nontrivial feature in a barely known codebase
Hello Dear readers.
Today, I would like to write about a project I&rsquo;ve been working on these past months or so. This is a longer story
and hopefully an interesting one to read.
I&rsquo;m going to write about the journey I took while trying to implement IPv6 based Kubernetes cluster for CAPA
and EKS.
The interesting points of this journey are twofold. First, understanding IPv6 in AWS land and how it&rsquo;s configured
and how it works. What are it&rsquo;s limitations and requirements? Topology, routing, security groups, launch configuration,
IAM roles, node policies&hellip; etc.">
<meta name="author" content="hannibal">
<link rel="canonical" href="https://skarlso.github.io/2022/06/26/hacking-on-capa/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://skarlso.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://skarlso.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://skarlso.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://skarlso.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://skarlso.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://skarlso.github.io/2022/06/26/hacking-on-capa/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Hacking on CAPA - The journey of implementing a nontrivial feature in a barely known codebase">
<meta property="og:description" content="Hacking on CAPA - The journey of implementing a nontrivial feature in a barely known codebase
Hello Dear readers.
Today, I would like to write about a project I&rsquo;ve been working on these past months or so. This is a longer story
and hopefully an interesting one to read.
I&rsquo;m going to write about the journey I took while trying to implement IPv6 based Kubernetes cluster for CAPA
and EKS.
The interesting points of this journey are twofold. First, understanding IPv6 in AWS land and how it&rsquo;s configured
and how it works. What are it&rsquo;s limitations and requirements? Topology, routing, security groups, launch configuration,
IAM roles, node policies&hellip; etc.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://skarlso.github.io/2022/06/26/hacking-on-capa/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-06-26T01:01:00+01:00">
<meta property="article:modified_time" content="2022-06-26T01:01:00+01:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hacking on CAPA - The journey of implementing a nontrivial feature in a barely known codebase">
<meta name="twitter:description" content="Hacking on CAPA - The journey of implementing a nontrivial feature in a barely known codebase
Hello Dear readers.
Today, I would like to write about a project I&rsquo;ve been working on these past months or so. This is a longer story
and hopefully an interesting one to read.
I&rsquo;m going to write about the journey I took while trying to implement IPv6 based Kubernetes cluster for CAPA
and EKS.
The interesting points of this journey are twofold. First, understanding IPv6 in AWS land and how it&rsquo;s configured
and how it works. What are it&rsquo;s limitations and requirements? Topology, routing, security groups, launch configuration,
IAM roles, node policies&hellip; etc.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://skarlso.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Hacking on CAPA - The journey of implementing a nontrivial feature in a barely known codebase",
      "item": "https://skarlso.github.io/2022/06/26/hacking-on-capa/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Hacking on CAPA - The journey of implementing a nontrivial feature in a barely known codebase",
  "name": "Hacking on CAPA - The journey of implementing a nontrivial feature in a barely known codebase",
  "description": "Hacking on CAPA - The journey of implementing a nontrivial feature in a barely known codebase Hello Dear readers.\nToday, I would like to write about a project I\u0026rsquo;ve been working on these past months or so. This is a longer story and hopefully an interesting one to read.\nI\u0026rsquo;m going to write about the journey I took while trying to implement IPv6 based Kubernetes cluster for CAPA and EKS.\nThe interesting points of this journey are twofold. First, understanding IPv6 in AWS land and how it\u0026rsquo;s configured and how it works. What are it\u0026rsquo;s limitations and requirements? Topology, routing, security groups, launch configuration, IAM roles, node policies\u0026hellip; etc.\n",
  "keywords": [
    
  ],
  "articleBody": "Hacking on CAPA - The journey of implementing a nontrivial feature in a barely known codebase Hello Dear readers.\nToday, I would like to write about a project I’ve been working on these past months or so. This is a longer story and hopefully an interesting one to read.\nI’m going to write about the journey I took while trying to implement IPv6 based Kubernetes cluster for CAPA and EKS.\nThe interesting points of this journey are twofold. First, understanding IPv6 in AWS land and how it’s configured and how it works. What are it’s limitations and requirements? Topology, routing, security groups, launch configuration, IAM roles, node policies… etc.\nThe second part is the codebase of CAPA, which was largely unknown to me. What I’m going to write about here is how I navigated these hurdles.\nTL;DR I take lots of notes and re-work these notes into a semi-zettelkasten format I read RFCs and documentations a couple times I start exploring the codebase by reading package information and going through a known code path like, creating a cluster and reading tests I had some prior knowledge due to working on a similar project at Weaveworks ( implementing ipv6 for eksctl ) I had ample of help from one of the project maintainers who happens to work at Weaveworks I had some documentation already available on IPv6 and AWS and could compare to existing, working IPv6 clusters using eksctl What is CAPA Before I begin, let’s talk about what CAPA is. It’s a project which implements cluster API for Kubernetes using AWS. CAPI ( Cluster API ) is simply a set of API projects and tooling for Kubernetes to basically use Kubernetes programmatically. It provides a way to create clusters using a management cluster which runs the API code using a couple CRDs and controllers.\nOnce you create your management cluster, you can apply a YAML template which will use the AWS API to create a set of objects for an EKS cluster. These are for example, IAM roles, a VPC, subnets, routing tables, security groups, IGWs, NAT gateways, instances and many many more things. Once that’s done it will keep reconciling the cluster. Detect diffs and manage its state until you remove the resources for it ( the CRDs installed onto the management cluster ).\nIPv6 The first thing to tackle was understanding and knowing IPv6. Though, funny enough, as we’ll see later, it wasn’t a hard requirement. Never the less, it did me good to study up on it.\nHow do I approach the unknown The reason why I wanted to understand IPv6 was because of how to calculate subnets. Subnetting is an interesting topic in the land of IPs and one that isn’t easy to grasp if you aren’t into these kinds of things in the first place.\nI did learn how to calculate CIDRs for IPv4 so I thought it should be kind of in the same ballpark. It actually took me a while to find a resource which neatly explained the math behind the calculations and not just throw a website into my face into which you input a prefix range and done, you have your subnets. I rarely watch videos but this one has a neat explanation with detailed calculations and samples.\nWhat I do in these cases, is as follows. I open up a new page in my trusty notebook and start listing what things I can read or watch to understand the subject at hand better. Then I slowly start working down my list, taking notes from the material or video in a fashion similar as what is depicted in Effective Note taking book written by Dr. Fiona McPherson. I create concept graphs and various visuals and just write down my thoughts.\nI’ll try to connect to future notes or write ideas next to it, things like “Oh this will be useful when I do x,y,z”.\nA page from one my notes:\nThis is in pre-review format. Once I’m done with a material, I’ll start translating the notes and get the gist of it into a semi-zettelkasten type of note system using Obsidian. Or if it makes more sense, I’ll use a single obsidian note to collect all the things together. For this implementation I’m doing on CAPA I have a single file which points to various other files with various other information about the code and about IPv6 itself.\nOnce I translated my written notes, I’ll move on to the next topic. I have lots of tags and always create back-links. I use something akin to Zettelkasten but with a slight modification that sometimes my atomic notes contain a bit more information than a single idea.\nWhy use a notebook in the digital age? I like writing by hand. It gives me a motoric impression of the subject and drawing pictures is a lot easier. Also, I found if I take notes on the computer in Obsidian directly, I tend to ramble more because typing is so easy. Which leaves my notes full of unnecessary information that I have to go through when refining. Lots more to read. Further, typing is so easy indeed, that it’s too easy. There are no motoric impressions, no muscle memory built no aid in thinking. And lastly, the linear nature of a notebook forces me to focus on a single thing at once unless I want my notes completely jumbled up. If I’m on the computer I found I tend to jump around different subjects all the time and not finish what I started.\nThis blog post’s idea has its origins in a notebook.\nUnderstanding IPv6 The first step I took was to understand IPv6 itself. I already knew a couple of things about it, but I didn’t intimately knew its structure and composition. The best way to know about these things is go to the source. I read a couple of RFCs about it. Notably RFC 8200 - The protocol itself and RFC 4291 - The Address itself.\nReading these and taking notes and understanding the underlying technology made me not be afraid of it anymore. But also it had the added benefit of me understanding why some of the decisions were made at AWS. I have a saying.\nIf you are afraid of it, you have to do it. If some technology or software concept or hard problem intimidates you THAT is a clear sign that you have to understand it and make it your own.\nNext, I watched the video about subnetting and read some posts, of which I saved the links and took some notes that I connected back to my existing notes, to get a large picture and the immediate usage and interesting parts of IPv6.\nIt was time to put it all in perspective.\nUnderstanding IPv6 in relation to AWS As always with AWS finding documentation which describes a feature in its completeness is near impossible. I found various blog posts, some hints here and there and when you open the EKS console page, there is an announcement at the top that they started supporting IPv6. That page contains some information about restrictions and requirements. But nothing profound enough to know how to call some APIs or what to set up or how routing works exactly. Or what to pass to the VPC. Or how to slice subnets not using eksctl and cloudformation.\nLucky for me, I had some prior knowledge in the area. I work at https://weave.works/. And at eksctl a couple of co-workers of mine already did some research and created some documentations that I was able to follow. But ultimately, that was using a different approach because it’s using CloudFormation. But the notes on security groups and VPCs was invaluable.\nThe other guide which helped me was the VPC usage guide and the IPv6 section. And the EKS usage guide and how to migrate to IPv6 clusters. There were numerous restrictions which helped me understand what I needed to create. I read these over 5-6 times.\nFrom all of these, notes taken into my trusty notebook in which I gathered together all the relevant information that I could connect to things I needed, I slowly put together an approach for CAPA.\nI also had the benefit that I could compare my CAPA created network topology to that of an eksctl created cluster. I could verify that the cluster created by CAPA had similar routings, VPCs and subnet configuration.\nFor example, a “private” ( there is no such thing as private in the land of IPv6 ( there are no private/local ips ) ) VPC configuration requires an Egress Only Internet Gateway for IPv6 clusters so network translation can still work.\nThe most difficult part though to discover was subnetting.\nThe journey of subnetting IPv6 My first approach was the mathematical one. I implemented code which would slice an IPv6 address into the needed number of subnets based on AZs that looked like this:\nfunc SplitIntoSubnetsIPv6(cidrBlock string, numSubnets int) ([]*net.IPNet, error) { _, parent, err := net.ParseCIDR(cidrBlock) if err != nil { return nil, errors.Wrap(err, \"failed to parse CIDR\") } subnetBits := math.Ceil(math.Log2(float64(numSubnets))) networkLen, addrLen := parent.Mask.Size() modifiedNetworkLen := networkLen + int(subnetBits) if modifiedNetworkLen \u003e addrLen { return nil, errors.Errorf(\"cidr range %s cannot accommodate %d subnets\", cidrBlock, numSubnets) } addr, err := netaddr.ParseIPv6Net(cidrBlock) if err != nil { return nil, errors.Wrapf(err, \"failed to parse network address %s\", cidrBlock) } var subnets []*net.IPNet for i := 0; i \u003c numSubnets; i++ { subnetIP := addr.NthSubnet(uint(modifiedNetworkLen), uint64(i)) if subnetIP == nil { return nil, errors.Errorf(\"exceeded the subnet space with len %d\", modifiedNetworkLen) } parsedSubnetIP, _, err := net.ParseCIDR(subnetIP.Long()) if err != nil { return nil, err } v := \u0026net.IPNet{ IP: parsedSubnetIP, Mask: net.CIDRMask(modifiedNetworkLen, 128), } subnets = append(subnets, v) } return subnets, nil } It’s using a library to calculate the actual new IP based on NthSubnet. I did some bit shifting myself, but that turned out to be not so error resilient and didn’t handle some edge cases that the library already did.\nHowever, this research all turned out to be mute once I re-read my notes and some of the docs and I internalized the point that all subnets have a fixed prefix length of 64. And further reading about subnet IDs in IPv6 and creating IPv6 clusters using the console it became apparent that subnets are super easy, barely an inconvenience.\nSee, it basically works like this. You get an IPv6 pool and an IPv6 address with a fixed prefix length of 56. You need to switch that to 64 and just increase the subnet ID for any further subnets. This looks like this:\nfunc SplitIntoSubnetsIPv6(cidrBlock string, numSubnets int) ([]*net.IPNet, error) { _, ipv6CidrBlock, err := net.ParseCIDR(cidrBlock) if err != nil { return nil, fmt.Errorf(\"failed to parse cidr block %s with error: %w\", cidrBlock, err) } // update the prefix to 64. ipv6CidrBlock.Mask = net.CIDRMask(64, 128) var ( subnets []*net.IPNet ) for i := 0; i \u003c numSubnets; i++ { ipv6CidrBlock.IP[subnetIDLocation]++ newIP := net.ParseIP(ipv6CidrBlock.IP.String()) v := \u0026net.IPNet{ IP: newIP, Mask: net.CIDRMask(64, 128), } subnets = append(subnets, v) } return subnets, nil } Boom. And that’s all there is to it! That’s mostly what the CloudFormation is doing internally too.\nWhy do you still need subnets? Once I gathered all resources that needed updates, it was time to write them down. Subnets and networking are obviously the two big hitters. With IPv4 we needed the separation and a thing called SecondaryCidrBlock because you can easily run out of ips. With IPv6 you don’t need to worry about that. However, we do still need to subnet, because we want resiliency through availability zones. Each AZ gets a subnet and an assigned IPv6 address.\nPrivate networking Another thing of the past is private networking. There no private addresses or local addresses for IPv6. All IPv6 addresses are public. Which means, we need another way of defining a private network. That is achieved through security groups and routing. The routes will have a new resource called EgressOnlyInternetGateway. Which is basically what it says. An IWG which works with IPv6 addresses, allows for outgoing communication through IPv6 but blocks all incoming data through IPv6.\nImplementation Time Alright. With these things out of the way, it was time to get acquainted with the source code.\nApproaching an unknown codebase I had the a couple of things on my side.\nI had ample of experience with working with controllers in Kubernetes I had personally wrote couple of projects which worked with AWS and the GO SDK I had experience in working with AWS in general I had one of the maintainers as a colleague working here at Weaveworks How did these things help me? Let’s take a look.\nThe fact that I already worked with a lot of controllers makes me aware of a couple of things when working with such a codebase. What are these?\nThe API is versioned in a certain way like alphav1 and alphav2 and betav1 and so on Lots and LOTS of generated code Controller lifecycle What does this mean? This has a couple of baggages when you think about it. The code has a reconciliation loop which takes care of creating, updating and deleting resources based on their state. But this also means that you have to always consider existing infrastructure and objects in Kubernetes. And when deleting you always have to be aware of finalizers. Unit testing and mocking calls and Kubernetes Certain package structure and code constructs All these helped me massively to discover where things are and why. Richard ( the maintainer ) talked us through a general flow and from there it was easier to go with the flow. And he was constantly available when I was stuck at a certain part like conversions…\nAnalysing the code When faced with the unknown you must find what you might no in relation. I already knew it creates a cluster and that cluster has resources and log outputs. So… follow the flow. I started checking out the code and followed a create code path. How a cluster is reconciled.\nI started taking notes and write down which package and path did what. I started following reconcileCluster. This is the main flow. It contained everything. I glanced over the sub flows of reconciling providers and security groups and the likes, but I mainly kept with the main flow.\nThis limitation allowed me to focus on the most important bits. Where code lives, why and how it is configured. Once I knew all of these things, I could focus on various sub-flows. Since my main focus was altering the network and instance bits, I focused on ReconcileNetwork flow and Machines.\nAgain, same thing. Go over the main flow, follow the code path, see how things are set up where they live and why, but don’t go too deep. Once the main flow is understood, follow the sub-flow, like reconcileVPC.\nUpdate, test, update, test… Once I got a feel for things and noted down places where I probably will have to update something, I started updating things incrementally. Small bits at a time. My first update, for example, was this trivial thing:\n// EnableIPv6 requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for // the VPC. You cannot specify the range of IP addresses, or the size of the // CIDR block. // +optional EnableIPv6 bool `json:\"enableIPv6\"` Basically I started updating the config types. It was a small, trivial thin to add but it got the ball rolling. Which is the most important part of tackling a hard problem. When the codebase is daunting and you have no idea where to even begin, a tiny update can make all the differences. It gets you started. It gives you an entry point.\nI started adding more new settings and types and once I had all the settings I could think of, I started writing code which actually used them. First, gradually. Things like these came in to picture:\ns.scope.VPC().EnableIPv6 = vpc.EnableIPv6 s.scope.VPC().IPv6CidrBlock = vpc.IPv6CidrBlock s.scope.VPC().IPv6Pool = vpc.IPv6Pool Just a trivial assignment. Then a tiny bit of logic…\nif !s.scope.VPC().EnableIPv6 { return \u0026infrav1.VPCSpec{ ID: *out.Vpc.VpcId, CidrBlock: *out.Vpc.CidrBlock, Tags: converters.TagsToMap(out.Vpc.Tags), }, nil } Deal with things that returned with normal flow. Here, the important part is that CIDR block is defined instead of IPv6CidrBlock.\nThese small, incremental updates, eventually lead to this pr: PR. As of this writing it needs some validations added and an e2e test, but it’s pretty much complete.\nTesting Tests are super important in a new codebase ( in an old one too, but that’s a different story ). Reading the tests helps me understand somewhat how the code is structured and what it does and why and what calls are expected to happen. What I do is, that I fiddle with the code and start to run the unit tests and see what things fail. That gives me more insight into how the thing I just changed works. This is invaluable when I’m facing code which is difficult to decipher.\nWrite tests folks! I don’t care if you use TDD or not, jut PLEASE write tests!\nConclusion If you made it this far, congratulations! You deserve a cookie. This has been my journey in understanding a fairly new thing and implementing it into a largely unknown codebase. How I approached it and how I eventually ended up writing around +2500 lines of code. You got some insight into how I take notes and how I figure out a larger problem in an unknown environment. I hope it was a good read and worth your time.\nThank you for reading!\nGergely.\n",
  "wordCount" : "2947",
  "inLanguage": "en",
  "datePublished": "2022-06-26T01:01:00+01:00",
  "dateModified": "2022-06-26T01:01:00+01:00",
  "author":{
    "@type": "Person",
    "name": "hannibal"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://skarlso.github.io/2022/06/26/hacking-on-capa/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ramblings of a cloud engineer",
    "logo": {
      "@type": "ImageObject",
      "url": "https://skarlso.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://skarlso.github.io/" accesskey="h" title="Ramblings of a cloud engineer (Alt + H)">Ramblings of a cloud engineer</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://skarlso.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/search/" title="Search">
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://skarlso.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://skarlso.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Hacking on CAPA - The journey of implementing a nontrivial feature in a barely known codebase
    </h1>
    <div class="post-meta"><span title='2022-06-26 01:01:00 +0100 +0100'>June 26, 2022</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;hannibal

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#hacking-on-capa---the-journey-of-implementing-a-nontrivial-feature-in-a-barely-known-codebase" aria-label="Hacking on CAPA - The journey of implementing a nontrivial feature in a barely known codebase">Hacking on CAPA - The journey of implementing a nontrivial feature in a barely known codebase</a><ul>
                        
                <li>
                    <a href="#tldr" aria-label="TL;DR">TL;DR</a></li>
                <li>
                    <a href="#what-is-capa" aria-label="What is CAPA">What is CAPA</a></li>
                <li>
                    <a href="#ipv6" aria-label="IPv6">IPv6</a><ul>
                        
                <li>
                    <a href="#how-do-i-approach-the-unknown" aria-label="How do I approach the unknown">How do I approach the unknown</a><ul>
                        
                <li>
                    <a href="#why-use-a-notebook-in-the-digital-age" aria-label="Why use a notebook in the digital age?">Why use a notebook in the digital age?</a></li></ul>
                </li>
                <li>
                    <a href="#understanding-ipv6" aria-label="Understanding IPv6">Understanding IPv6</a></li>
                <li>
                    <a href="#understanding-ipv6-in-relation-to-aws" aria-label="Understanding IPv6 in relation to AWS">Understanding IPv6 in relation to AWS</a><ul>
                        
                <li>
                    <a href="#the-journey-of-subnetting-ipv6" aria-label="The journey of subnetting IPv6">The journey of subnetting IPv6</a></li></ul>
                </li>
                <li>
                    <a href="#why-do-you-still-need-subnets" aria-label="Why do you still need subnets?">Why do you still need subnets?</a></li>
                <li>
                    <a href="#private-networking" aria-label="Private networking">Private networking</a></li></ul>
                </li>
                <li>
                    <a href="#implementation-time" aria-label="Implementation Time">Implementation Time</a><ul>
                        
                <li>
                    <a href="#approaching-an-unknown-codebase" aria-label="Approaching an unknown codebase">Approaching an unknown codebase</a></li>
                <li>
                    <a href="#analysing-the-code" aria-label="Analysing the code">Analysing the code</a></li>
                <li>
                    <a href="#update-test-update-test" aria-label="Update, test, update, test&hellip;">Update, test, update, test&hellip;</a></li></ul>
                </li>
                <li>
                    <a href="#testing" aria-label="Testing">Testing</a></li></ul>
                </li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="hacking-on-capa---the-journey-of-implementing-a-nontrivial-feature-in-a-barely-known-codebase">Hacking on CAPA - The journey of implementing a nontrivial feature in a barely known codebase<a hidden class="anchor" aria-hidden="true" href="#hacking-on-capa---the-journey-of-implementing-a-nontrivial-feature-in-a-barely-known-codebase">#</a></h1>
<p>Hello Dear readers.</p>
<p>Today, I would like to write about a project I&rsquo;ve been working on these past months or so. This is a longer story
and hopefully an interesting one to read.</p>
<p>I&rsquo;m going to write about the journey I took while trying to implement IPv6 based Kubernetes cluster for <a href="https://github.com/kubernetes-sigs/cluster-api-provider-aws">CAPA</a>
and EKS.</p>
<p>The interesting points of this journey are twofold. First, understanding IPv6 in AWS land and how it&rsquo;s configured
and how it works. What are it&rsquo;s limitations and requirements? Topology, routing, security groups, launch configuration,
IAM roles, node policies&hellip; etc.</p>
<p>The second part is the codebase of CAPA, which was largely unknown to me. What I&rsquo;m going to write about here is
how I navigated these hurdles.</p>
<h2 id="tldr">TL;DR<a hidden class="anchor" aria-hidden="true" href="#tldr">#</a></h2>
<ul>
<li>I take lots of notes and re-work these notes into a semi-zettelkasten format</li>
<li>I read RFCs and documentations a couple times</li>
<li>I start exploring the codebase by reading package information and going through a known code path like, creating a
cluster and reading tests</li>
<li>I had some prior knowledge due to working on a similar project at Weaveworks ( implementing ipv6 for eksctl )</li>
<li>I had ample of help from one of the project maintainers who happens to work at Weaveworks</li>
<li>I had some documentation already available on IPv6 and AWS and could compare to existing, working IPv6 clusters
using eksctl</li>
</ul>
<h2 id="what-is-capa">What is CAPA<a hidden class="anchor" aria-hidden="true" href="#what-is-capa">#</a></h2>
<p>Before I begin, let&rsquo;s talk about what <a href="https://github.com/kubernetes-sigs/cluster-api-provider-aws">CAPA</a> is. It&rsquo;s a project which implements
<a href="https://cluster-api.sigs.k8s.io/">cluster API</a> for Kubernetes using AWS. CAPI ( Cluster API ) is simply a set of API
projects and tooling for Kubernetes to basically use Kubernetes programmatically. It provides a way to create
clusters using a management cluster which runs the API code using a couple CRDs and controllers.</p>
<p>Once you create your management cluster, you can apply a YAML template which will use the AWS API to create a set of
objects for an EKS cluster. These are for example, IAM roles, a VPC, subnets, routing tables, security groups, IGWs, NAT gateways,
instances and many many more things. Once that&rsquo;s done it will keep reconciling the cluster. Detect diffs and manage its
state until you remove the resources for it ( the CRDs installed onto the management cluster ).</p>
<h2 id="ipv6">IPv6<a hidden class="anchor" aria-hidden="true" href="#ipv6">#</a></h2>
<p>The first thing to tackle was understanding and knowing IPv6. Though, funny enough, as we&rsquo;ll see later, it wasn&rsquo;t a hard
requirement. Never the less, it did me good to study up on it.</p>
<h3 id="how-do-i-approach-the-unknown">How do I approach the unknown<a hidden class="anchor" aria-hidden="true" href="#how-do-i-approach-the-unknown">#</a></h3>
<p>The reason why I wanted to understand IPv6 was because of how to calculate subnets. Subnetting is an interesting topic
in the land of IPs and one that isn&rsquo;t easy to grasp if you aren&rsquo;t into these kinds of things in the first place.</p>
<p>I did learn how to calculate CIDRs for IPv4 so I thought it should be kind of in the same ballpark. It actually took me
a while to find a resource which neatly explained the math behind the calculations and not just throw a website into my
face into which you input a prefix range and done, you have your subnets. I rarely watch videos but <a href="https://www.youtube.com/watch?v=KSiZ751-Zs8">this</a> one has
a neat explanation with detailed calculations and samples.</p>
<p>What I do in these cases, is as follows. I open up a new page in my trusty notebook and start listing what things I
can read or watch to understand the subject at hand better. Then I slowly start working down my list, taking notes from
the material or video in a fashion similar as what is depicted in <a href="https://www.amazon.de/-/en/Fiona-McPherson/dp/1927166527/">Effective Note taking</a> book
written by Dr. Fiona McPherson. I create concept graphs and various visuals and just write down my thoughts.</p>
<p>I&rsquo;ll try to connect to future notes or write ideas next to it, things like &ldquo;Oh this will be useful when I do x,y,z&rdquo;.</p>
<p>A page from one my notes:</p>
<p><img alt="page1" loading="lazy" src="/img/2022/06/27/notes-01.jpeg"></p>
<p>This is in pre-review format. Once I&rsquo;m done with a material, I&rsquo;ll start translating the notes and get the gist of it into a
semi-zettelkasten type of note system using Obsidian. Or if it makes more sense, I&rsquo;ll use a single obsidian note to
collect all the things together. For this implementation I&rsquo;m doing on CAPA I have a single file which points to various
other files with various other information about the code and about IPv6 itself.</p>
<p>Once I translated my written notes, I&rsquo;ll move on to the next topic. I have lots of tags and always create back-links. I use
something akin to <a href="https://zettelkasten.de/posts/overview/">Zettelkasten</a> but with a slight modification that sometimes
my atomic notes contain a bit more information than a single idea.</p>
<h4 id="why-use-a-notebook-in-the-digital-age">Why use a notebook in the digital age?<a hidden class="anchor" aria-hidden="true" href="#why-use-a-notebook-in-the-digital-age">#</a></h4>
<p>I like writing by hand. It gives me a motoric impression of the subject and drawing pictures is a lot easier. Also, I
found if I take notes on the computer in Obsidian directly, I tend to ramble more because typing is so easy. Which leaves
my notes full of unnecessary information that I have to go through when refining. Lots more to read. Further, typing is
so easy indeed, that it&rsquo;s too easy. There are no motoric impressions, no muscle memory built no aid in thinking. And lastly,
the linear nature of a notebook forces me to focus on a single thing at once unless I want my notes completely jumbled up.
If I&rsquo;m on the computer I found I tend to jump around different subjects all the time and not finish what I started.</p>
<p>This blog post&rsquo;s idea has its origins in a notebook.</p>
<h3 id="understanding-ipv6">Understanding IPv6<a hidden class="anchor" aria-hidden="true" href="#understanding-ipv6">#</a></h3>
<p>The first step I took was to understand IPv6 itself. I already knew a couple of things about it, but I didn&rsquo;t intimately knew
its structure and composition. The best way to know about these things is go to the source. I read a couple of RFCs
about it. Notably <a href="https://datatracker.ietf.org/doc/html/rfc8200">RFC 8200 - The protocol itself</a> and <a href="https://datatracker.ietf.org/doc/html/rfc4291">RFC 4291 - The Address itself</a>.</p>
<p>Reading these and taking notes and understanding the underlying technology made me not be afraid of it anymore. But also
it had the added benefit of me understanding why some of the decisions were made at AWS. I have a saying.</p>
<p>If you are afraid of it, you have to do it. If some technology or software concept or hard problem intimidates you THAT
is a clear sign that you have to understand it and make it your own.</p>
<p>Next, I watched the video about subnetting and read some posts, of which I saved the links and took some notes that I
connected back to my existing notes, to get a large picture and the immediate usage and interesting parts of IPv6.</p>
<p>It was time to put it all in perspective.</p>
<h3 id="understanding-ipv6-in-relation-to-aws">Understanding IPv6 in relation to AWS<a hidden class="anchor" aria-hidden="true" href="#understanding-ipv6-in-relation-to-aws">#</a></h3>
<p>As always with AWS finding documentation which describes a feature in its completeness is near impossible. I found
various blog posts, some hints here and there and when you open the EKS console page, there is an announcement at the
top that they started supporting IPv6. That page contains some information about restrictions and requirements. But
nothing profound enough to know how to call some APIs or what to set up or how routing works exactly. Or what to pass to
the VPC. Or how to slice subnets not using eksctl and cloudformation.</p>
<p>Lucky for me, I had some prior knowledge in the area. I work at <a href="https://weave.works/">https://weave.works/</a>. And at <code>eksctl</code> a couple of
co-workers of mine already did some research and created some documentations that I was able to follow. But ultimately,
that was using a different approach because it&rsquo;s using CloudFormation. But the notes on security groups and VPCs was
invaluable.</p>
<p>The other guide which helped me was the <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-ug.pdf">VPC usage guide</a> and
the IPv6 section. And the EKS usage guide and how to migrate to IPv6 clusters. There were numerous restrictions which
helped me understand what I needed to create. I read these over 5-6 times.</p>
<p>From all of these, notes taken into my trusty notebook in which I gathered together all the relevant information that I
could connect to things I needed, I slowly put together an approach for CAPA.</p>
<p>I also had the benefit that I could compare my CAPA created network topology to that of an <code>eksctl</code> created cluster. I
could verify that the cluster created by CAPA had similar routings, VPCs and subnet configuration.</p>
<p>For example, a &ldquo;private&rdquo; ( there is no such thing as private in the land of IPv6 ( there are no private/local ips ) )
VPC configuration requires an Egress Only Internet Gateway for IPv6 clusters so network translation can still work.</p>
<p>The most difficult part though to discover was subnetting.</p>
<h4 id="the-journey-of-subnetting-ipv6">The journey of subnetting IPv6<a hidden class="anchor" aria-hidden="true" href="#the-journey-of-subnetting-ipv6">#</a></h4>
<p>My first approach was the mathematical one. I implemented code which would slice an IPv6 address into the needed number
of subnets based on AZs that looked like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">SplitIntoSubnetsIPv6</span>(<span style="color:#a6e22e">cidrBlock</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">numSubnets</span> <span style="color:#66d9ef">int</span>) ([]<span style="color:#f92672">*</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">IPNet</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">parent</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">ParseCIDR</span>(<span style="color:#a6e22e">cidrBlock</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">Wrap</span>(<span style="color:#a6e22e">err</span>, <span style="color:#e6db74">&#34;failed to parse CIDR&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">subnetBits</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Ceil</span>(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Log2</span>(float64(<span style="color:#a6e22e">numSubnets</span>)))
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">networkLen</span>, <span style="color:#a6e22e">addrLen</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">parent</span>.<span style="color:#a6e22e">Mask</span>.<span style="color:#a6e22e">Size</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">modifiedNetworkLen</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">networkLen</span> <span style="color:#f92672">+</span> int(<span style="color:#a6e22e">subnetBits</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">modifiedNetworkLen</span> &gt; <span style="color:#a6e22e">addrLen</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;cidr range %s cannot accommodate %d subnets&#34;</span>, <span style="color:#a6e22e">cidrBlock</span>, <span style="color:#a6e22e">numSubnets</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">addr</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">netaddr</span>.<span style="color:#a6e22e">ParseIPv6Net</span>(<span style="color:#a6e22e">cidrBlock</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">Wrapf</span>(<span style="color:#a6e22e">err</span>, <span style="color:#e6db74">&#34;failed to parse network address %s&#34;</span>, <span style="color:#a6e22e">cidrBlock</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">subnets</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">IPNet</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">numSubnets</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">subnetIP</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">addr</span>.<span style="color:#a6e22e">NthSubnet</span>(uint(<span style="color:#a6e22e">modifiedNetworkLen</span>), uint64(<span style="color:#a6e22e">i</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">subnetIP</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;exceeded the subnet space with len %d&#34;</span>, <span style="color:#a6e22e">modifiedNetworkLen</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">parsedSubnetIP</span>, <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">ParseCIDR</span>(<span style="color:#a6e22e">subnetIP</span>.<span style="color:#a6e22e">Long</span>())
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">IPNet</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">IP</span>:   <span style="color:#a6e22e">parsedSubnetIP</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">Mask</span>: <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">CIDRMask</span>(<span style="color:#a6e22e">modifiedNetworkLen</span>, <span style="color:#ae81ff">128</span>),
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">subnets</span> = append(<span style="color:#a6e22e">subnets</span>, <span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">subnets</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It&rsquo;s using a library to calculate the actual new IP based on <code>NthSubnet</code>. I did some bit shifting myself, but that turned
out to be not so error resilient and didn&rsquo;t handle some edge cases that the library already did.</p>
<p>However, this research all turned out to be mute once I re-read my notes and some of the docs and I internalized the point
that all subnets have a fixed prefix length of <code>64</code>. And further reading about subnet IDs in IPv6 and creating IPv6
clusters using the console it became apparent that subnets are super easy, barely an inconvenience.</p>
<p>See, it basically works like this. You get an IPv6 pool and an IPv6 address with a fixed prefix length of 56. You need to
switch that to 64 and just increase the subnet ID for any further subnets. This looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">SplitIntoSubnetsIPv6</span>(<span style="color:#a6e22e">cidrBlock</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">numSubnets</span> <span style="color:#66d9ef">int</span>) ([]<span style="color:#f92672">*</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">IPNet</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ipv6CidrBlock</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">ParseCIDR</span>(<span style="color:#a6e22e">cidrBlock</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;failed to parse cidr block %s with error: %w&#34;</span>, <span style="color:#a6e22e">cidrBlock</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// update the prefix to 64.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ipv6CidrBlock</span>.<span style="color:#a6e22e">Mask</span> = <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">CIDRMask</span>(<span style="color:#ae81ff">64</span>, <span style="color:#ae81ff">128</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">subnets</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">IPNet</span>
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">numSubnets</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ipv6CidrBlock</span>.<span style="color:#a6e22e">IP</span>[<span style="color:#a6e22e">subnetIDLocation</span>]<span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">newIP</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">ParseIP</span>(<span style="color:#a6e22e">ipv6CidrBlock</span>.<span style="color:#a6e22e">IP</span>.<span style="color:#a6e22e">String</span>())
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">IPNet</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">IP</span>:   <span style="color:#a6e22e">newIP</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">Mask</span>: <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">CIDRMask</span>(<span style="color:#ae81ff">64</span>, <span style="color:#ae81ff">128</span>),
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">subnets</span> = append(<span style="color:#a6e22e">subnets</span>, <span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">subnets</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Boom. And that&rsquo;s all there is to it! That&rsquo;s mostly what the CloudFormation is doing internally too.</p>
<h3 id="why-do-you-still-need-subnets">Why do you still need subnets?<a hidden class="anchor" aria-hidden="true" href="#why-do-you-still-need-subnets">#</a></h3>
<p>Once I gathered all resources that needed updates, it was time to write them down. Subnets and networking are obviously
the two big hitters. With IPv4 we needed the separation and a thing called <code>SecondaryCidrBlock</code> because you can easily
run out of ips. With IPv6 you don&rsquo;t need to worry about that. However, we do still need to subnet, because we want
resiliency through availability zones. Each AZ gets a subnet and an assigned IPv6 address.</p>
<h3 id="private-networking">Private networking<a hidden class="anchor" aria-hidden="true" href="#private-networking">#</a></h3>
<p>Another thing of the past is private networking. There no private addresses or local addresses for IPv6. All IPv6
addresses are public. Which means, we need another way of defining a private network. That is achieved through security
groups and routing. The routes will have a new resource called <code>EgressOnlyInternetGateway</code>. Which is basically what it
says. An IWG which works with IPv6 addresses, allows for outgoing communication through IPv6 but blocks all incoming
data through IPv6.</p>
<h2 id="implementation-time">Implementation Time<a hidden class="anchor" aria-hidden="true" href="#implementation-time">#</a></h2>
<p>Alright. With these things out of the way, it was time to get acquainted with the source code.</p>
<h3 id="approaching-an-unknown-codebase">Approaching an unknown codebase<a hidden class="anchor" aria-hidden="true" href="#approaching-an-unknown-codebase">#</a></h3>
<p>I had the a couple of things on my side.</p>
<ul>
<li>I had ample of experience with working with controllers in Kubernetes</li>
<li>I had personally wrote couple of projects which worked with AWS and the GO SDK</li>
<li>I had experience in working with AWS in general</li>
<li>I had one of the maintainers as a colleague working here at Weaveworks</li>
</ul>
<p>How did these things help me? Let&rsquo;s take a look.</p>
<p>The fact that I already worked with a lot of controllers makes me aware of a couple of things when working with such a
codebase. What are these?</p>
<ul>
<li>The API is versioned in a certain way like <code>alphav1</code> and <code>alphav2</code> and <code>betav1</code> and so on</li>
<li>Lots and LOTS of generated code</li>
<li>Controller lifecycle
<ul>
<li>What does this mean? This has a couple of baggages when you think about it. The code has a reconciliation loop
which takes care of creating, updating and deleting resources based on their state. But this also means that you
have to always consider existing infrastructure and objects in Kubernetes. And when deleting you always have to be
aware of finalizers.</li>
</ul>
</li>
<li>Unit testing and mocking calls and Kubernetes</li>
<li>Certain package structure and code constructs</li>
</ul>
<p>All these helped me massively to discover where things are and why. Richard ( the maintainer ) talked us through a general
flow and from there it was easier to go with the flow. And he was constantly available when I was stuck at a certain part
like conversions&hellip;</p>
<h3 id="analysing-the-code">Analysing the code<a hidden class="anchor" aria-hidden="true" href="#analysing-the-code">#</a></h3>
<p>When faced with the unknown you must find what you might no in relation. I already knew it creates a cluster and that
cluster has resources and log outputs. So&hellip; follow the flow. I started checking out the code and followed a <code>create</code>
code path. How a cluster is reconciled.</p>
<p>I started taking notes and write down which package and path did what. I started following <code>reconcileCluster</code>.
This is the main flow. It contained everything. I glanced over the sub flows of reconciling providers and security groups
and the likes, but I mainly kept with the main flow.</p>
<p>This limitation allowed me to focus on the most important bits. Where code lives, why and how it is configured.
Once I knew all of these things, I could focus on various sub-flows. Since my main focus was altering the network and
instance bits, I focused on <code>ReconcileNetwork</code> flow and Machines.</p>
<p>Again, same thing. Go over the main flow, follow the code path, see how things are set up where they live and why, but
don&rsquo;t go too deep. Once the main flow is understood, follow the sub-flow, like <code>reconcileVPC</code>.</p>
<h3 id="update-test-update-test">Update, test, update, test&hellip;<a hidden class="anchor" aria-hidden="true" href="#update-test-update-test">#</a></h3>
<p>Once I got a feel for things and noted down places where I probably will have to update something, I started updating
things incrementally. Small bits at a time. My first update, for example, was this trivial thing:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#75715e">// EnableIPv6 requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// the VPC. You cannot specify the range of IP addresses, or the size of the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// CIDR block.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// +optional
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">EnableIPv6</span> <span style="color:#66d9ef">bool</span> <span style="color:#e6db74">`json:&#34;enableIPv6&#34;`</span>
</span></span></code></pre></div><p>Basically I started updating the config types. It was a small, trivial thin to add but it got the ball rolling. Which
is the most important part of tackling a hard problem. When the codebase is daunting and you have no idea where to even
begin, a tiny update can make all the differences. It gets you started. It gives you an entry point.</p>
<p>I started adding more new settings and types and once I had all the settings I could think of, I started writing code
which actually used them. First, gradually. Things like these came in to picture:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">scope</span>.<span style="color:#a6e22e">VPC</span>().<span style="color:#a6e22e">EnableIPv6</span> = <span style="color:#a6e22e">vpc</span>.<span style="color:#a6e22e">EnableIPv6</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">scope</span>.<span style="color:#a6e22e">VPC</span>().<span style="color:#a6e22e">IPv6CidrBlock</span> = <span style="color:#a6e22e">vpc</span>.<span style="color:#a6e22e">IPv6CidrBlock</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">scope</span>.<span style="color:#a6e22e">VPC</span>().<span style="color:#a6e22e">IPv6Pool</span> = <span style="color:#a6e22e">vpc</span>.<span style="color:#a6e22e">IPv6Pool</span>
</span></span></code></pre></div><p>Just a trivial assignment. Then a tiny bit of logic&hellip;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">scope</span>.<span style="color:#a6e22e">VPC</span>().<span style="color:#a6e22e">EnableIPv6</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">infrav1</span>.<span style="color:#a6e22e">VPCSpec</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">ID</span>:        <span style="color:#f92672">*</span><span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">Vpc</span>.<span style="color:#a6e22e">VpcId</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">CidrBlock</span>: <span style="color:#f92672">*</span><span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">Vpc</span>.<span style="color:#a6e22e">CidrBlock</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">Tags</span>:      <span style="color:#a6e22e">converters</span>.<span style="color:#a6e22e">TagsToMap</span>(<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">Vpc</span>.<span style="color:#a6e22e">Tags</span>),
</span></span><span style="display:flex;"><span>		}, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>Deal with things that returned with normal flow. Here, the important part is that CIDR block is defined instead of
<code>IPv6CidrBlock</code>.</p>
<p>These small, incremental updates, eventually lead to this pr: <a href="https://github.com/kubernetes-sigs/cluster-api-provider-aws/pull/3513">PR</a>. As of this writing it needs some validations added
and an e2e test, but it&rsquo;s pretty much complete.</p>
<h2 id="testing">Testing<a hidden class="anchor" aria-hidden="true" href="#testing">#</a></h2>
<p>Tests are super important in a new codebase ( in an old one too, but that&rsquo;s a different story ). Reading the tests helps
me understand somewhat how the code is structured and what it does and why and what calls are expected to happen. What I
do is, that I fiddle with the code and start to run the unit tests and see what things fail. That gives me more
insight into how the thing I just changed works. This is invaluable when I&rsquo;m facing code which is difficult to decipher.</p>
<p>Write tests folks! I don&rsquo;t care if you use TDD or not, jut PLEASE write tests!</p>
<h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>If you made it this far, congratulations! You deserve a cookie. This has been my journey in understanding a fairly new
thing and implementing it into a largely unknown codebase. How I approached it and how I eventually ended up writing
around +2500 lines of code. You got some insight into how I take notes and how I figure out a larger problem in an
unknown environment. I hope it was a good read and worth your time.</p>
<p>Thank you for reading!</p>
<p>Gergely.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://skarlso.github.io/2022/07/01/how-to-contribute-to-a-new-repository/">
    <span class="title">« Prev</span>
    <br>
    <span>How to contribute to a new repository</span>
  </a>
  <a class="next" href="https://skarlso.github.io/2022/05/16/dependabot-bundler/">
    <span class="title">Next »</span>
    <br>
    <span>Dependabot Bundler</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://skarlso.github.io/">Ramblings of a cloud engineer</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
