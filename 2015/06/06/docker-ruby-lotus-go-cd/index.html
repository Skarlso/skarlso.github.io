<!DOCTYPE html>
<html lang="en-GB">
    <head>
    <meta charset="UTF-8" />

    <meta name="generator" content="Hugo 0.83.1" /><meta name="theme-color" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <meta name="format-detection" content="telephone=no, date=no, address=no, email=no" />
    
    <meta http-equiv="Cache-Control" content="no-transform" />
    
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <title>Docker &#43; Java &#43; Vagrant&#43; GO.CD | Ramblings of a cloud engineer</title>

    <link rel="stylesheet" href="/css/meme.min.css" />

    
    
        <script src="/js/meme.min.js"></script>

    

    

    <meta name="author" content="hannibal" /><meta name="description" content="Hello folks.
Today, I would like to write about something interesting and close to me at the moment. Iâ€™m going to setup Go.cd with Docker, and Iâ€™m going to get a Ruby Lotus app running. Letâ€™s get started.
" />

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="" />
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-title" content="Ramblings of a cloud engineer" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="application-name" content="Ramblings of a cloud engineer" />
    <meta name="msapplication-starturl" content="../../../../" />
    <meta name="msapplication-TileColor" content="" />
    <meta name="msapplication-TileImage" content="../../../../icons/mstile-150x150.png" />
    <link rel="manifest" href="/manifest.json" />

    
    

    
    <link rel="canonical" href="https://skarlso.github.io/2015/06/06/docker-ruby-lotus-go-cd/" />
    

    
    

    
    

    
</head>

    <body>
        <div class="container">
            



            
                
                
                
            
            
    <main class="main single" id="main">
    <div class="main-inner">

        

        <article class="content post h-entry" data-align="default" data-type="post">

            <h1 class="post-title p-name">Docker + Java + Vagrant+ GO.CD</h1>

            

            

            

            <div class="post-body e-content">
                <p>Hello folks.</p>
<p>Today, I would like to write about something interesting and close to me at the moment. Iâ€™m going to setup Go.cd with Docker, and Iâ€™m going to get a Ruby Lotus app running. Letâ€™s get started.</p>
<h1 id="fluff">Fluff</h1>
<p>Now, obviously, you donâ€™t really need Go.Cd or Docker to setup a Java Gradle application, since itâ€™s dead easy. But Iâ€™m going to do it just for the heck of it.</p>
<h1 id="setup">Setup</h1>
<p>Okay, lets start with Vagrant. Dockerâ€™s strength is coming from Linuxâ€™s process isolation capabilities itâ€™s not yet properly working on OSX or Windows. You have a couple of options if youâ€™d like to try never the less, like boot2docker, or a Tiny Linux kernel, but at that point, I think itâ€™s easier to use a VM.</p>
<h4 id="vagrant">Vagrant</h4>
<p>So, letâ€™s start with my small Vagrantfile.</p>
<!-- raw HTML omitted -->
<p>Very simple. Iâ€™m setting up a trusty64(because docker requires 3.10 &lt;= x)Â box and then doing a simple shell provision. Also, I gave it a bit juice, since go-server requires a raw power. Here is the shell script:</p>
<!-- raw HTML omitted -->
<p>The debconf at the end accepts java8â€™s terms and conditions. And the last line installs docker in my box. This runs for a little whileâ€¦</p>
<p>The routing on the end routes every traffic from 172.17.*.* to my vagrant box, which in turn Iâ€™ll be able to use from my mac local, like 127.0.0.1:8153/go/home.</p>
<p>After a vagrant up, my box is ready to be used.</p>
<h4 id="docker">Docker</h4>
<p>When thatâ€™s finished, we can move on to the next part, which is writing a little Dockerfile for our image. Go.cd will require java and a couple of other things, so letâ€™s automate the installation of that so we donâ€™t have to do itÂ by hand.</p>
<p>Here is a Dockerfile I came up with:</p>
<!-- raw HTML omitted -->
<p>So, our docker images have to be setup with Java as well for go.cd which Iâ€™m taking care of here, and a little bit extra, to add vim, and unzip, which is required for dpkg later.</p>
<p>At this point run: <strong>docker build -t ubuntu:go .</strong> -&gt; This will use the dockerfile and create the ubuntu:go image. Note theÂ **.Â **at the end.</p>
<h4 id="gocd">Go.cd</h4>
<p>Now, Iâ€™m creating two containers. One, go-server, will be the go server, and the other, go-agent, will be the go agent.</p>
<p>First, go-server:</p>
<!-- raw HTML omitted -->
<p>Pretty straight forward, no? We forward 8153 to vagrant (which forwards it to my mac), so after we start go-server service we should be able to visit: http://127.0.0.1:8153/go/home.</p>
<p>Loâ€™, and behold, go server. Letâ€™s add an agent too.</p>
<!-- raw HTML omitted -->
<p>No need to forward anything here. And as you can see, my agent was added successfully.</p>
<p>All nice, and dandy. The agent is there, and I enabled it, so itâ€™s ready to work. Letâ€™s give it something to do, shall we?</p>
<h1 id="the-app">The App</h1>
<p>Iâ€™m going to use my gradle project which is on github. This one =&gt;Â https://github.com/Skarlso/DataMung.git.</p>
<p>Very basic setup. Just check it out and then build &amp; run tests. Easy, right?</p>
<p>First step in this process, define the pipeline. Iâ€™m going to keep it simple. Name the pipeline DataMunger. Group is Linux. Now, in go.cd you have to define something called, an <strong>environment</strong>. Environment can be anything you want, Iâ€™m going to go with Linux. You have to assign <strong>agents</strong> to this environment who fulfil it and the pipeline which will use that environment. More on that you can read in the go.cd documentation. This is how you would handle a pipeline which uses linux, and a windows environment at the same time.</p>
<p>In step one you have to define something called the <strong>Material</strong>. That will be the source on which the agent will work. This can be multiple, in different folders within the confines of the pipeline, or singular.</p>
<p>I defined my git project and tested the connection OK. Next up is the firstÂ **StageÂ **and the initialÂ **JobÂ **to perform. This, for me, will be a compile or an assemble, and later on a test run.</p>
<p>Now, Go is awesome in parallelising jobs. If my project would be large enough, I could have multiple jobsÂ here. But for now,Â Iâ€™ll use stages because they run subsequently. So, first stage, compile. Next stage, testing and archiving the results.</p>
<p>I added the next stage and defined the artefact. Go supports test-reports. If you define the path to a test artefact than go will parse it and create a nice report out of it.</p>
<p>Now, letâ€™s run it. It will probably fail on something. ðŸ˜‰</p>
<p>Well, Iâ€™ll beâ€¦ It worked on the first run.</p>
<p>And here are the test results.</p>
<h1 id="wrap-up">Wrap-up</h1>
<p>Well, thatâ€™s it folks. Gradle project, with vagrant, docker, and go.cd. I hope you all enjoyed reading about it as much as I did doing it.</p>
<p>Any questions, please feel free to ask it in the comment section below.</p>
<p>Cheers,
Have a nice weekend,
Gergely.</p>
            </div>

            


        </article>

        

        


        


        


        


        


        


        


        


        


    </div>
</main>


            

            

        </div>
        

        















    </body>
</html>
