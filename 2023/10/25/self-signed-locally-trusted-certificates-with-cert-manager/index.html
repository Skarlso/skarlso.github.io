<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Self-Signed locally trusted certificates with cert-manager | Ramblings of a cloud engineer</title>
<meta name="keywords" content="">
<meta name="description" content="Self-Signed locally trusted certificates with cert-manager
We are going to discuss how to set up a Kubernetes environment where components can run using HTTPS without pain.
Premise
Usually, people either generate certificates outside the cluster using either openssl, or mkcert, then mount them in or
use those as seeds for further generation. This poses a number of problems during testing and distribution of these
certificates. And then, switching to production, it proves that local certs will either no longer work or pose even
more problems in getting them properly distributed again.">
<meta name="author" content="hannibal">
<link rel="canonical" href="https://skarlso.github.io/2023/10/25/self-signed-locally-trusted-certificates-with-cert-manager/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://skarlso.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://skarlso.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://skarlso.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://skarlso.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://skarlso.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://skarlso.github.io/2023/10/25/self-signed-locally-trusted-certificates-with-cert-manager/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Self-Signed locally trusted certificates with cert-manager">
<meta property="og:description" content="Self-Signed locally trusted certificates with cert-manager
We are going to discuss how to set up a Kubernetes environment where components can run using HTTPS without pain.
Premise
Usually, people either generate certificates outside the cluster using either openssl, or mkcert, then mount them in or
use those as seeds for further generation. This poses a number of problems during testing and distribution of these
certificates. And then, switching to production, it proves that local certs will either no longer work or pose even
more problems in getting them properly distributed again.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://skarlso.github.io/2023/10/25/self-signed-locally-trusted-certificates-with-cert-manager/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2023-10-25T01:01:00+01:00">
<meta property="article:modified_time" content="2023-10-25T01:01:00+01:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Self-Signed locally trusted certificates with cert-manager">
<meta name="twitter:description" content="Self-Signed locally trusted certificates with cert-manager
We are going to discuss how to set up a Kubernetes environment where components can run using HTTPS without pain.
Premise
Usually, people either generate certificates outside the cluster using either openssl, or mkcert, then mount them in or
use those as seeds for further generation. This poses a number of problems during testing and distribution of these
certificates. And then, switching to production, it proves that local certs will either no longer work or pose even
more problems in getting them properly distributed again.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://skarlso.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Self-Signed locally trusted certificates with cert-manager",
      "item": "https://skarlso.github.io/2023/10/25/self-signed-locally-trusted-certificates-with-cert-manager/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Self-Signed locally trusted certificates with cert-manager",
  "name": "Self-Signed locally trusted certificates with cert-manager",
  "description": "Self-Signed locally trusted certificates with cert-manager We are going to discuss how to set up a Kubernetes environment where components can run using HTTPS without pain.\nPremise Usually, people either generate certificates outside the cluster using either openssl, or mkcert, then mount them in or use those as seeds for further generation. This poses a number of problems during testing and distribution of these certificates. And then, switching to production, it proves that local certs will either no longer work or pose even more problems in getting them properly distributed again.\n",
  "keywords": [
    
  ],
  "articleBody": "Self-Signed locally trusted certificates with cert-manager We are going to discuss how to set up a Kubernetes environment where components can run using HTTPS without pain.\nPremise Usually, people either generate certificates outside the cluster using either openssl, or mkcert, then mount them in or use those as seeds for further generation. This poses a number of problems during testing and distribution of these certificates. And then, switching to production, it proves that local certs will either no longer work or pose even more problems in getting them properly distributed again.\nProposition Start with cert-manager from the begin. This will give the flexibility needed to move into production immediately, and the ability to set up a local testing environment quickly and efficiently. I will demonstrate how to achieve this with minimal pain and no interaction needed aside from a password confirm when starting the test. I will also show how to set all this up using a Github Action for e2e testing on CI environment.\nBreakdown First, let’s take a look at two deployments to demonstrate this set up. The first deployment we’ll be using is a plain docker registry. It requires some certs to be mounted in so it can run using HTTPS.\napiVersion: apps/v1 kind: Deployment metadata: name: registry spec: replicas: 1 selector: matchLabels: app: curl template: metadata: labels: app: registry spec: containers: - name: registry image: registry:2 ports: - containerPort: 5000 env: - name: REGISTRY_STORAGE_DELETE_ENABLED value: \"true\" - name: REGISTRY_HTTP_TLS_CERTIFICATE value: \"/certs/cert.pem\" - name: REGISTRY_HTTP_TLS_KEY value: \"/certs/key.pem\" - name: REGISTRY_HTTP_TLS_CLIENTCAS_0 value: \"/certs/ca.pem\" volumeMounts: - mountPath: \"/certs\" name: \"root-certs\" volumes: - name: registry emptyDir: {} - name: \"root-certs\" secret: secretName: \"root-certs\" items: - key: \"tls.crt\" path: \"cert.pem\" - key: \"tls.key\" path: \"key.pem\" - key: \"ca.crt\" path: \"ca.pem\" Nothing too fancy.\nThe second pod will be a plain ubuntu that runs a curl to this service to verify that it is indeed HTTPS.\napiVersion: apps/v1 kind: Deployment metadata: name: curl-test spec: replicas: 1 selector: matchLabels: app: curl template: metadata: labels: app: curl spec: containers: - name: curl-container image: curlimages/curl:latest command: [\"curl\", \"https://registry.default.svc.cluster.local:5000\"] Now, let’s assume that the registry already has the certificate, this deployment now would fail with something like this:\nkubectl logs \"$(kubectl get pods --template '{{range .items}}{{.metadata.name}}{{end}}' --selector=app=curl)\" % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0 curl: (60) SSL certificate problem: unable to get local issuer certificate More details here: https://curl.se/docs/sslcerts.html curl failed to verify the legitimacy of the server and therefore could not establish a secure connection to it. To learn more about this situation and how to fix it, please visit the web page mentioned above. Because the pod is lacking the root certificate for our registry. So far so good. Now, let’s see how we can make this work automatically.\nSetting up First, we need to configure cert-manager to create a root certificate for us. Now, cert-manager creates root certificates by the means of marking a certificate as a CA. This, sometimes, does not work well with certain browsers. For example, Firefox doesn’t like certificates that are also root CAs. I’m willing to accept this sacrifice in the test environment.\nTo prime cert-manager to generate a root certificate for us, all we need to apply this combo:\napiVersion: cert-manager.io/v1 kind: ClusterIssuer metadata: name: selfsigned-issuer spec: selfSigned: {} --- apiVersion: cert-manager.io/v1 kind: Certificate metadata: name: my-selfsigned-ca namespace: cert-manager spec: isCA: true commonName: my-selfsigned-ca # deprecated but still requires in iOS environment secretName: root-secret subject: # needed later for local trust store organizations: - example.com privateKey: algorithm: ECDSA size: 256 issuerRef: name: selfsigned-issuer kind: ClusterIssuer group: cert-manager.io --- apiVersion: cert-manager.io/v1 kind: ClusterIssuer metadata: name: my-ca-issuer spec: ca: secretName: root-secret We are going to start to put this into a setup script at this point. This script will work for us to prime a test cluster.\n#!/usr/bin/env bash # cleanup rm -fr rootCA.pem # install cert-manager with a specific version. CERT_MANAGER_VERSION=${CERT_MANAGER_VERSION:-v1.13.1} # if the manifest hasn't been downloaded yet, download it. if [ ! -e 'cert-manager.yaml' ]; then echo \"fetching cert-manager manifest for version ${CERT_MANAGER_VERSION}\" curl -L https://github.com/cert-manager/cert-manager/releases/download/${CERT_MANAGER_VERSION}/cert-manager.yaml -o cert-manager.yaml fi # create a test cluster -- use any configuration here for kind kind create cluster --name=e2e-test-cluster echo -n 'installing cert-manager' # apply the downloaded manifest then wait for all the deployments to become ready. kubectl apply -f cert-manager.yaml kubectl wait --for=condition=Available=True Deployment/cert-manager -n cert-manager --timeout=60s kubectl wait --for=condition=Available=True Deployment/cert-manager-webhook -n cert-manager --timeout=60s kubectl wait --for=condition=Available=True Deployment/cert-manager-cainjector -n cert-manager --timeout=60s echo 'done' # apply the cluster_issuer combination that was defined above this. echo -n 'applying root certificate issuer' kubectl apply -f cluster_issuer.yaml echo 'done' # wait for the certificate to be generated. echo -n 'waiting for root certificate to be generated...' kubectl wait --for=condition=Ready=true Certificate/mpas-bootstrap-certificate -n cert-manager --timeout=60s echo 'done' Now, when running our e2e test from a Makefile for example, we can easily use this script as a primer. Consider the following target for a Go project:\n.PHONY: e2e e2e: prime-test-cluster ## Runs e2e tests go test -count=1 -tags=e2e ./e2e .PHONY: prime-test-cluster prime-test-cluster: ./prime_test_cluster.sh Simple Makefile dependency so it primes the test cluster first, than executes our e2e tests.\nWe aren’t done yet. We do have a certificate root, but we don’t have a certificate. We could use the rootCA, but I would rather create a new certificate with the rootCA so each has its own access. To generate a new certificate we apply a Certificate:\napiVersion: cert-manager.io/v1 kind: Certificate metadata: name: curl-certs spec: secretName: curl-certs dnsNames: - registry.default.svc.cluster.local - localhost ipAddresses: - 127.0.0.1 - ::1 privateKey: algorithm: RSA encoding: PKCS8 size: 2048 issuerRef: name: my-ca-issuer kind: ClusterIssuer group: cert-manager.io With this, we have our certificate and we can mount it into our CURL deployment:\napiVersion: apps/v1 kind: Deployment metadata: name: curl-test spec: replicas: 1 selector: matchLabels: app: curl template: metadata: labels: app: curl spec: containers: - name: curl-container image: curlimages/curl:latest env: - name: CURL_CA_BUNDLE value: \"/etc/ssl/certs/registry-root.pem\" command: [\"curl\", \"https://registry.default.svc.cluster.local:5000\"] volumeMounts: - mountPath: \"/etc/ssl/certs/registry-root.pem\" subPath: \"registry-root.pem\" name: \"certificates\" volumes: - name: \"certificates\" secret: secretName: \"curl-certs\" items: - key: \"ca.crt\" path: \"registry-root.pem\" A small trick in case of this curl container we do here is using CURL_CA_BUNDLER env. But normally, running something like alpine, or the likes, you would install ca-certificate package. For gcr.io/distroless/static:nonroot this is not needed at all. The certificate will be loaded automatically after start.\nRunning this deployment now should result in a passing container:\ncurl-test-6589849f47-9f57h 1/1 Completed 0 4s This is all fine and good, however, what if you would like to have access to the container using https from localhost? Maybe you want to prime some test data, push some data into the registry and you don’t want to use insecure. There are a number of reasons to not use insecure. And we don’t want an if case in our code to detect if we are running in a test environment and inject stuff into our product code either.\nDon’t worry. mkcert got you covered.\nTrusting the certificate locally using mkcert What we get from priming this cluster is that we have access to the certificate that we bootstrapped. We can download and decode that rootCA and use mkcert to install it locally. We’ll put in some guards to make sure mkcert is installed and then run it in the prime script to install the download rootCA into the local trust stores.\nAltered Makefile:\n## Location to install dependencies to LOCALBIN ?= $(shell pwd)/bin $(LOCALBIN): mkdir -p $(LOCALBIN) MKCERT ?= $(LOCALBIN)/mkcert MKCERT_VERSION ?= v1.4.4 ## Make sure mkcert exists .PHONY: mkcert mkcert: $(MKCERT) $(MKCERT): $(LOCALBIN) curl -L \"https://github.com/FiloSottile/mkcert/releases/download/$(MKCERT_VERSION)/mkcert-$(MKCERT_VERSION)-$(UNAME)-amd64\" -o $(LOCALBIN)/mkcert chmod +x $(LOCALBIN)/mkcert .PHONY: e2e e2e: prime-test-cluster ## Runs e2e tests go test -count=1 -tags=e2e ./e2e .PHONY: prime-test-cluster prime-test-cluster: mkcert ## mkcert added as a dependency ./prime_test_cluster.sh Then we add a tiny bit at the end of our primer:\n#!/usr/bin/env bash # cleanup rm -fr rootCA.pem # install cert-manager with a specific version. CERT_MANAGER_VERSION=${CERT_MANAGER_VERSION:-v1.13.1} # if the manifest hasn't been downloaded yet, download it. if [ ! -e 'cert-manager.yaml' ]; then echo \"fetching cert-manager manifest for version ${CERT_MANAGER_VERSION}\" curl -L https://github.com/cert-manager/cert-manager/releases/download/${CERT_MANAGER_VERSION}/cert-manager.yaml -o cert-manager.yaml fi # create a test cluster -- use any configuration here for kind kind create cluster --name=e2e-test-cluster echo -n 'installing cert-manager' # apply the downloaded manifest then wait for all the deployments to become ready. kubectl apply -f cert-manager.yaml kubectl wait --for=condition=Available=True Deployment/cert-manager -n cert-manager --timeout=60s kubectl wait --for=condition=Available=True Deployment/cert-manager-webhook -n cert-manager --timeout=60s kubectl wait --for=condition=Available=True Deployment/cert-manager-cainjector -n cert-manager --timeout=60s echo 'done' # apply the cluster_issuer combination that was defined above this. echo -n 'applying root certificate issuer' kubectl apply -f cluster_issuer.yaml echo 'done' # wait for the certificate to be generated. echo -n 'waiting for root certificate to be generated...' kubectl wait --for=condition=Ready=true Certificate/mpas-bootstrap-certificate -n cert-manager --timeout=60s echo 'done' #### New segment from here #### # download the certificate and decode it using base64. kubectl get secret ocm-registry-tls-certs -n cert-manager -o jsonpath=\"{.data['tls\\.crt']}\" | base64 -d \u003e rootCA.pem echo -n 'installing root certificate into local trust store...' CAROOT=. ./bin/mkcert -install rootCAPath=\"./rootCA.pem\" # if the local environment as a ca-certificates store, append our certificate to it. This will come in handy later # when using a github action to set this all up. if [ -e '/etc/ssl/certs/ca-certificates.crt' ]; then echo \"updating root certificate\" sudo cat \"${rootCAPath}\" | sudo tee -a /etc/ssl/certs/ca-certificates.crt || echo \"failed to append to ca-certificates. Ignoring the failure\" fi echo 'done' And this is it. Running this script will prompt the user for a root password so mkcert can install the downloaded rootCA. The name is important here rootCA.pem. This is the name mkcert expects to find when running -install.\nGithub Action All that remains now is to put this all together so it can run in a github action:\nname: e2e on: pull_request: paths-ignore: - 'CODE_OF_CONDUCT.md' - 'README.md' - 'Contributing.md' branches: - main permissions: contents: read # for actions/checkout to fetch code jobs: run-e2e-suite: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Setup Go uses: actions/setup-go@v4 with: go-version-file: '${{ github.workspace }}/go.mod' - name: Restore Go cache uses: actions/cache@v3 with: path: /home/runner/work/_temp/_github_home/go/pkg/mod key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }} restore-keys: | ${{ runner.os }}-go- - name: Setup Kubernetes uses: helm/kind-action@v1.5.0 with: install_only: true - name: Run E2E tests id: e2e-tests run: make e2e-verbose That’s it! Because of our little hack at the end of our script in prime, it will update the ca-certificate with the root certificate on an Ubuntu environment. If you are running a different environment, you might have to put this root ca elsewhere. That depends on your configuration.\nConclusion We’ve seen how to use cert-manager to easily generate a root certificate in cluster. This will alieviate the point of having to:\nlocally generate them create secret(s) for them rotate certificates when they expire deal with switching code between development and prod environments using insecure We are now using cert-manager which is an industry standard for generating certificates. This setup will also make it a lot easier to switch to a prod environment since we already installed cert-manager and we already have a means of mounting and distributing certificates amongst pods that need them.\n",
  "wordCount" : "1853",
  "inLanguage": "en",
  "datePublished": "2023-10-25T01:01:00+01:00",
  "dateModified": "2023-10-25T01:01:00+01:00",
  "author":{
    "@type": "Person",
    "name": "hannibal"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://skarlso.github.io/2023/10/25/self-signed-locally-trusted-certificates-with-cert-manager/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ramblings of a cloud engineer",
    "logo": {
      "@type": "ImageObject",
      "url": "https://skarlso.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://skarlso.github.io/" accesskey="h" title="Ramblings of a cloud engineer (Alt + H)">Ramblings of a cloud engineer</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://skarlso.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/search/" title="Search">
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://skarlso.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://skarlso.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Self-Signed locally trusted certificates with cert-manager
    </h1>
    <div class="post-meta"><span title='2023-10-25 01:01:00 +0100 +0100'>October 25, 2023</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;hannibal

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#self-signed-locally-trusted-certificates-with-cert-manager" aria-label="Self-Signed locally trusted certificates with cert-manager">Self-Signed locally trusted certificates with cert-manager</a><ul>
                        
                <li>
                    <a href="#premise" aria-label="Premise">Premise</a></li>
                <li>
                    <a href="#proposition" aria-label="Proposition">Proposition</a></li>
                <li>
                    <a href="#breakdown" aria-label="Breakdown">Breakdown</a><ul>
                        
                <li>
                    <a href="#setting-up" aria-label="Setting up">Setting up</a></li>
                <li>
                    <a href="#trusting-the-certificate-locally-using-mkcert" aria-label="Trusting the certificate locally using mkcert">Trusting the certificate locally using mkcert</a></li></ul>
                </li>
                <li>
                    <a href="#github-action" aria-label="Github Action">Github Action</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="self-signed-locally-trusted-certificates-with-cert-manager">Self-Signed locally trusted certificates with cert-manager<a hidden class="anchor" aria-hidden="true" href="#self-signed-locally-trusted-certificates-with-cert-manager">#</a></h1>
<p>We are going to discuss how to set up a Kubernetes environment where components can run using HTTPS without pain.</p>
<h2 id="premise">Premise<a hidden class="anchor" aria-hidden="true" href="#premise">#</a></h2>
<p>Usually, people either generate certificates outside the cluster using either openssl, or mkcert, then mount them in or
use those as seeds for further generation. This poses a number of problems during testing and distribution of these
certificates. And then, switching to production, it proves that local certs will either no longer work or pose even
more problems in getting them properly distributed again.</p>
<h2 id="proposition">Proposition<a hidden class="anchor" aria-hidden="true" href="#proposition">#</a></h2>
<p>Start with cert-manager from the begin. This will give the flexibility needed to move into production immediately, and
the ability to set up a local testing environment quickly and efficiently. I will demonstrate how to achieve this with
minimal pain and no interaction needed aside from a password confirm when starting the test. I will also show how to set
all this up using a Github Action for e2e testing on CI environment.</p>
<h2 id="breakdown">Breakdown<a hidden class="anchor" aria-hidden="true" href="#breakdown">#</a></h2>
<p>First, let&rsquo;s take a look at two deployments to demonstrate this set up. The first deployment we&rsquo;ll be using is a plain
docker registry. It requires some certs to be mounted in so it can run using HTTPS.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">apps/v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Deployment</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">registry</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">matchLabels</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">app</span>: <span style="color:#ae81ff">curl</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">template</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">app</span>: <span style="color:#ae81ff">registry</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">registry</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">image</span>: <span style="color:#ae81ff">registry:2</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>            - <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">5000</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">env</span>:
</span></span><span style="display:flex;"><span>            - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">REGISTRY_STORAGE_DELETE_ENABLED</span>
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">value</span>: <span style="color:#e6db74">&#34;true&#34;</span>
</span></span><span style="display:flex;"><span>            - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">REGISTRY_HTTP_TLS_CERTIFICATE</span>
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">value</span>: <span style="color:#e6db74">&#34;/certs/cert.pem&#34;</span>
</span></span><span style="display:flex;"><span>            - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">REGISTRY_HTTP_TLS_KEY</span>
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">value</span>: <span style="color:#e6db74">&#34;/certs/key.pem&#34;</span>
</span></span><span style="display:flex;"><span>            - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">REGISTRY_HTTP_TLS_CLIENTCAS_0</span>
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">value</span>: <span style="color:#e6db74">&#34;/certs/ca.pem&#34;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">volumeMounts</span>:
</span></span><span style="display:flex;"><span>            - <span style="color:#f92672">mountPath</span>: <span style="color:#e6db74">&#34;/certs&#34;</span>
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">name</span>: <span style="color:#e6db74">&#34;root-certs&#34;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">volumes</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">registry</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">emptyDir</span>: {}
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">name</span>: <span style="color:#e6db74">&#34;root-certs&#34;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">secret</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">secretName</span>: <span style="color:#e6db74">&#34;root-certs&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">items</span>:
</span></span><span style="display:flex;"><span>              - <span style="color:#f92672">key</span>: <span style="color:#e6db74">&#34;tls.crt&#34;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">path</span>: <span style="color:#e6db74">&#34;cert.pem&#34;</span>
</span></span><span style="display:flex;"><span>              - <span style="color:#f92672">key</span>: <span style="color:#e6db74">&#34;tls.key&#34;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">path</span>: <span style="color:#e6db74">&#34;key.pem&#34;</span>
</span></span><span style="display:flex;"><span>              - <span style="color:#f92672">key</span>: <span style="color:#e6db74">&#34;ca.crt&#34;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">path</span>: <span style="color:#e6db74">&#34;ca.pem&#34;</span>
</span></span></code></pre></div><p>Nothing too fancy.</p>
<p>The second pod will be a plain ubuntu that runs a curl to this service to verify that it is indeed HTTPS.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">apps/v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Deployment</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">curl-test</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">matchLabels</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">app</span>: <span style="color:#ae81ff">curl</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">template</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">app</span>: <span style="color:#ae81ff">curl</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">curl-container</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">image</span>: <span style="color:#ae81ff">curlimages/curl:latest</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">command</span>: [<span style="color:#e6db74">&#34;curl&#34;</span>, <span style="color:#e6db74">&#34;https://registry.default.svc.cluster.local:5000&#34;</span>]
</span></span></code></pre></div><p>Now, let&rsquo;s assume that the registry already has the certificate, this deployment now would fail with something like this:</p>
<pre tabindex="0"><code>kubectl logs &#34;$(kubectl get pods --template &#39;{{range .items}}{{.metadata.name}}{{end}}&#39; --selector=app=curl)&#34;
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
curl: (60) SSL certificate problem: unable to get local issuer certificate
More details here: https://curl.se/docs/sslcerts.html

curl failed to verify the legitimacy of the server and therefore could not
establish a secure connection to it. To learn more about this situation and
how to fix it, please visit the web page mentioned above.
</code></pre><p>Because the pod is lacking the root certificate for our registry. So far so good. Now, let&rsquo;s see how we can make this
work automatically.</p>
<h3 id="setting-up">Setting up<a hidden class="anchor" aria-hidden="true" href="#setting-up">#</a></h3>
<p>First, we need to configure cert-manager to create a root certificate for us. Now, cert-manager creates root certificates
by the means of marking a certificate as a CA. This, sometimes, does not work well with certain browsers. For example,
Firefox doesn&rsquo;t like certificates that are also root CAs. I&rsquo;m willing to accept this sacrifice in the test environment.</p>
<p>To prime cert-manager to generate a root certificate for us, all we need to apply this combo:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">cert-manager.io/v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">ClusterIssuer</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">selfsigned-issuer</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">selfSigned</span>: {}
</span></span><span style="display:flex;"><span>---
</span></span><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">cert-manager.io/v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Certificate</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-selfsigned-ca</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">cert-manager</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">isCA</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">commonName</span>: <span style="color:#ae81ff">my-selfsigned-ca</span> <span style="color:#75715e"># deprecated but still requires in iOS environment</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">secretName</span>: <span style="color:#ae81ff">root-secret</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">subject</span>: <span style="color:#75715e"># needed later for local trust store</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">organizations</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">example.com</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">privateKey</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">algorithm</span>: <span style="color:#ae81ff">ECDSA</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">size</span>: <span style="color:#ae81ff">256</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">issuerRef</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">selfsigned-issuer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">kind</span>: <span style="color:#ae81ff">ClusterIssuer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">group</span>: <span style="color:#ae81ff">cert-manager.io</span>
</span></span><span style="display:flex;"><span>---
</span></span><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">cert-manager.io/v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">ClusterIssuer</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-ca-issuer</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ca</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">secretName</span>: <span style="color:#ae81ff">root-secret</span>
</span></span></code></pre></div><p>We are going to start to put this into a setup script at this point. This script will work for us to prime a test
cluster.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env bash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># cleanup</span>
</span></span><span style="display:flex;"><span>rm -fr rootCA.pem
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># install cert-manager with a specific version.</span>
</span></span><span style="display:flex;"><span>CERT_MANAGER_VERSION<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>CERT_MANAGER_VERSION<span style="color:#66d9ef">:-</span>v1.13.1<span style="color:#e6db74">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># if the manifest hasn&#39;t been downloaded yet, download it.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> ! -e <span style="color:#e6db74">&#39;cert-manager.yaml&#39;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>  echo <span style="color:#e6db74">&#34;fetching cert-manager manifest for version </span><span style="color:#e6db74">${</span>CERT_MANAGER_VERSION<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>  curl -L https://github.com/cert-manager/cert-manager/releases/download/<span style="color:#e6db74">${</span>CERT_MANAGER_VERSION<span style="color:#e6db74">}</span>/cert-manager.yaml -o cert-manager.yaml
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># create a test cluster -- use any configuration here for kind</span>
</span></span><span style="display:flex;"><span>kind create cluster --name<span style="color:#f92672">=</span>e2e-test-cluster
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo -n <span style="color:#e6db74">&#39;installing cert-manager&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># apply the downloaded manifest then wait for all the deployments to become ready.</span>
</span></span><span style="display:flex;"><span>kubectl apply -f cert-manager.yaml
</span></span><span style="display:flex;"><span>kubectl wait --for<span style="color:#f92672">=</span>condition<span style="color:#f92672">=</span>Available<span style="color:#f92672">=</span>True Deployment/cert-manager -n cert-manager --timeout<span style="color:#f92672">=</span>60s
</span></span><span style="display:flex;"><span>kubectl wait --for<span style="color:#f92672">=</span>condition<span style="color:#f92672">=</span>Available<span style="color:#f92672">=</span>True Deployment/cert-manager-webhook -n cert-manager --timeout<span style="color:#f92672">=</span>60s
</span></span><span style="display:flex;"><span>kubectl wait --for<span style="color:#f92672">=</span>condition<span style="color:#f92672">=</span>Available<span style="color:#f92672">=</span>True Deployment/cert-manager-cainjector -n cert-manager --timeout<span style="color:#f92672">=</span>60s
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;done&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># apply the cluster_issuer combination that was defined above this.</span>
</span></span><span style="display:flex;"><span>echo -n <span style="color:#e6db74">&#39;applying root certificate issuer&#39;</span>
</span></span><span style="display:flex;"><span>kubectl apply -f cluster_issuer.yaml
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;done&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># wait for the certificate to be generated.</span>
</span></span><span style="display:flex;"><span>echo -n <span style="color:#e6db74">&#39;waiting for root certificate to be generated...&#39;</span>
</span></span><span style="display:flex;"><span>kubectl wait --for<span style="color:#f92672">=</span>condition<span style="color:#f92672">=</span>Ready<span style="color:#f92672">=</span>true Certificate/mpas-bootstrap-certificate -n cert-manager --timeout<span style="color:#f92672">=</span>60s
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;done&#39;</span>
</span></span></code></pre></div><p>Now, when running our e2e test from a Makefile for example, we can easily use this script as a primer. Consider the
following target for a Go project:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Makefile" data-lang="Makefile"><span style="display:flex;"><span><span style="color:#a6e22e">.PHONY</span><span style="color:#f92672">:</span> e2e
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">e2e</span><span style="color:#f92672">:</span> prime-test-cluster <span style="color:#75715e">## Runs e2e tests
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	go test -count<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> -tags<span style="color:#f92672">=</span>e2e ./e2e
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">.PHONY</span><span style="color:#f92672">:</span> prime-test-cluster
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">prime-test-cluster</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	./prime_test_cluster.sh
</span></span></code></pre></div><p>Simple Makefile dependency so it primes the test cluster first, than executes our e2e tests.</p>
<p>We aren&rsquo;t done yet. We do have a certificate root, but we don&rsquo;t have a certificate. We could use the rootCA, but I
would rather create a new certificate with the rootCA so each has its own access. To generate a new certificate we apply
a <code>Certificate</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">cert-manager.io/v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Certificate</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">curl-certs</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">secretName</span>: <span style="color:#ae81ff">curl-certs</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">dnsNames</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#ae81ff">registry.default.svc.cluster.local</span>
</span></span><span style="display:flex;"><span>    - <span style="color:#ae81ff">localhost</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ipAddresses</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#ae81ff">127.0.0.1</span>
</span></span><span style="display:flex;"><span>    - ::<span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">privateKey</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">algorithm</span>: <span style="color:#ae81ff">RSA</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">encoding</span>: <span style="color:#ae81ff">PKCS8</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">size</span>: <span style="color:#ae81ff">2048</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">issuerRef</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-ca-issuer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">kind</span>: <span style="color:#ae81ff">ClusterIssuer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">group</span>: <span style="color:#ae81ff">cert-manager.io</span>
</span></span></code></pre></div><p>With this, we have our certificate and we can mount it into our CURL deployment:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">apps/v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Deployment</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">curl-test</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">matchLabels</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">app</span>: <span style="color:#ae81ff">curl</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">template</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">app</span>: <span style="color:#ae81ff">curl</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">curl-container</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">image</span>: <span style="color:#ae81ff">curlimages/curl:latest</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">env</span>:
</span></span><span style="display:flex;"><span>          - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">CURL_CA_BUNDLE</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">value</span>: <span style="color:#e6db74">&#34;/etc/ssl/certs/registry-root.pem&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">command</span>: [<span style="color:#e6db74">&#34;curl&#34;</span>, <span style="color:#e6db74">&#34;https://registry.default.svc.cluster.local:5000&#34;</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">volumeMounts</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">mountPath</span>: <span style="color:#e6db74">&#34;/etc/ssl/certs/registry-root.pem&#34;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">subPath</span>: <span style="color:#e6db74">&#34;registry-root.pem&#34;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">name</span>: <span style="color:#e6db74">&#34;certificates&#34;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">volumes</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#e6db74">&#34;certificates&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">secret</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">secretName</span>: <span style="color:#e6db74">&#34;curl-certs&#34;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">items</span>:
</span></span><span style="display:flex;"><span>            - <span style="color:#f92672">key</span>: <span style="color:#e6db74">&#34;ca.crt&#34;</span>
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">path</span>: <span style="color:#e6db74">&#34;registry-root.pem&#34;</span>
</span></span></code></pre></div><p>A small trick in case of this curl container we do here is using <code>CURL_CA_BUNDLER</code> env. But normally, running something
like alpine, or the likes, you would install <code>ca-certificate</code> package. For <code>gcr.io/distroless/static:nonroot</code> this is
not needed at all. The certificate will be loaded automatically after start.</p>
<p>Running this deployment now should result in a passing container:</p>
<pre tabindex="0"><code>curl-test-6589849f47-9f57h                               1/1     Completed          0                4s
</code></pre><p>This is all fine and good, however, what if you would like to have access to the container using https from localhost?
Maybe you want to prime some test data, push some data into the registry and you don&rsquo;t want to use <code>insecure</code>. There
are a number of reasons to not use insecure. And we don&rsquo;t want an if case in our code to detect if we are running in a
test environment and inject stuff into our product code either.</p>
<p>Don&rsquo;t worry. <a href="https://github.com/FiloSottile/mkcert">mkcert</a> got you covered.</p>
<h3 id="trusting-the-certificate-locally-using-mkcert">Trusting the certificate locally using mkcert<a hidden class="anchor" aria-hidden="true" href="#trusting-the-certificate-locally-using-mkcert">#</a></h3>
<p>What we get from priming this cluster is that we have access to the certificate that we bootstrapped. We can download
and decode that rootCA and use <code>mkcert</code> to install it locally. We&rsquo;ll put in some guards to make sure mkcert is installed
and then run it in the prime script to install the download rootCA into the local trust stores.</p>
<p>Altered Makefile:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Makefile" data-lang="Makefile"><span style="display:flex;"><span><span style="color:#75715e">## Location to install dependencies to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LOCALBIN <span style="color:#f92672">?=</span> <span style="color:#66d9ef">$(</span>shell pwd<span style="color:#66d9ef">)</span>/bin
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">$(LOCALBIN)</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	mkdir -p <span style="color:#66d9ef">$(</span>LOCALBIN<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>MKCERT <span style="color:#f92672">?=</span> <span style="color:#66d9ef">$(</span>LOCALBIN<span style="color:#66d9ef">)</span>/mkcert
</span></span><span style="display:flex;"><span>MKCERT_VERSION <span style="color:#f92672">?=</span> v1.4.4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## Make sure mkcert exists
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">.PHONY</span><span style="color:#f92672">:</span> mkcert
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mkcert</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">$(</span>MKCERT<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">$(MKCERT)</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">$(</span>LOCALBIN<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>	curl -L <span style="color:#e6db74">&#34;https://github.com/FiloSottile/mkcert/releases/download/</span><span style="color:#66d9ef">$(</span>MKCERT_VERSION<span style="color:#66d9ef">)</span><span style="color:#e6db74">/mkcert-</span><span style="color:#66d9ef">$(</span>MKCERT_VERSION<span style="color:#66d9ef">)</span><span style="color:#e6db74">-</span><span style="color:#66d9ef">$(</span>UNAME<span style="color:#66d9ef">)</span><span style="color:#e6db74">-amd64&#34;</span> -o <span style="color:#66d9ef">$(</span>LOCALBIN<span style="color:#66d9ef">)</span>/mkcert
</span></span><span style="display:flex;"><span>	chmod +x <span style="color:#66d9ef">$(</span>LOCALBIN<span style="color:#66d9ef">)</span>/mkcert
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">.PHONY</span><span style="color:#f92672">:</span> e2e
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">e2e</span><span style="color:#f92672">:</span> prime-test-cluster <span style="color:#75715e">## Runs e2e tests
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	go test -count<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> -tags<span style="color:#f92672">=</span>e2e ./e2e
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">.PHONY</span><span style="color:#f92672">:</span> prime-test-cluster
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">prime-test-cluster</span><span style="color:#f92672">:</span> mkcert <span style="color:#75715e">## mkcert added as a dependency
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	./prime_test_cluster.sh
</span></span></code></pre></div><p>Then we add a tiny bit at the end of our primer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env bash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># cleanup</span>
</span></span><span style="display:flex;"><span>rm -fr rootCA.pem
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># install cert-manager with a specific version.</span>
</span></span><span style="display:flex;"><span>CERT_MANAGER_VERSION<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>CERT_MANAGER_VERSION<span style="color:#66d9ef">:-</span>v1.13.1<span style="color:#e6db74">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># if the manifest hasn&#39;t been downloaded yet, download it.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> ! -e <span style="color:#e6db74">&#39;cert-manager.yaml&#39;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>  echo <span style="color:#e6db74">&#34;fetching cert-manager manifest for version </span><span style="color:#e6db74">${</span>CERT_MANAGER_VERSION<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>  curl -L https://github.com/cert-manager/cert-manager/releases/download/<span style="color:#e6db74">${</span>CERT_MANAGER_VERSION<span style="color:#e6db74">}</span>/cert-manager.yaml -o cert-manager.yaml
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># create a test cluster -- use any configuration here for kind</span>
</span></span><span style="display:flex;"><span>kind create cluster --name<span style="color:#f92672">=</span>e2e-test-cluster
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo -n <span style="color:#e6db74">&#39;installing cert-manager&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># apply the downloaded manifest then wait for all the deployments to become ready.</span>
</span></span><span style="display:flex;"><span>kubectl apply -f cert-manager.yaml
</span></span><span style="display:flex;"><span>kubectl wait --for<span style="color:#f92672">=</span>condition<span style="color:#f92672">=</span>Available<span style="color:#f92672">=</span>True Deployment/cert-manager -n cert-manager --timeout<span style="color:#f92672">=</span>60s
</span></span><span style="display:flex;"><span>kubectl wait --for<span style="color:#f92672">=</span>condition<span style="color:#f92672">=</span>Available<span style="color:#f92672">=</span>True Deployment/cert-manager-webhook -n cert-manager --timeout<span style="color:#f92672">=</span>60s
</span></span><span style="display:flex;"><span>kubectl wait --for<span style="color:#f92672">=</span>condition<span style="color:#f92672">=</span>Available<span style="color:#f92672">=</span>True Deployment/cert-manager-cainjector -n cert-manager --timeout<span style="color:#f92672">=</span>60s
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;done&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># apply the cluster_issuer combination that was defined above this.</span>
</span></span><span style="display:flex;"><span>echo -n <span style="color:#e6db74">&#39;applying root certificate issuer&#39;</span>
</span></span><span style="display:flex;"><span>kubectl apply -f cluster_issuer.yaml
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;done&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># wait for the certificate to be generated.</span>
</span></span><span style="display:flex;"><span>echo -n <span style="color:#e6db74">&#39;waiting for root certificate to be generated...&#39;</span>
</span></span><span style="display:flex;"><span>kubectl wait --for<span style="color:#f92672">=</span>condition<span style="color:#f92672">=</span>Ready<span style="color:#f92672">=</span>true Certificate/mpas-bootstrap-certificate -n cert-manager --timeout<span style="color:#f92672">=</span>60s
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;done&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#### New segment from here ####</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># download the certificate and decode it using base64.</span>
</span></span><span style="display:flex;"><span>kubectl get secret ocm-registry-tls-certs -n cert-manager -o jsonpath<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;{.data[&#39;tls\.crt&#39;]}&#34;</span> | base64 -d &gt; rootCA.pem
</span></span><span style="display:flex;"><span>echo -n <span style="color:#e6db74">&#39;installing root certificate into local trust store...&#39;</span>
</span></span><span style="display:flex;"><span>CAROOT<span style="color:#f92672">=</span>. ./bin/mkcert -install
</span></span><span style="display:flex;"><span>rootCAPath<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;./rootCA.pem&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># if the local environment as a ca-certificates store, append our certificate to it. This will come in handy later</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># when using a github action to set this all up.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -e <span style="color:#e6db74">&#39;/etc/ssl/certs/ca-certificates.crt&#39;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>  echo <span style="color:#e6db74">&#34;updating root certificate&#34;</span>
</span></span><span style="display:flex;"><span>  sudo cat <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>rootCAPath<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span> | sudo tee -a /etc/ssl/certs/ca-certificates.crt <span style="color:#f92672">||</span> echo <span style="color:#e6db74">&#34;failed to append to ca-certificates. Ignoring the failure&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;done&#39;</span>
</span></span></code></pre></div><p>And this is it. Running this script will prompt the user for a root password so mkcert can install the downloaded rootCA.
The name is important here <code>rootCA.pem</code>. This is the name mkcert expects to find when running <code>-install</code>.</p>
<h2 id="github-action">Github Action<a hidden class="anchor" aria-hidden="true" href="#github-action">#</a></h2>
<p>All that remains now is to put this all together so it can run in a github action:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">name</span>: <span style="color:#ae81ff">e2e</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">on</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">pull_request</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">paths-ignore</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#e6db74">&#39;CODE_OF_CONDUCT.md&#39;</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#e6db74">&#39;README.md&#39;</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#e6db74">&#39;Contributing.md&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">branches</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">permissions</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">contents</span>: <span style="color:#ae81ff">read</span> <span style="color:#75715e"># for actions/checkout to fetch code</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">jobs</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">run-e2e-suite</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">runs-on</span>: <span style="color:#ae81ff">ubuntu-latest</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">steps</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Checkout</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/checkout@v4</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Setup Go</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/setup-go@v4</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">go-version-file</span>: <span style="color:#e6db74">&#39;${{ github.workspace }}/go.mod&#39;</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Restore Go cache</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/cache@v3</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/home/runner/work/_temp/_github_home/go/pkg/mod</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">key</span>: <span style="color:#ae81ff">${{ runner.os }}-go-${{ hashFiles(&#39;**/go.sum&#39;) }}</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">restore-keys</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ${{ runner.os }}-go-</span>            
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Setup Kubernetes</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">helm/kind-action@v1.5.0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">install_only</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Run E2E tests</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">id</span>: <span style="color:#ae81ff">e2e-tests</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">run</span>: <span style="color:#ae81ff">make e2e-verbose</span>
</span></span></code></pre></div><p>That&rsquo;s it! Because of our little hack at the end of our script in prime, it will update the ca-certificate with the root
certificate on an Ubuntu environment. If you are running a different environment, you might have to put this root ca
elsewhere. That depends on your configuration.</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>We&rsquo;ve seen how to use cert-manager to easily generate a root certificate in cluster. This will alieviate the point of
having to:</p>
<ul>
<li>locally generate them</li>
<li>create secret(s) for them</li>
<li>rotate certificates when they expire</li>
<li>deal with switching code between development and prod environments</li>
<li>using insecure</li>
</ul>
<p>We are now using cert-manager which is an industry standard for generating certificates. This setup will also make it a
lot easier to switch to a prod environment since we already installed cert-manager and we already have a means of
mounting and distributing certificates amongst pods that need them.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://skarlso.github.io/2023/12/01/crd-to-yaml-as-wasm-website/">
    <span class="title">« Prev</span>
    <br>
    <span>CRD to YAML as WASM website</span>
  </a>
  <a class="next" href="https://skarlso.github.io/2023/08/11/diff-check/">
    <span class="title">Next »</span>
    <br>
    <span>Diff check and Manifest generation in GitHub Actions</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://skarlso.github.io/">Ramblings of a cloud engineer</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
