<!DOCTYPE html>
<html lang="en-us">
    <head>
    <meta charset="UTF-8" />

    <meta name="generator" content="Hugo 0.83.1" /><meta name="theme-color" content="#494f5c" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <meta name="format-detection" content="telephone=no, date=no, address=no, email=no" />
    
    <meta http-equiv="Cache-Control" content="no-transform" />
    
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <title>Byte arrays and Channels | Ramblings of a cloud engineer</title>

    <link rel="stylesheet" href="/css/meme.min.css" />

    
    
        <script src="/js/meme.min.js"></script>

    

    

    <meta name="author" content="hannibal" /><meta name="description" content="Hi folks and a Happy new Year!
Today, I would like to show you some interesting things you can do with channels. Consider the following simple example.
package main import &#34;fmt&#34; func main() { generatedPassword := make(chan int, 100) correctPassword := make(chan int) defer close(generatedPassword) defer close(correctPassword) go passwordIncrement(generatedPassword) go checkPassword(generatedPassword, correctPassword) pass := &lt;-correctPassword fmt.Println(pass) } func checkPassword(input &lt;-chan int, output chan&lt;- int) { for { p := &lt;-input //Introduce lengthy operation here 	// time." />

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="" />
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-title" content="Ramblings of a cloud engineer" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="application-name" content="Ramblings of a cloud engineer" />
    <meta name="msapplication-starturl" content="../../../../" />
    <meta name="msapplication-TileColor" content="" />
    <meta name="msapplication-TileImage" content="../../../../icons/mstile-150x150.png" />
    <link rel="manifest" href="/manifest.json" />

    
    

    
    <link rel="canonical" href="https://skarlso.github.io/2016/01/01/byte-arrays-and-channels/" />
    

    
    

    
    

    
</head>

    <body>
        <div class="container">
            



            
                
                
                
            
            
    <main class="main single" id="main">
    <div class="main-inner">

        

        <article class="content post h-entry" data-align="default" data-type="posts" data-layout="post">

            <h1 class="post-title p-name">Byte arrays and Channels</h1>

            

            

            

            <div class="post-body e-content">
                <p>Hi folks and a Happy new Year!</p>
<p>Today, I would like to show you some interesting things you can do with channels. Consider the following simple example.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">generatedPassword</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
	<span class="nx">correctPassword</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">generatedPassword</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">correctPassword</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">passwordIncrement</span><span class="p">(</span><span class="nx">generatedPassword</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">checkPassword</span><span class="p">(</span><span class="nx">generatedPassword</span><span class="p">,</span> <span class="nx">correctPassword</span><span class="p">)</span>
	<span class="nx">pass</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">correctPassword</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">pass</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">checkPassword</span><span class="p">(</span><span class="nx">input</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">output</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">input</span>
		<span class="c1">//Introduce lengthy operation here
</span><span class="c1"></span>		<span class="c1">// time.Sleep(time.Second)
</span><span class="c1"></span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Checking p:&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">p</span> <span class="p">&gt;</span> <span class="mi">100000</span> <span class="p">{</span>
			<span class="nx">output</span> <span class="o">&lt;-</span> <span class="nx">p</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">passwordIncrement</span><span class="p">(</span><span class="nx">out</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">p</span><span class="o">++</span>
		<span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">p</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>The premise is as follows. It launches two go routines. One, which generates passwords, and an other which checks for validity. The two routines talk to each other through the channel <code>generatedPassword</code>. That&rsquo;s the providing connections between them. The channel <code>correctPassword</code> provides output for the <code>checkPassword</code> routine.</p>
<p>If there is data received from <code>correctPassword</code> channel, we found our first password and there is no need to look further so we, print the password and quit. The channels will close with defer. This works. But the password is usually either a []byte or a string. With string, it still works.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">generatedPassword</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
	<span class="nx">correctPassword</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">generatedPassword</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">correctPassword</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">passwordIncrement</span><span class="p">(</span><span class="nx">generatedPassword</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">checkPassword</span><span class="p">(</span><span class="nx">generatedPassword</span><span class="p">,</span> <span class="nx">correctPassword</span><span class="p">)</span>
	<span class="nx">pass</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">correctPassword</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">pass</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">checkPassword</span><span class="p">(</span><span class="nx">input</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">output</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">input</span>
		<span class="c1">//Introduce lengthy operation here
</span><span class="c1"></span>		<span class="c1">// time.Sleep(time.Second)
</span><span class="c1"></span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Checking p:&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
		<span class="k">if</span> <span class="nf">performSomeCheckingOperation</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">output</span> <span class="o">&lt;-</span> <span class="nx">p</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">generateNewPassword</span><span class="p">(</span><span class="nx">out</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">p</span> <span class="kt">string</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nf">generate</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
		<span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">p</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>The generating happens based on the previously generated password. For example, we increment, or permeate. aaaa, aaab, aaac&hellip;</p>
<p>So <code>generatedPassword</code> is a buffered channel, it gathers a 100 passwords from which checking retrieves passwords one by one and works on them in a slower process.</p>
<p>Now, this is fine, but using []byte arrays will always be more powerful and faster. So we would like to use []byte. Like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">generatedPassword</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
	<span class="nx">correctPassword</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">generatedPassword</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">correctPassword</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">passwordIncrement</span><span class="p">(</span><span class="nx">generatedPassword</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">checkPassword</span><span class="p">(</span><span class="nx">generatedPassword</span><span class="p">,</span> <span class="nx">correctPassword</span><span class="p">)</span>
	<span class="nx">pass</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">correctPassword</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">pass</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">checkPassword</span><span class="p">(</span><span class="nx">input</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">output</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">input</span>
		<span class="c1">//Introduce lengthy operation here
</span><span class="c1"></span>		<span class="c1">// time.Sleep(time.Second)
</span><span class="c1"></span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Checking p:&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span>
		<span class="k">if</span> <span class="nf">performSomeCheckingOperation</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">output</span> <span class="o">&lt;-</span> <span class="nx">p</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">generateNewPassword</span><span class="p">(</span><span class="nx">out</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nf">generate</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
		<span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">p</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>This will not work. Why? Because []byte is a slice and thus will be constantly overwritten. The checking go routine will always only check the last data and many generated passwords will be lost. This is also noted in go&rsquo;s scanner here =&gt; <a href="https://golang.org/pkg/bufio/#Scanner.Bytes">Scanner.Bytes</a></p>
<p>We have a couple of options here.</p>
<p>We could use <code>string</code> channels and convert to []byte after. This is still okay, because the conversion isn&rsquo;t very CPU intensive.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">...</span>
<span class="nx">generatedPassword</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="nx">correctPassword</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>
<span class="o">...</span>
<span class="nx">p</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">input</span><span class="p">)</span> <span class="c1">//This will work very nicely.
</span><span class="c1"></span><span class="o">...</span>
</code></pre></div><p>Options two would be If you have a fixed password to handle, fix data, for example MD5 hash, you can use a byte array. Like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">const</span> <span class="nx">PASSWD</span><span class="p">=</span><span class="mi">13</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">generatedPassword</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[</span><span class="nx">PASSWD</span><span class="p">]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
	<span class="nx">correctPassword</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[</span><span class="nx">PASSWD</span><span class="p">]</span><span class="kt">byte</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">generatedPassword</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">correctPassword</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">passwordIncrement</span><span class="p">(</span><span class="nx">generatedPassword</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">checkPassword</span><span class="p">(</span><span class="nx">generatedPassword</span><span class="p">,</span> <span class="nx">correctPassword</span><span class="p">)</span>
	<span class="nx">pass</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">correctPassword</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">pass</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">checkPassword</span><span class="p">(</span><span class="nx">input</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="p">[</span><span class="nx">PASSWD</span><span class="p">]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">output</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="p">[</span><span class="nx">PASSWD</span><span class="p">]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">input</span>
		<span class="c1">//Introduce lengthy operation here
</span><span class="c1"></span>		<span class="c1">// time.Sleep(time.Second)
</span><span class="c1"></span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Checking p:&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span>
		<span class="k">if</span> <span class="nf">performSomeCheckingOperation</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">output</span> <span class="o">&lt;-</span> <span class="nx">p</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">generateNewPassword</span><span class="p">(</span><span class="nx">out</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="p">[</span><span class="nx">PASSWD</span><span class="p">]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">p</span> <span class="p">[</span><span class="nx">PASSWD</span><span class="p">]</span><span class="kt">byte</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nf">generate</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
		<span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">p</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>This is also one solution. If you have to convert between the two, could go with <code>p := byte[:]</code>.</p>
<p>Conclusion is, that use conversion rather than string types and be aware that using slices in channels is dangerous.</p>
<p>Thanks for reading!
Gergely.</p>

            </div>

            


        </article>

        

        


        


        


        


        


        


        


        


        


    </div>
</main>


            

            

        </div>
        

        















    </body>
</html>
