<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">

<meta itemprop="name" content="Byte arrays and Channels">
<meta itemprop="description" content="Hi folks and a Happy new Year!
Today, I would like to show you some interesting things you can do with channels. Consider the following simple example.
package main import &quot;fmt&quot; func main() { generatedPassword := make(chan int, 100) correctPassword := make(chan int) defer close(generatedPassword) defer close(correctPassword) go passwordIncrement(generatedPassword) go checkPassword(generatedPassword, correctPassword) pass := &lt;-correctPassword fmt.Println(pass) } func checkPassword(input &lt;-chan int, output chan&lt;- int) { for { p := &lt;-input //Introduce lengthy operation here // time.">


<meta itemprop="datePublished" content="2016-01-01T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2016-01-01T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="673">



<meta itemprop="keywords" content="" />
<meta property="og:title" content="Byte arrays and Channels" />
<meta property="og:description" content="Hi folks and a Happy new Year!
Today, I would like to show you some interesting things you can do with channels. Consider the following simple example.
package main import &quot;fmt&quot; func main() { generatedPassword := make(chan int, 100) correctPassword := make(chan int) defer close(generatedPassword) defer close(correctPassword) go passwordIncrement(generatedPassword) go checkPassword(generatedPassword, correctPassword) pass := &lt;-correctPassword fmt.Println(pass) } func checkPassword(input &lt;-chan int, output chan&lt;- int) { for { p := &lt;-input //Introduce lengthy operation here // time." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://skarlso.github.io/2016/01/01/byte-arrays-and-channels/" />
<meta property="article:published_time" content="2016-01-01T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2016-01-01T00:00:00&#43;00:00"/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Byte arrays and Channels"/>
<meta name="twitter:description" content="Hi folks and a Happy new Year!
Today, I would like to show you some interesting things you can do with channels. Consider the following simple example.
package main import &quot;fmt&quot; func main() { generatedPassword := make(chan int, 100) correctPassword := make(chan int) defer close(generatedPassword) defer close(correctPassword) go passwordIncrement(generatedPassword) go checkPassword(generatedPassword, correctPassword) pass := &lt;-correctPassword fmt.Println(pass) } func checkPassword(input &lt;-chan int, output chan&lt;- int) { for { p := &lt;-input //Introduce lengthy operation here // time."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Byte arrays and Channels</title>
	<link rel="stylesheet" href="https://skarlso.github.io/css/style.min.c693329ce3bac2503f88115a4011a284a06d53e30f484562a37664dc4c5f0a74.css" integrity="sha256-xpMynOO6wlA/iBFaQBGihKBtU+MPSEVio3Zk3ExfCnQ=">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://skarlso.github.io/">Ramblings of a cloud engineer</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					<a href="https://skarlso.github.io/blog/">blog</a>
				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://skarlso.github.io/blog/">blog</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Jan 1, 2016</span></div>
				<h1>Byte arrays and Channels</h1>
			</header>
			<div class="content">
				<p>Hi folks and a Happy new Year!</p>

<p>Today, I would like to show you some interesting things you can do with channels. Consider the following simple example.</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	generatedPassword := make(chan int, 100)
	correctPassword := make(chan int)
	defer close(generatedPassword)
	defer close(correctPassword)
	go passwordIncrement(generatedPassword)
	go checkPassword(generatedPassword, correctPassword)
	pass := &lt;-correctPassword
	fmt.Println(pass)
}

func checkPassword(input &lt;-chan int, output chan&lt;- int) {
	for {
		p := &lt;-input
		//Introduce lengthy operation here
		// time.Sleep(time.Second)
		fmt.Println(&quot;Checking p:&quot;, p)
		if p &gt; 100000 {
			output &lt;- p
		}
	}
}

func passwordIncrement(out chan&lt;- int) {
	p := 0
	for {
		p++
		out &lt;- p
	}
}
</code></pre>

<p>The premise is as follows. It launches two go routines. One, which generates passwords, and an other which checks for validity. The two routines talk to each other through the channel <code>generatedPassword</code>. That&rsquo;s the providing connections between them. The channel <code>correctPassword</code> provides output for the <code>checkPassword</code> routine.</p>

<p>If there is data received from <code>correctPassword</code> channel, we found our first password and there is no need to look further so we, print the password and quit. The channels will close with defer. This works. But the password is usually either a []byte or a string. With string, it still works.</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	generatedPassword := make(chan string, 100)
	correctPassword := make(chan string)
	defer close(generatedPassword)
	defer close(correctPassword)
	go passwordIncrement(generatedPassword)
	go checkPassword(generatedPassword, correctPassword)
	pass := &lt;-correctPassword
	fmt.Println(pass)
}

func checkPassword(input &lt;-chan string, output chan&lt;- string) {
	for {
		p := &lt;-input
		//Introduce lengthy operation here
		// time.Sleep(time.Second)
		fmt.Println(&quot;Checking p:&quot;, p)
		if performSomeCheckingOperation(p) {
			output &lt;- p
		}
	}
}

func generateNewPassword(out chan&lt;- string) {
	var p string
	for {
		p = generate(p)
		out &lt;- p
	}
}
</code></pre>

<p>The generating happens based on the previously generated password. For example, we increment, or permeate. aaaa, aaab, aaac&hellip;</p>

<p>So <code>generatedPassword</code> is a buffered channel, it gathers a 100 passwords from which checking retrieves passwords one by one and works on them in a slower process.</p>

<p>Now, this is fine, but using []byte arrays will always be more powerful and faster. So we would like to use []byte. Like this:</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	generatedPassword := make(chan []byte, 100)
	correctPassword := make(chan []byte)
	defer close(generatedPassword)
	defer close(correctPassword)
	go passwordIncrement(generatedPassword)
	go checkPassword(generatedPassword, correctPassword)
	pass := &lt;-correctPassword
	fmt.Println(string(pass))
}

func checkPassword(input &lt;-chan []byte, output chan&lt;- []byte) {
	for {
		p := &lt;-input
		//Introduce lengthy operation here
		// time.Sleep(time.Second)
		fmt.Println(&quot;Checking p:&quot;, string(p))
		if performSomeCheckingOperation(p) {
			output &lt;- p
		}
	}
}

func generateNewPassword(out chan&lt;- []byte) {
	var p []byte
	for {
		p = generate(p)
		out &lt;- p
	}
}
</code></pre>

<p>This will not work. Why? Because []byte is a slice and thus will be constantly overwritten. The checking go routine will always only check the last data and many generated passwords will be lost. This is also noted in go&rsquo;s scanner here =&gt; <a href="https://golang.org/pkg/bufio/#Scanner.Bytes">Scanner.Bytes</a></p>

<p>We have a couple of options here.</p>

<p>We could use <code>string</code> channels and convert to []byte after. This is still okay, because the conversion isn&rsquo;t very CPU intensive.</p>

<pre><code class="language-go">...
generatedPassword := make(chan string, 100)
correctPassword := make(chan string)
...
p := []byte(&lt;-input) //This will work very nicely.
...
</code></pre>

<p>Options two would be If you have a fixed password to handle, fix data, for example MD5 hash, you can use a byte array. Like this:</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

const PASSWD=13

func main() {
	generatedPassword := make(chan [PASSWD]byte, 100)
	correctPassword := make(chan [PASSWD]byte)
	defer close(generatedPassword)
	defer close(correctPassword)
	go passwordIncrement(generatedPassword)
	go checkPassword(generatedPassword, correctPassword)
	pass := &lt;-correctPassword
	fmt.Println(string(pass))
}

func checkPassword(input &lt;-chan [PASSWD]byte, output chan&lt;- [PASSWD]byte) {
	for {
		p := &lt;-input
		//Introduce lengthy operation here
		// time.Sleep(time.Second)
		fmt.Println(&quot;Checking p:&quot;, string(p))
		if performSomeCheckingOperation(p) {
			output &lt;- p
		}
	}
}

func generateNewPassword(out chan&lt;- [PASSWD]byte) {
	var p [PASSWD]byte
	for {
		p = generate(p)
		out &lt;- p
	}
}
</code></pre>

<p>This is also one solution. If you have to convert between the two, could go with <code>p := byte[:]</code>.</p>

<p>Conclusion is, that use conversion rather than string types and be aware that using slices in channels is dangerous.</p>

<p>Thanks for reading!
Gergely.</p>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>673 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2016-01-01 00:00 &#43;0000</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="https://skarlso.github.io/2016/01/05/improving-performance-with-byte-slice-and-int-map/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>Improving performance with byte slice and int map</span>
			</a>
			<a class="prev-post" href="https://skarlso.github.io/2015/12/29/use-byte-array-instead-of-strings/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>Use Byte Array Instead of Strings</span>
			</a>
		</div>
		<div id="comments" class="thin">
</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2021 <a href="https://skarlso.github.io/">Gergely Brautigam</a>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://skarlso.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	<script src="https://skarlso.github.io/js/main.min.4acd331997be4b64e30f47c568e49ba9ad887432eb559fcd232d73a3860134c5.js" integrity="sha256-Ss0zGZe+S2TjD0fFaOSbqa2IdDLrVZ/NIy1zo4YBNMU="></script>

</body>

</html>
