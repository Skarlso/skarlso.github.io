<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Furnace - The building of an AWS CLI Tool for CloudFormation and CodeDeploy - Part 4 | Ramblings of a cloud engineer</title>
<meta name="keywords" content="">
<meta name="description" content="Intro Hi folks.
Previously on this blog: Part 1. Part 2. Part 3.
In this part we are going to talk about Unit Testing Furnace and how to work some magic with AWS and Go.
Mock Stub Fake Dummy Canned Unit testing in Go usually follows the Dependency Injection model of dealing with Mocks and Stubs.
## DI
Dependency Inject in short is one object supplying the dependencies of another object.">
<meta name="author" content="hannibal">
<link rel="canonical" href="https://skarlso.github.io/2017/04/16/building-furnace-part-4/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://skarlso.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://skarlso.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://skarlso.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://skarlso.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://skarlso.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Furnace - The building of an AWS CLI Tool for CloudFormation and CodeDeploy - Part 4" />
<meta property="og:description" content="Intro Hi folks.
Previously on this blog: Part 1. Part 2. Part 3.
In this part we are going to talk about Unit Testing Furnace and how to work some magic with AWS and Go.
Mock Stub Fake Dummy Canned Unit testing in Go usually follows the Dependency Injection model of dealing with Mocks and Stubs.
## DI
Dependency Inject in short is one object supplying the dependencies of another object." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://skarlso.github.io/2017/04/16/building-furnace-part-4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-04-16T09:23:00+01:00" />
<meta property="article:modified_time" content="2017-04-16T09:23:00+01:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Furnace - The building of an AWS CLI Tool for CloudFormation and CodeDeploy - Part 4"/>
<meta name="twitter:description" content="Intro Hi folks.
Previously on this blog: Part 1. Part 2. Part 3.
In this part we are going to talk about Unit Testing Furnace and how to work some magic with AWS and Go.
Mock Stub Fake Dummy Canned Unit testing in Go usually follows the Dependency Injection model of dealing with Mocks and Stubs.
## DI
Dependency Inject in short is one object supplying the dependencies of another object."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://skarlso.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Furnace - The building of an AWS CLI Tool for CloudFormation and CodeDeploy - Part 4",
      "item": "https://skarlso.github.io/2017/04/16/building-furnace-part-4/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Furnace - The building of an AWS CLI Tool for CloudFormation and CodeDeploy - Part 4",
  "name": "Furnace - The building of an AWS CLI Tool for CloudFormation and CodeDeploy - Part 4",
  "description": "Intro Hi folks.\nPreviously on this blog: Part 1. Part 2. Part 3.\nIn this part we are going to talk about Unit Testing Furnace and how to work some magic with AWS and Go.\nMock Stub Fake Dummy Canned Unit testing in Go usually follows the Dependency Injection model of dealing with Mocks and Stubs.\n## DI\nDependency Inject in short is one object supplying the dependencies of another object.",
  "keywords": [
    
  ],
  "articleBody": "Intro Hi folks.\nPreviously on this blog: Part 1. Part 2. Part 3.\nIn this part we are going to talk about Unit Testing Furnace and how to work some magic with AWS and Go.\nMock Stub Fake Dummy Canned Unit testing in Go usually follows the Dependency Injection model of dealing with Mocks and Stubs.\n## DI\nDependency Inject in short is one object supplying the dependencies of another object. In a longer description, it’s ideal to be used for removing the lock on a third party library, like the AWS client. Imaging having code which solely depends on the AWS client. How would you unit test that code without having to ACTUALLY connect to AWS? You couldn’t. Every time you try to test the code it would run the live code and it would try and connect to AWS and perform the operations it’s design to do. The Ruby library with it’s metaprogramming allows you to set the client globally to stub responses, but, alas, this is not the world of Ruby.\nHere is where DI comes to the rescue. If you have control over the AWS client on a very high level, and would pass it around as a function parameter, or create that client in an init() function and have it globally defined; you would be able to implement your own client, and have your code use that with stubbed responses which your tests need. For example, you would like a CreateApplication call to fail, or you would like a DescribeStack which returns an aws.Error(“StackAlreadyExists”).\nFor this, however, you need the API of the AWS client. Which is provided by AWS.\nAWS Client API In order for DI to work, the injected object needs to be of a certain type for us to inject our own. Luckily, AWS provides an Interface for all of it’s clients. Meaning, we can implement our own version for all of the clients, like S3, CloudFormation, CodeDeploy etc.\nFor each client you want to mock out, an *iface package should be present like this:\n\"github.com/aws/aws-sdk-go/service/cloudformation/cloudformationiface\" In this package you find and use the interface like this:\ntype fakeCloudFormationClient struct { cloudformationiface.CloudFormationAPI err error } And with this, we have our own CloudFormation client. The real code uses the real clients as function parameters, like this:\n// Execute defines what this command does. func (c *Create) Execute(opts *commander.CommandHelper) { log.Println(\"Creating cloud formation session.\") sess := session.New(\u0026aws.Config{Region: aws.String(config.REGION)}) cfClient := cloudformation.New(sess, nil) client := CFClient{cfClient} createExecute(opts, \u0026client) } We can’t test Execute itself, as it’s using the real client here (or you could have a global from some library, thus allowing you to tests even Execute here) but there is very little logic in this function for this very reason. All the logic is in small functions for which the main starting point and our testing opportunity is, createExecute.\nStubbing Calls Now, that we have our own client, and with the power of Go’s interface embedding as seen above with CloudFormationAPI, we have to only stub the functions which we are actually using, instead of every function of the given interface. This looks like this:\ncfClient := new(CFClient) cfClient.Client = \u0026fakeCloudFormationClient{err: nil} Where cfClient is a struct like this:\n// CFClient abstraction for cloudFormation client. type CFClient struct { Client cloudformationiface.CloudFormationAPI } And a stubbed call can than be written as follows:\nfunc (fc *fakeCreateCFClient) WaitUntilStackCreateComplete(input *cloudformation.DescribeStacksInput) error { return nil } This can range from a very trivial example, like the one above, to intricate ones as well, like this gem:\nfunc (fc *fakePushCFClient) ListStackResources(input *cloudformation.ListStackResourcesInput) (*cloudformation.ListStackResourcesOutput, error) { if \"NoASG\" == *input.StackName { return \u0026cloudformation.ListStackResourcesOutput{ StackResourceSummaries: []*cloudformation.StackResourceSummary{ { ResourceType: aws.String(\"NoASG\"), PhysicalResourceId: aws.String(\"arn::whatever\"), }, }, }, fc.err } return \u0026cloudformation.ListStackResourcesOutput{ StackResourceSummaries: []*cloudformation.StackResourceSummary{ { ResourceType: aws.String(\"AWS::AutoScaling::AutoScalingGroup\"), PhysicalResourceId: aws.String(\"arn::whatever\"), }, }, }, fc.err } This ListStackResources stub lets us test two scenarios based on the stackname. If the test stackname is ‘NoASG’ it will return a result which equals to a result containing no AutoScaling Group. Otherwise, it will return the correct ResourceType for an ASG.\nIt is a common practice to line up several scenario based stubbed responses in order to test the robustness of your code.\nUnfortunately, this also means that your tests will be a bit cluttered with stubs and mock structs and whatnots. For that, I’m partially using a package available struct file in which I’m defining most of the mock structs at least. And from there on, the tests will only contain specific stubs for that particular file. This can be further fine grained by having defaults and than only override in case you need something else.\nTesting fatals Now, the other point which is not really AWS related, but still comes to mind when dealing with Furnace, is testing error scenarios.\nBecause Furnace is a CLI application it uses Fatals to signal if something is wrong and it doesn’t want to continue or recover because, frankly it can’t. If AWS throws an error, that’s it. You can retry, but in 90% of the cases, it’s usually something that you messed up.\nSo, how do we test for a fatal or an os.Exit? There are a number of points on that if you do a quick search. You may end up on this talk: GoTalk 2014 Testing Slide #23. Which does an interesting thing. It calls the test binary in a separate process and tests the exit code.\nOthers, and me as well, will say that you have to have your own logger implemented and use a different logger / os.Exit in your test environment.\nOthers others will tell you to not to have tests around os.Exit and fatal things, rather return an error and only the main should pop a world ending event. I leave it up to you which you want to use. Either is fine.\nIn Furnace, I’m using a global logger in my error handling util like this:\n// HandleFatal handler fatal errors in Furnace. func HandleFatal(s string, err error) { LogFatalf(s, err) } And LogFatalf is an exported variable var LogFatalf = log.Fatalf. Than in a test, I just override this variable with a local anonymous function:\nfunc TestCreateExecuteEmptyStack(t *testing.T) { failed := false utils.LogFatalf = func(s string, a ...interface{}) { failed = true } config.WAITFREQUENCY = 0 client := new(CFClient) stackname := \"EmptyStack\" client.Client = \u0026fakeCreateCFClient{err: nil, stackname: stackname} opts := \u0026commander.CommandHelper{} createExecute(opts, client) if !failed { t.Error(\"expected outcome to fail during create\") } } It can get even more granular by testing for the error message to make sure that it actually fails at the point we think we are testing:\nfunc TestCreateStackReturnsWithError(t *testing.T) { failed := false expectedMessage := \"failed to create stack\" var message string utils.LogFatalf = func(s string, a ...interface{}) { failed = true if err, ok := a[0].(error); ok { message = err.Error() } } config.WAITFREQUENCY = 0 client := new(CFClient) stackname := \"NotEmptyStack\" client.Client = \u0026fakeCreateCFClient{err: errors.New(expectedMessage), stackname: stackname} config := []byte(\"{}\") create(stackname, config, client) if !failed { t.Error(\"expected outcome to fail\") } if message != expectedMessage { t.Errorf(\"message did not equal expected message of '%s', was:%s\", expectedMessage, message) } } Conclusion This is it. That’s all it took to write Furnace. I hope you enjoyed reading it as much as I enjoyed writing all these thoughts down.\nI hope somebody might learn from my journey and also improve upon it.\nAny comments are much appreciated and welcomed. Also, PRs and Issues can be submitted on the GitHub page of Furnace.\nThank you for reading! Gergely.\n",
  "wordCount" : "1249",
  "inLanguage": "en",
  "datePublished": "2017-04-16T09:23:00+01:00",
  "dateModified": "2017-04-16T09:23:00+01:00",
  "author":{
    "@type": "Person",
    "name": "hannibal"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://skarlso.github.io/2017/04/16/building-furnace-part-4/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ramblings of a cloud engineer",
    "logo": {
      "@type": "ImageObject",
      "url": "https://skarlso.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://skarlso.github.io" accesskey="h" title="Ramblings of a cloud engineer (Alt + H)">Ramblings of a cloud engineer</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Furnace - The building of an AWS CLI Tool for CloudFormation and CodeDeploy - Part 4
    </h1>
    <div class="post-meta"><span title='2017-04-16 09:23:00 +0100 +0100'>April 16, 2017</span>&nbsp;·&nbsp;hannibal

</div>
  </header> 
  <div class="post-content"><h1 id="intro">Intro<a hidden class="anchor" aria-hidden="true" href="#intro">#</a></h1>
<p>Hi folks.</p>
<p>Previously on this blog: <a href="https://skarlso.github.io/2017/03/16/building-furnace-part-1/">Part 1</a>. <a href="https://skarlso.github.io/2017/03/19/building-furnace-part-2/">Part 2</a>. <a href="https://skarlso.github.io/2017/03/22/building-furnace-part-3/">Part 3</a>.</p>
<p>In this part we are going to talk about Unit Testing Furnace and how to work some magic with AWS and Go.</p>
<h1 id="mock-stub-fake-dummy-canned-insert-name-here">Mock Stub Fake Dummy Canned <Insert Name Here><a hidden class="anchor" aria-hidden="true" href="#mock-stub-fake-dummy-canned-insert-name-here">#</a></h1>
<p>Unit testing in Go usually follows the Dependency Injection model of dealing with Mocks and Stubs.</p>
<p>## DI</p>
<p>Dependency Inject in short is one object supplying the dependencies of another object. In a longer description, it&rsquo;s ideal to be used
for removing the lock on a third party library, like the AWS client. Imaging having code which solely depends on the AWS client. How
would you unit test that code without having to ACTUALLY connect to AWS? You couldn&rsquo;t. Every time you try to test the code it would run
the live code and it would try and connect to AWS and perform the operations it&rsquo;s design to do. The Ruby library with it&rsquo;s metaprogramming
allows you to set the client globally to stub responses, but, alas, this is not the world of Ruby.</p>
<p>Here is where DI comes to the rescue. If you have control over the AWS client on a very high level, and would pass it around as a function
parameter, or create that client in an <code>init()</code> function and have it globally defined; you would be able to implement your own client, and
have your code use that with stubbed responses which your tests need. For example, you would like a CreateApplication call to fail, or you
would like a DescribeStack which returns an aws.Error(&ldquo;StackAlreadyExists&rdquo;).</p>
<p>For this, however, you need the API of the AWS client. Which is provided by AWS.</p>
<h2 id="aws-client-api">AWS Client API<a hidden class="anchor" aria-hidden="true" href="#aws-client-api">#</a></h2>
<p>In order for DI to work, the injected object needs to be of a certain type for us to inject our own. Luckily, AWS provides an Interface for
all of it&rsquo;s clients. Meaning, we can implement our own version for all of the clients, like S3, CloudFormation, CodeDeploy etc.</p>
<p>For each client you want to mock out, an <em>*iface</em> package should be present like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;github.com/aws/aws-sdk-go/service/cloudformation/cloudformationiface&#34;</span>
</span></span></code></pre></div><p>In this package you find and use the interface like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">fakeCloudFormationClient</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cloudformationiface</span>.<span style="color:#a6e22e">CloudFormationAPI</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And with this, we have our own CloudFormation client. The real code uses the real clients as function parameters, like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Execute defines what this command does.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Create</span>) <span style="color:#a6e22e">Execute</span>(<span style="color:#a6e22e">opts</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">commander</span>.<span style="color:#a6e22e">CommandHelper</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Creating cloud formation session.&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sess</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">session</span>.<span style="color:#a6e22e">New</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">aws</span>.<span style="color:#a6e22e">Config</span>{<span style="color:#a6e22e">Region</span>: <span style="color:#a6e22e">aws</span>.<span style="color:#a6e22e">String</span>(<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">REGION</span>)})
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cfClient</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cloudformation</span>.<span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">sess</span>, <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">client</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">CFClient</span>{<span style="color:#a6e22e">cfClient</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">createExecute</span>(<span style="color:#a6e22e">opts</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">client</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can&rsquo;t test Execute itself, as it&rsquo;s using the real client here (or you could have a global from some library, thus allowing you to tests
even <code>Execute</code> here) but there is very little logic in this function for this very reason. All the logic is in small functions for which
the main starting point and our testing opportunity is, <code>createExecute</code>.</p>
<h2 id="stubbing-calls">Stubbing Calls<a hidden class="anchor" aria-hidden="true" href="#stubbing-calls">#</a></h2>
<p>Now, that we have our own client, and with the power of Go&rsquo;s interface embedding as seen above with CloudFormationAPI, we have to only stub
the functions which we are actually using, instead of every function of the given interface. This looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">cfClient</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">CFClient</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cfClient</span>.<span style="color:#a6e22e">Client</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fakeCloudFormationClient</span>{<span style="color:#a6e22e">err</span>: <span style="color:#66d9ef">nil</span>}
</span></span></code></pre></div><p>Where cfClient is a struct like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// CFClient abstraction for cloudFormation client.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">CFClient</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Client</span> <span style="color:#a6e22e">cloudformationiface</span>.<span style="color:#a6e22e">CloudFormationAPI</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And a stubbed call can than be written as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">fc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">fakeCreateCFClient</span>) <span style="color:#a6e22e">WaitUntilStackCreateComplete</span>(<span style="color:#a6e22e">input</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">cloudformation</span>.<span style="color:#a6e22e">DescribeStacksInput</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This can range from a very trivial example, like the one above, to intricate ones as well, like this gem:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">fc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">fakePushCFClient</span>) <span style="color:#a6e22e">ListStackResources</span>(<span style="color:#a6e22e">input</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">cloudformation</span>.<span style="color:#a6e22e">ListStackResourcesInput</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">cloudformation</span>.<span style="color:#a6e22e">ListStackResourcesOutput</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#34;NoASG&#34;</span> <span style="color:#f92672">==</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">StackName</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">cloudformation</span>.<span style="color:#a6e22e">ListStackResourcesOutput</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">StackResourceSummaries</span>: []<span style="color:#f92672">*</span><span style="color:#a6e22e">cloudformation</span>.<span style="color:#a6e22e">StackResourceSummary</span>{
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">ResourceType</span>:       <span style="color:#a6e22e">aws</span>.<span style="color:#a6e22e">String</span>(<span style="color:#e6db74">&#34;NoASG&#34;</span>),
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">PhysicalResourceId</span>: <span style="color:#a6e22e">aws</span>.<span style="color:#a6e22e">String</span>(<span style="color:#e6db74">&#34;arn::whatever&#34;</span>),
</span></span><span style="display:flex;"><span>				},
</span></span><span style="display:flex;"><span>			},
</span></span><span style="display:flex;"><span>		}, <span style="color:#a6e22e">fc</span>.<span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">cloudformation</span>.<span style="color:#a6e22e">ListStackResourcesOutput</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">StackResourceSummaries</span>: []<span style="color:#f92672">*</span><span style="color:#a6e22e">cloudformation</span>.<span style="color:#a6e22e">StackResourceSummary</span>{
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">ResourceType</span>:       <span style="color:#a6e22e">aws</span>.<span style="color:#a6e22e">String</span>(<span style="color:#e6db74">&#34;AWS::AutoScaling::AutoScalingGroup&#34;</span>),
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">PhysicalResourceId</span>: <span style="color:#a6e22e">aws</span>.<span style="color:#a6e22e">String</span>(<span style="color:#e6db74">&#34;arn::whatever&#34;</span>),
</span></span><span style="display:flex;"><span>			},
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	}, <span style="color:#a6e22e">fc</span>.<span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This ListStackResources stub lets us test two scenarios based on the stackname. If the test stackname is &lsquo;NoASG&rsquo; it will return a result
which equals to a result containing no AutoScaling Group. Otherwise, it will return the correct ResourceType for an ASG.</p>
<p>It is a common practice to line up several scenario based stubbed responses in order to test the robustness of your code.</p>
<p>Unfortunately, this also means that your tests will be a bit cluttered with stubs and mock structs and whatnots. For that, I&rsquo;m partially
using a package available struct file in which I&rsquo;m defining most of the mock structs at least. And from there on, the tests will only contain
specific stubs for that particular file. This can be further fine grained by having defaults and than only override in case you need something
else.</p>
<h1 id="testing-fatals">Testing fatals<a hidden class="anchor" aria-hidden="true" href="#testing-fatals">#</a></h1>
<p>Now, the other point which is not really AWS related, but still comes to mind when dealing with Furnace, is testing error scenarios.</p>
<p>Because Furnace is a CLI application it uses Fatals to signal if something is wrong and it doesn&rsquo;t want to continue or recover because, frankly
it can&rsquo;t. If AWS throws an error, that&rsquo;s it. You can retry, but in 90% of the cases, it&rsquo;s usually something that you messed up.</p>
<p>So, how do we test for a fatal or an <code>os.Exit</code>? There are a number of points on that if you do a quick search. You may end up on this talk:
<a href="https://talks.golang.org/2014/testing.slide#23">GoTalk 2014 Testing Slide #23</a>. Which does an interesting thing. It calls the test binary in a
separate process and tests the exit code.</p>
<p>Others, and me as well, will say that you have to have your own logger implemented and use a different logger / os.Exit in your test environment.</p>
<p>Others others will tell you to not to have tests around os.Exit and fatal things, rather return an error and only the main should pop a world
ending event. I leave it up to you which you want to use. Either is fine.</p>
<p>In Furnace, I&rsquo;m using a global logger in my error handling util like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// HandleFatal handler fatal errors in Furnace.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">HandleFatal</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">LogFatalf</span>(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And <code>LogFatalf</code> is an exported variable <code>var LogFatalf = log.Fatalf</code>. Than in a test, I just override this variable with a local anonymous
function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestCreateExecuteEmptyStack</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">failed</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">LogFatalf</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">a</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">interface</span>{}) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">failed</span> = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">WAITFREQUENCY</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">client</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">CFClient</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">stackname</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;EmptyStack&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">Client</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fakeCreateCFClient</span>{<span style="color:#a6e22e">err</span>: <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">stackname</span>: <span style="color:#a6e22e">stackname</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">opts</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">commander</span>.<span style="color:#a6e22e">CommandHelper</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">createExecute</span>(<span style="color:#a6e22e">opts</span>, <span style="color:#a6e22e">client</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">failed</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Error</span>(<span style="color:#e6db74">&#34;expected outcome to fail during create&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It can get even more granular by testing for the error message to make sure that it actually fails at the point we think we are
testing:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestCreateStackReturnsWithError</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">failed</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">expectedMessage</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;failed to create stack&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">message</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">LogFatalf</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">a</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">interface</span>{}) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">failed</span> = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">0</span>].(<span style="color:#66d9ef">error</span>); <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">message</span> = <span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>()
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">WAITFREQUENCY</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">client</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">CFClient</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">stackname</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;NotEmptyStack&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">Client</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fakeCreateCFClient</span>{<span style="color:#a6e22e">err</span>: <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">expectedMessage</span>), <span style="color:#a6e22e">stackname</span>: <span style="color:#a6e22e">stackname</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">config</span> <span style="color:#f92672">:=</span> []byte(<span style="color:#e6db74">&#34;{}&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">create</span>(<span style="color:#a6e22e">stackname</span>, <span style="color:#a6e22e">config</span>, <span style="color:#a6e22e">client</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">failed</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Error</span>(<span style="color:#e6db74">&#34;expected outcome to fail&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">message</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">expectedMessage</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;message did not equal expected message of &#39;%s&#39;, was:%s&#34;</span>, <span style="color:#a6e22e">expectedMessage</span>, <span style="color:#a6e22e">message</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>This is it. That&rsquo;s all it took to write Furnace. I hope you enjoyed reading it as much as I enjoyed writing all these thoughts down.</p>
<p>I hope somebody might learn from my journey and also improve upon it.</p>
<p>Any comments are much appreciated and welcomed. Also, PRs and Issues can be submitted on the GitHub page of <a href="https://github.com/Skarlso/go-furnace">Furnace</a>.</p>
<p>Thank you for reading!
Gergely.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer><div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hannibalDisqus" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://skarlso.github.io">Ramblings of a cloud engineer</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
