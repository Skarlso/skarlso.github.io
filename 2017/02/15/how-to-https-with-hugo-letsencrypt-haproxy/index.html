<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>How to HTTPS with Hugo LetsEncrypt and HAProxy | Ramblings of a cloud engineer</title>
<meta name="keywords" content="">
<meta name="description" content="Intro Hi folks.
Today, I would like to write about how to do HTTPS for a website, without the need to buy a certificate and set it up via your DNS provider. Let&rsquo;s begin.
Abstract What you will achieve by the end of this post:
Every call to HTTP will be redirected to HTTPS via haproxy. HTTPS will be served with Haproxy and LetsEncrypt as the Certificate provider. Automatically update the certificate before its expiration.">
<meta name="author" content="hannibal">
<link rel="canonical" href="https://skarlso.github.io/2017/02/15/how-to-https-with-hugo-letsencrypt-haproxy/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://skarlso.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://skarlso.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://skarlso.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://skarlso.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://skarlso.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="How to HTTPS with Hugo LetsEncrypt and HAProxy" />
<meta property="og:description" content="Intro Hi folks.
Today, I would like to write about how to do HTTPS for a website, without the need to buy a certificate and set it up via your DNS provider. Let&rsquo;s begin.
Abstract What you will achieve by the end of this post:
Every call to HTTP will be redirected to HTTPS via haproxy. HTTPS will be served with Haproxy and LetsEncrypt as the Certificate provider. Automatically update the certificate before its expiration." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://skarlso.github.io/2017/02/15/how-to-https-with-hugo-letsencrypt-haproxy/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-02-15T19:20:00+01:00" />
<meta property="article:modified_time" content="2017-02-15T19:20:00+01:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="How to HTTPS with Hugo LetsEncrypt and HAProxy"/>
<meta name="twitter:description" content="Intro Hi folks.
Today, I would like to write about how to do HTTPS for a website, without the need to buy a certificate and set it up via your DNS provider. Let&rsquo;s begin.
Abstract What you will achieve by the end of this post:
Every call to HTTP will be redirected to HTTPS via haproxy. HTTPS will be served with Haproxy and LetsEncrypt as the Certificate provider. Automatically update the certificate before its expiration."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://skarlso.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "How to HTTPS with Hugo LetsEncrypt and HAProxy",
      "item": "https://skarlso.github.io/2017/02/15/how-to-https-with-hugo-letsencrypt-haproxy/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "How to HTTPS with Hugo LetsEncrypt and HAProxy",
  "name": "How to HTTPS with Hugo LetsEncrypt and HAProxy",
  "description": "Intro Hi folks.\nToday, I would like to write about how to do HTTPS for a website, without the need to buy a certificate and set it up via your DNS provider. Let\u0026rsquo;s begin.\nAbstract What you will achieve by the end of this post:\nEvery call to HTTP will be redirected to HTTPS via haproxy. HTTPS will be served with Haproxy and LetsEncrypt as the Certificate provider. Automatically update the certificate before its expiration.",
  "keywords": [
    
  ],
  "articleBody": "Intro Hi folks.\nToday, I would like to write about how to do HTTPS for a website, without the need to buy a certificate and set it up via your DNS provider. Let’s begin.\nAbstract What you will achieve by the end of this post:\nEvery call to HTTP will be redirected to HTTPS via haproxy. HTTPS will be served with Haproxy and LetsEncrypt as the Certificate provider. Automatically update the certificate before its expiration. No need for IPTable rules to route 8080 to 80. Traffic to and from your page will be encrypted. This all will cost you nothing. I will use a static website generator for this called Hugo which, if you know me, is my favorite generator tool. These instructions are for haproxy and hugo, if you wish to use apache and nginx for example, you’ll have to dig for the corresponding settings for letsencrypt and certbot.\nWhat You Will Need Hugo You will need hugo, which can be downloaded from here: Hugo. A simple website will be enough. For themes, you can take a look at the humongous list located here: HugoThemes.\nHaproxy Haproxy can be found here: Haproxy. There are a number of options to install haproxy. I chose a simple apt-get install haproxy.\nLet’s Encrypt Information about Let’s Encrypt can be found on their website here: Let’s Encrypt. Let’s Encrypt’s client is now called Certbot which is used to generate the certificates. To get the latest code you either clone the repository Certbot, or use an auto downloader:\nuser@webserver:~$ wget https://dl.eff.org/certbot-auto user@webserver:~$ chmod a+x ./certbot-auto user@webserver:~$ ./certbot-auto --help Either way, I’m using the current latest version: v0.11.1.\nSudo This goes without saying, but that these operations will require you to have sudo privileges. I suggest staying in sudo for ease of use. This means that the commands, I’ll write here, will assume you are in sudo su mode thus no sudo prefix will be used.\nPortforwarding In order for your website to work under https this guide assumes that you have port 80 and 443 open on your router / network security group.\nSetup Single Server Environment It is possible for haproxy, certbot and your website to run on designated servers. Haproxy’s abilities allows to define multiple server sources. In this guide, my haproxy, website and certbot will all run on the same server; thus redirecting to 127.0.0.1 and local ips. This is more convenient, because otherwise the haproxy IP would have to be a permanent local/remote ip. Or an automated script would have to be setup which is notified upon IP change and updates the ip records.\nCreating a Certificate Diving in, the first thing you will require is a certificate. A certificate will allow for encrypted traffic and an authenticated website. Let’s Encrypt which is basically functioning as an independent, free, automated CA (Certificate Authority). Usually, the process would be to pay a CA to give you a signed, generated certificate for your website, and you would have to set that up with your DNS provider. Let’s Encrypt has that all automated, and free of any charge. Neat.\nCertbot So let’s get started. Clone the repository into /opt/letsencrypt for further usage.\ngit clone https://github.com/certbot/certbot /opt/letsencrypt Generating the certificate Make sure that there is nothing listening on ports: 80, 443. To list usage:\nnetstat -nlt | grep ':80\\s' netstat -nlt | grep ':443\\s' Kill everything that might be on these ports, like apache2 and httpd. These will be used by haproxy and certbot for challenges and redirecting traffic.\nYou will be creating a standalone certificate. This is the reason we need port 80 and 443 open. Run certbot by defining the certonly and --standalone flags. For domain validation you are going to use port 443, tls-sni-01 challenge. The whole command looks like this:\ncd /opt/letsencrypt ./certbot-auto certonly --standalone -d example.com -d www.example.com If this displays something like, “couldn’t connect” you probably still have something running on a port it tries to use. The generated certificate will be located under /etc/letsencrypt/archive and /etc/letsencrypt/keys while /etc/letsencrypt/live is a symlink to the latest version of the cert. It’s wise to not copy these away from here, since the live link is always updated to the latest version. Our script will handle haproxy, which requires one cert file made from privkey + fullchain|.pem files.\nSetup Auto-Renewal Let’s Encrypt issues short lived certificates (90 days). In order to not have to do this procedure every 89 days, certbot provides a nifty command called renew. However, for the cert to be generated, the port 443 has to be open. This means, haproxy needs to be stopped before doing the renew. Now, you COULD write a script which stops it, and after the certificate has been renewed, starts it again, but certbot has you covered again in that department. It provides hooks called pre-hook and post-hook. Thus, all you have to write is the following:\n#!/bin/bash cd /opt/letsencrypt ./certbot-auto renew --pre-hook \"service haproxy stop\" --post-hook \"service haproxy start\" DOMAIN='example.com' sudo -E bash -c 'cat /etc/letsencrypt/live/$DOMAIN/fullchain.pem /etc/letsencrypt/live/$DOMAIN/privkey.pem \u003e /etc/haproxy/certs/$DOMAIN.pem' If you would like to test it first, just include the switch --dry-run.\nIn case of success you should see something like this:\nroot@raspberrypi:/opt/letsencrypt# ./certbot-auto renew --pre-hook \"service haproxy stop\" --post-hook \"service haproxy start\" --dry-run Saving debug log to /var/log/letsencrypt/letsencrypt.log ------------------------------------------------------------------------------- Processing /etc/letsencrypt/renewal/example.com.conf ------------------------------------------------------------------------------- Cert not due for renewal, but simulating renewal for dry run Running pre-hook command: service haproxy stop Renewing an existing certificate Performing the following challenges: tls-sni-01 challenge for example.com Waiting for verification... Cleaning up challenges Generating key (2048 bits): /etc/letsencrypt/keys/0002_key-certbot.pem Creating CSR: /etc/letsencrypt/csr/0002_csr-certbot.pem ** DRY RUN: simulating 'certbot renew' close to cert expiry ** (The test certificates below have not been saved.) Congratulations, all renewals succeeded. The following certs have been renewed: /etc/letsencrypt/live/example.com/fullchain.pem (success) ** DRY RUN: simulating 'certbot renew' close to cert expiry ** (The test certificates above have not been saved.) Running post-hook command: service haproxy start Put this script into a crontab to run every 89 days like this:\ncrontab -e # Open crontab for edit and paste in this line * * */89 * * /root/renew-cert.sh And you should be all set. Now we move on the configure haproxy to redirect and to use our newly generated certificate.\nHaproxy Like I said, haproxy requires a single file certificate in order to encrypt traffic to and from the website. To do this, we need to combine privkey.pem and fullchain.pem. As of this writing, there are a couple of solutions to automate this via a post hook on renewal. And also, there is an open ticket with certbot to implement a simpler solution located here: https://github.com/certbot/certbot/issues/1201. I, for now, have chosen to simply concatenate the two files together with cat like this:\nDOMAIN='example.com' sudo -E bash -c 'cat /etc/letsencrypt/live/$DOMAIN/fullchain.pem /etc/letsencrypt/live/$DOMAIN/privkey.pem \u003e /etc/haproxy/certs/$DOMAIN.pem' It will create a combined cert under /etc/haproxy/certs/example.com.pem.\nHaproxy configuration If haproxy happens to be running, stop it with service haproxy stop.\nFirst, save the default configuration file: cp /etc/haproxy/haproxy.cfg /etc/haproxy/haproxy.cfg.old. Now, overwrite the old one with this new one (comments about what each setting does, are in-lined; they are safe to copy):\nglobal daemon # Set this to your desired maximum connection count. maxconn 2048 # https://cbonte.github.io/haproxy-dconv/configuration-1.5.html#3.2-tune.ssl.default-dh-param # bit setting for Diffie - Hellman key size. tune.ssl.default-dh-param 2048 defaults option forwardfor option http-server-close log global mode http option httplog option dontlognull timeout connect 5000 timeout client 50000 timeout server 50000 errorfile 400 /etc/haproxy/errors/400.http errorfile 403 /etc/haproxy/errors/403.http errorfile 408 /etc/haproxy/errors/408.http errorfile 500 /etc/haproxy/errors/500.http errorfile 502 /etc/haproxy/errors/502.http errorfile 503 /etc/haproxy/errors/503.http errorfile 504 /etc/haproxy/errors/504.http # In case it's a simple http call, we redirect to the basic backend server # which in turn, if it isn't an SSL call, will redirect to HTTPS that is # handled by the frontend setting called 'www-https'. frontend www-http # Redirect HTTP to HTTPS bind *:80 # Adds http header to end of end of the HTTP request reqadd X-Forwarded-Proto:\\ http # Sets the default backend to use which is defined below with name 'www-backend' default_backend www-backend # If the call is HTTPS we set a challenge to letsencrypt backend which # verifies our certificate and than direct traffic to the backend server # which is the running hugo site that is served under https if the challenge succeeds. frontend www-https # Bind 443 with the generated letsencrypt cert. bind *:443 ssl crt /etc/haproxy/certs/skarlso.com.pem # set x-forward to https reqadd X-Forwarded-Proto:\\ https # set X-SSL in case of ssl_fc \u003c- explained below http-request set-header X-SSL %[ssl_fc] # Select a Challenge acl letsencrypt-acl path_beg /.well-known/acme-challenge/ # Use the challenge backend if the challenge is set use_backend letsencrypt-backend if letsencrypt-acl default_backend www-backend backend www-backend # Redirect with code 301 so the browser understands it is a redirect. If it's not SSL_FC. # ssl_fc: Returns true when the front connection was made via an SSL/TLS transport # layer and is locally deciphered. This means it has matched a socket declared # with a \"bind\" line having the \"ssl\" option. redirect scheme https code 301 if !{ ssl_fc } # Server for the running hugo site. server www-1 192.168.0.17:8080 check backend letsencrypt-backend # Lets encrypt backend server server letsencrypt 127.0.0.1:54321 Save this, and start haproxy with services haproxy start. If you did everything right, it should say nothing. If, however, there went something wrong with starting the proxy, it usually displays something like this:\nJob for haproxy.service failed. See 'systemctl status haproxy.service' and 'journalctl -xn' for details. You can also gather some more information on what went wrong from less /var/log/haproxy.log.\nStarting the Server Everything should be ready to go. Hugo has the concept of a baseUrl. Everything that it loads, and tries to access will be prefixed with it. You can either set it through it’s config.yaml file, or from the command line.\nTo start the server, call this from the site’s root folder:\nhugo server --bind=192.168.x.x --port=8080 --baseUrl=https://example.com --appendPort=false Interesting thing here to note is https and the port. The IP could be 127.0.0.1 as well. I experienced problems though with not binding to network IP when I was debugging the site from a different laptop on the same network.\nOnce the server is started, you should be able to open up your website from a different browser, not on your local network, and see that it has a valid certificate installed. In Chrome you should see a green icon telling you that the cert is valid.\nLast Words And that is all. The site should be up and running and the proxy should auto-renew your site’s certificate. If you happened to change DNS or change the server, you’ll have to reissue the certificate.\nThanks for reading! Any questions or trouble setting something up, please feel free to leave a comment.\nCheers, Gergely.\n",
  "wordCount" : "1781",
  "inLanguage": "en",
  "datePublished": "2017-02-15T19:20:00+01:00",
  "dateModified": "2017-02-15T19:20:00+01:00",
  "author":{
    "@type": "Person",
    "name": "hannibal"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://skarlso.github.io/2017/02/15/how-to-https-with-hugo-letsencrypt-haproxy/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ramblings of a cloud engineer",
    "logo": {
      "@type": "ImageObject",
      "url": "https://skarlso.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://skarlso.github.io" accesskey="h" title="Ramblings of a cloud engineer (Alt + H)">Ramblings of a cloud engineer</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://skarlso.github.io/posts/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      How to HTTPS with Hugo LetsEncrypt and HAProxy
    </h1>
    <div class="post-meta"><span title='2017-02-15 19:20:00 +0100 +0100'>February 15, 2017</span>&nbsp;·&nbsp;hannibal

</div>
  </header> 
  <div class="post-content"><h1 id="intro">Intro<a hidden class="anchor" aria-hidden="true" href="#intro">#</a></h1>
<p>Hi folks.</p>
<p>Today, I would like to write about how to do HTTPS for a website, without the need to buy a certificate and set it up via your DNS provider. Let&rsquo;s begin.</p>
<h2 id="abstract">Abstract<a hidden class="anchor" aria-hidden="true" href="#abstract">#</a></h2>
<p>What you will achieve by the end of this post:</p>
<ul>
<li>Every call to HTTP will be redirected to HTTPS via <a href="https://www.haproxy.com">haproxy</a>.</li>
<li>HTTPS will be served with Haproxy and <a href="https://letsencrypt.org">LetsEncrypt</a> as the Certificate provider.</li>
<li>Automatically update the certificate before its expiration.</li>
<li>No need for IPTable rules to route 8080 to 80.</li>
<li>Traffic to and from your page will be encrypted.</li>
<li>This all will cost you nothing.</li>
</ul>
<p>I will use a static website generator for this called <a href="https://gohugo.io">Hugo</a> which, if you know me, is my favorite generator tool. These instructions
are for haproxy and hugo, if you wish to use apache and nginx for example, you&rsquo;ll have to dig for the corresponding settings for letsencrypt and certbot.</p>
<h1 id="what-you-will-need">What You Will Need<a hidden class="anchor" aria-hidden="true" href="#what-you-will-need">#</a></h1>
<h2 id="hugo">Hugo<a hidden class="anchor" aria-hidden="true" href="#hugo">#</a></h2>
<p>You will need hugo, which can be downloaded from here: <a href="https://gohugo.io">Hugo</a>. A simple website will be enough. For themes, you can take a look
at the humongous list located here: <a href="http://themes.gohugo.io/">HugoThemes</a>.</p>
<h2 id="haproxy">Haproxy<a hidden class="anchor" aria-hidden="true" href="#haproxy">#</a></h2>
<p>Haproxy can be found here: <a href="https://www.haproxy.com">Haproxy</a>. There are a number of options to install haproxy. I chose a simple
<code>apt-get install haproxy</code>.</p>
<h2 id="lets-encrypt">Let&rsquo;s Encrypt<a hidden class="anchor" aria-hidden="true" href="#lets-encrypt">#</a></h2>
<p>Information about Let&rsquo;s Encrypt can be found on their website here: <a href="https://letsencrypt.org">Let&rsquo;s Encrypt</a>.
Let&rsquo;s Encrypt&rsquo;s client is now called <a href="https://certbot.eff.org/">Certbot</a> which is used to generate the certificates. To get the latest code
you either clone the repository <a href="https://github.com/certbot/certbot">Certbot</a>, or use an auto downloader:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>user@webserver:~$ wget https://dl.eff.org/certbot-auto
</span></span><span style="display:flex;"><span>user@webserver:~$ chmod a+x ./certbot-auto
</span></span><span style="display:flex;"><span>user@webserver:~$ ./certbot-auto --help
</span></span></code></pre></div><p>Either way, I&rsquo;m using the current latest version: <em>v0.11.1</em>.</p>
<h2 id="sudo">Sudo<a hidden class="anchor" aria-hidden="true" href="#sudo">#</a></h2>
<p>This goes without saying, but that these operations will require you to have sudo privileges. I suggest staying in sudo for ease of use.
This means that the commands, I&rsquo;ll write here, will assume you are in <code>sudo su</code> mode thus no <code>sudo</code> prefix will be used.</p>
<h2 id="portforwarding">Portforwarding<a hidden class="anchor" aria-hidden="true" href="#portforwarding">#</a></h2>
<p>In order for your website to work under https this guide assumes that you have port <em>80</em> and <em>443</em> open on your router / network security group.</p>
<h1 id="setup">Setup<a hidden class="anchor" aria-hidden="true" href="#setup">#</a></h1>
<h2 id="single-server-environment">Single Server Environment<a hidden class="anchor" aria-hidden="true" href="#single-server-environment">#</a></h2>
<p>It is possible for haproxy, certbot and your website to run on designated servers. Haproxy&rsquo;s abilities allows to define multiple server sources.
In this guide, my haproxy, website and certbot will all run on the same server; thus redirecting to 127.0.0.1 and local ips. This is more
convenient, because otherwise the haproxy IP would have to be a permanent local/remote ip. Or an automated script would have to be setup which is
notified upon IP change and updates the ip records.</p>
<h2 id="creating-a-certificate">Creating a Certificate<a hidden class="anchor" aria-hidden="true" href="#creating-a-certificate">#</a></h2>
<p>Diving in, the first thing you will require is a certificate. A certificate will allow for encrypted traffic and an authenticated website.
Let&rsquo;s Encrypt which is basically functioning as an independent, free, automated CA (Certificate Authority). Usually,
the process would be to pay a CA to give you a signed, generated certificate for your website, and you would have to set that up with your DNS
provider. Let&rsquo;s Encrypt has that all automated, and free of any charge. Neat.</p>
<h3 id="certbot">Certbot<a hidden class="anchor" aria-hidden="true" href="#certbot">#</a></h3>
<p>So let&rsquo;s get started. Clone the repository into <code>/opt/letsencrypt</code> for further usage.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git clone https://github.com/certbot/certbot /opt/letsencrypt
</span></span></code></pre></div><h3 id="generating-the-certificate">Generating the certificate<a hidden class="anchor" aria-hidden="true" href="#generating-the-certificate">#</a></h3>
<p>Make sure that there is nothing listening on ports: 80, 443. To list usage:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>netstat -nlt | grep <span style="color:#e6db74">&#39;:80\s&#39;</span>
</span></span><span style="display:flex;"><span>netstat -nlt | grep <span style="color:#e6db74">&#39;:443\s&#39;</span>
</span></span></code></pre></div><p>Kill everything that might be on these ports, like apache2 and httpd. These will be used by haproxy and certbot for challenges
and redirecting traffic.</p>
<p>You will be creating a <a href="https://certbot.eff.org/docs/using.html#standalone">standalone</a> certificate. This is the reason we need port 80 and 443 open.
Run certbot by defining the <code>certonly</code> and <code>--standalone</code> flags. For domain validation you are going to use port 443, tls-sni-01 challenge.
The whole command looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cd /opt/letsencrypt
</span></span><span style="display:flex;"><span>./certbot-auto certonly --standalone -d example.com -d www.example.com
</span></span></code></pre></div><p>If this displays something like, &ldquo;couldn&rsquo;t connect&rdquo; you probably still have something running on a port it tries to use. The
generated certificate will be located under <code>/etc/letsencrypt/archive</code> and <code>/etc/letsencrypt/keys</code> while <code>/etc/letsencrypt/live</code> is
a symlink to the latest version of the cert. It&rsquo;s wise to not copy these away from here, since the live link is always updated to the latest version.
Our script will handle haproxy, which requires one cert file made from privkey + fullchain|.pem files.</p>
<h3 id="setup-auto-renewal">Setup Auto-Renewal<a hidden class="anchor" aria-hidden="true" href="#setup-auto-renewal">#</a></h3>
<p>Let&rsquo;s Encrypt issues short lived certificates (90 days). In order to not have to do this procedure every 89 days, certbot provides a nifty
command called <code>renew</code>. However, for the cert to be generated, the port 443 has to be open. This means, haproxy needs to be stopped before
doing the renew. Now, you COULD write a script which stops it, and after the certificate has been renewed, starts it again, but certbot has
you covered again in that department. It provides hooks called <code>pre-hook</code> and <code>post-hook</code>. Thus, all you have to write is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>cd /opt/letsencrypt
</span></span><span style="display:flex;"><span>./certbot-auto renew --pre-hook <span style="color:#e6db74">&#34;service haproxy stop&#34;</span> --post-hook <span style="color:#e6db74">&#34;service haproxy start&#34;</span>
</span></span><span style="display:flex;"><span>DOMAIN<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;example.com&#39;</span> sudo -E bash -c <span style="color:#e6db74">&#39;cat /etc/letsencrypt/live/$DOMAIN/fullchain.pem /etc/letsencrypt/live/$DOMAIN/privkey.pem &gt; /etc/haproxy/certs/$DOMAIN.pem&#39;</span>
</span></span></code></pre></div><p>If you would like to test it first, just include the switch <code>--dry-run</code>.</p>
<p>In case of success you should see something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>root@raspberrypi:/opt/letsencrypt# ./certbot-auto renew --pre-hook <span style="color:#e6db74">&#34;service haproxy stop&#34;</span> --post-hook <span style="color:#e6db74">&#34;service haproxy start&#34;</span> --dry-run
</span></span><span style="display:flex;"><span>Saving debug log to /var/log/letsencrypt/letsencrypt.log
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>-------------------------------------------------------------------------------
</span></span><span style="display:flex;"><span>Processing /etc/letsencrypt/renewal/example.com.conf
</span></span><span style="display:flex;"><span>-------------------------------------------------------------------------------
</span></span><span style="display:flex;"><span>Cert not due <span style="color:#66d9ef">for</span> renewal, but simulating renewal <span style="color:#66d9ef">for</span> dry run
</span></span><span style="display:flex;"><span>Running pre-hook command: service haproxy stop
</span></span><span style="display:flex;"><span>Renewing an existing certificate
</span></span><span style="display:flex;"><span>Performing the following challenges:
</span></span><span style="display:flex;"><span>tls-sni-01 challenge <span style="color:#66d9ef">for</span> example.com
</span></span><span style="display:flex;"><span>Waiting <span style="color:#66d9ef">for</span> verification...
</span></span><span style="display:flex;"><span>Cleaning up challenges
</span></span><span style="display:flex;"><span>Generating key <span style="color:#f92672">(</span><span style="color:#ae81ff">2048</span> bits<span style="color:#f92672">)</span>: /etc/letsencrypt/keys/0002_key-certbot.pem
</span></span><span style="display:flex;"><span>Creating CSR: /etc/letsencrypt/csr/0002_csr-certbot.pem
</span></span><span style="display:flex;"><span>** DRY RUN: simulating <span style="color:#e6db74">&#39;certbot renew&#39;</span> close to cert expiry
</span></span><span style="display:flex;"><span>**          <span style="color:#f92672">(</span>The test certificates below have not been saved.<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Congratulations, all renewals succeeded. The following certs have been renewed:
</span></span><span style="display:flex;"><span>  /etc/letsencrypt/live/example.com/fullchain.pem <span style="color:#f92672">(</span>success<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>** DRY RUN: simulating <span style="color:#e6db74">&#39;certbot renew&#39;</span> close to cert expiry
</span></span><span style="display:flex;"><span>**          <span style="color:#f92672">(</span>The test certificates above have not been saved.<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Running post-hook command: service haproxy start
</span></span></code></pre></div><p>Put this script into a crontab to run every 89 days like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>crontab -e
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Open crontab for edit and paste in this line</span>
</span></span><span style="display:flex;"><span>* * */89 * * /root/renew-cert.sh
</span></span></code></pre></div><p>And you should be all set. Now we move on the configure haproxy to redirect and to use our newly generated certificate.</p>
<h2 id="haproxy-1">Haproxy<a hidden class="anchor" aria-hidden="true" href="#haproxy-1">#</a></h2>
<p>Like I said, haproxy requires a single file certificate in order to encrypt traffic to and from the website. To do this, we need to combine
<code>privkey.pem</code> and <code>fullchain.pem</code>. As of this writing, there are a couple of solutions to automate this via a post hook on renewal. And also,
there is an open ticket with certbot to implement a simpler solution located here: <a href="https://github.com/certbot/certbot/issues/1201">https://github.com/certbot/certbot/issues/1201</a>. I, for now,
have chosen to simply concatenate the two files together with <code>cat</code> like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>DOMAIN<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;example.com&#39;</span> sudo -E bash -c <span style="color:#e6db74">&#39;cat /etc/letsencrypt/live/$DOMAIN/fullchain.pem /etc/letsencrypt/live/$DOMAIN/privkey.pem &gt; /etc/haproxy/certs/$DOMAIN.pem&#39;</span>
</span></span></code></pre></div><p>It will create a combined cert under <code>/etc/haproxy/certs/example.com.pem</code>.</p>
<h3 id="haproxy-configuration">Haproxy configuration<a hidden class="anchor" aria-hidden="true" href="#haproxy-configuration">#</a></h3>
<p>If haproxy happens to be running, stop it with <code>service haproxy stop</code>.</p>
<p>First, save the default configuration file: <code>cp /etc/haproxy/haproxy.cfg /etc/haproxy/haproxy.cfg.old</code>. Now, overwrite the old one with this
new one (comments about what each setting does, are in-lined; they are safe to copy):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>global
</span></span><span style="display:flex;"><span>    daemon
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Set this to your desired maximum connection count.</span>
</span></span><span style="display:flex;"><span>    maxconn <span style="color:#ae81ff">2048</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># https://cbonte.github.io/haproxy-dconv/configuration-1.5.html#3.2-tune.ssl.default-dh-param</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># bit setting for Diffie - Hellman key size.</span>
</span></span><span style="display:flex;"><span>    tune.ssl.default-dh-param <span style="color:#ae81ff">2048</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>defaults
</span></span><span style="display:flex;"><span>    option forwardfor
</span></span><span style="display:flex;"><span>    option http-server-close
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    log     global
</span></span><span style="display:flex;"><span>    mode    http
</span></span><span style="display:flex;"><span>    option  httplog
</span></span><span style="display:flex;"><span>    option  dontlognull
</span></span><span style="display:flex;"><span>    timeout connect <span style="color:#ae81ff">5000</span>
</span></span><span style="display:flex;"><span>    timeout client  <span style="color:#ae81ff">50000</span>
</span></span><span style="display:flex;"><span>    timeout server  <span style="color:#ae81ff">50000</span>
</span></span><span style="display:flex;"><span>    errorfile <span style="color:#ae81ff">400</span> /etc/haproxy/errors/400.http
</span></span><span style="display:flex;"><span>    errorfile <span style="color:#ae81ff">403</span> /etc/haproxy/errors/403.http
</span></span><span style="display:flex;"><span>    errorfile <span style="color:#ae81ff">408</span> /etc/haproxy/errors/408.http
</span></span><span style="display:flex;"><span>    errorfile <span style="color:#ae81ff">500</span> /etc/haproxy/errors/500.http
</span></span><span style="display:flex;"><span>    errorfile <span style="color:#ae81ff">502</span> /etc/haproxy/errors/502.http
</span></span><span style="display:flex;"><span>    errorfile <span style="color:#ae81ff">503</span> /etc/haproxy/errors/503.http
</span></span><span style="display:flex;"><span>    errorfile <span style="color:#ae81ff">504</span> /etc/haproxy/errors/504.http
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># In case it&#39;s a simple http call, we redirect to the basic backend server</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># which in turn, if it isn&#39;t an SSL call, will redirect to HTTPS that is</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># handled by the frontend setting called &#39;www-https&#39;.</span>
</span></span><span style="display:flex;"><span>frontend www-http
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Redirect HTTP to HTTPS</span>
</span></span><span style="display:flex;"><span>    bind *:80
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Adds http header to end of end of the HTTP request</span>
</span></span><span style="display:flex;"><span>    reqadd X-Forwarded-Proto:<span style="color:#ae81ff">\ </span>http
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Sets the default backend to use which is defined below with name &#39;www-backend&#39;</span>
</span></span><span style="display:flex;"><span>    default_backend www-backend
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># If the call is HTTPS we set a challenge to letsencrypt backend which</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># verifies our certificate and than direct traffic to the backend server</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># which is the running hugo site that is served under https if the challenge succeeds.</span>
</span></span><span style="display:flex;"><span>frontend www-https
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Bind 443 with the generated letsencrypt cert.</span>
</span></span><span style="display:flex;"><span>    bind *:443 ssl crt /etc/haproxy/certs/skarlso.com.pem
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># set x-forward to https</span>
</span></span><span style="display:flex;"><span>    reqadd X-Forwarded-Proto:<span style="color:#ae81ff">\ </span>https
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># set X-SSL in case of ssl_fc &lt;- explained below</span>
</span></span><span style="display:flex;"><span>    http-request set-header X-SSL %<span style="color:#f92672">[</span>ssl_fc<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Select a Challenge</span>
</span></span><span style="display:flex;"><span>    acl letsencrypt-acl path_beg /.well-known/acme-challenge/
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Use the challenge backend if the challenge is set</span>
</span></span><span style="display:flex;"><span>    use_backend letsencrypt-backend <span style="color:#66d9ef">if</span> letsencrypt-acl
</span></span><span style="display:flex;"><span>    default_backend www-backend
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>backend www-backend
</span></span><span style="display:flex;"><span>   <span style="color:#75715e"># Redirect with code 301 so the browser understands it is a redirect. If it&#39;s not SSL_FC.</span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e"># ssl_fc: Returns true when the front connection was made via an SSL/TLS transport</span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e"># layer and is locally deciphered. This means it has matched a socket declared</span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e"># with a &#34;bind&#34; line having the &#34;ssl&#34; option.</span>
</span></span><span style="display:flex;"><span>   redirect scheme https code <span style="color:#ae81ff">301</span> <span style="color:#66d9ef">if</span> !<span style="color:#f92672">{</span> ssl_fc <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e"># Server for the running hugo site.</span>
</span></span><span style="display:flex;"><span>   server www-1 192.168.0.17:8080 check
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>backend letsencrypt-backend
</span></span><span style="display:flex;"><span>   <span style="color:#75715e"># Lets encrypt backend server</span>
</span></span><span style="display:flex;"><span>   server letsencrypt 127.0.0.1:54321
</span></span></code></pre></div><p>Save this, and start haproxy with <code>services haproxy start</code>. If you did everything right, it should say nothing.
If, however, there went something wrong with starting the proxy, it usually displays something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Job <span style="color:#66d9ef">for</span> haproxy.service failed. See <span style="color:#e6db74">&#39;systemctl status haproxy.service&#39;</span> and <span style="color:#e6db74">&#39;journalctl -xn&#39;</span> <span style="color:#66d9ef">for</span> details.
</span></span></code></pre></div><p>You can also gather some more information on what went wrong from <code>less /var/log/haproxy.log</code>.</p>
<h1 id="starting-the-server">Starting the Server<a hidden class="anchor" aria-hidden="true" href="#starting-the-server">#</a></h1>
<p>Everything should be ready to go. Hugo has the concept of a baseUrl. Everything that it loads, and tries to access
will be prefixed with it. You can either set it through it&rsquo;s <code>config.yaml</code> file, or from the command line.</p>
<p>To start the server, call this from the site&rsquo;s root folder:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>hugo server --bind<span style="color:#f92672">=</span>192.168.x.x --port<span style="color:#f92672">=</span><span style="color:#ae81ff">8080</span> --baseUrl<span style="color:#f92672">=</span>https://example.com --appendPort<span style="color:#f92672">=</span>false
</span></span></code></pre></div><p>Interesting thing here to note is <code>https</code> and the port. The IP could be 127.0.0.1 as well. I experienced problems though
with not binding to network IP when I was debugging the site from a different laptop on the same network.</p>
<p>Once the server is started, you should be able to open up your website from a different browser, not on your local network,
and see that it has a valid certificate installed. In Chrome you should see a green icon telling you that the cert is valid.</p>
<h1 id="last-words">Last Words<a hidden class="anchor" aria-hidden="true" href="#last-words">#</a></h1>
<p>And that is all. The site should be up and running and the proxy should auto-renew your site&rsquo;s certificate. If you happened to
change DNS or change the server, you&rsquo;ll have to reissue the certificate.</p>
<p>Thanks for reading!
Any questions or trouble setting something up, please feel free to leave a comment.</p>
<p>Cheers,
Gergely.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer><div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hannibalDisqus" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://skarlso.github.io">Ramblings of a cloud engineer</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
