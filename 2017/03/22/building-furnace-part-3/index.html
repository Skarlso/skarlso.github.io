<!DOCTYPE html>
<html lang="en-us">
    <head>
    <meta charset="UTF-8" />

    <meta name="generator" content="Hugo 0.83.1" /><meta name="theme-color" content="#494f5c" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <meta name="format-detection" content="telephone=no, date=no, address=no, email=no" />
    
    <meta http-equiv="Cache-Control" content="no-transform" />
    
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <title>Furnace - The building of an AWS CLI Tool for CloudFormation and CodeDeploy - Part 3 | Ramblings of a cloud engineer</title>

    <link rel="stylesheet" href="/css/meme.min.css" />

    
    
        <script src="/js/meme.min.js"></script>

    

    

    <meta name="author" content="hannibal" /><meta name="description" content="Intro Hi folks.
Previously on this blog: Part 1. Part 2. Part 4.
In this part, Iâ€™m going to talk about the experimental plugin system of Furnace.
Go Experimental Plugins Since Go 1.8 was released, an exciting and new feature was introduced called a Plug-in system. This system works with dynamic libraries built with a special switch to go build. These libraries, .so or .dylib (later), are than loaded and once that succeeds, specific functions can be called from them (symbol resolution)." />

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="" />
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-title" content="Ramblings of a cloud engineer" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="application-name" content="Ramblings of a cloud engineer" />
    <meta name="msapplication-starturl" content="../../../../" />
    <meta name="msapplication-TileColor" content="" />
    <meta name="msapplication-TileImage" content="../../../../icons/mstile-150x150.png" />
    <link rel="manifest" href="/manifest.json" />

    
    

    
    <link rel="canonical" href="https://skarlso.github.io/2017/03/22/building-furnace-part-3/" />
    

    
    

    
    

    
</head>

    <body>
        <div class="container">
            



            
                
                
                
            
            
    <main class="main single" id="main">
    <div class="main-inner">

        

        <article class="content post h-entry" data-align="default" data-type="posts" data-layout="post">

            <h1 class="post-title p-name">Furnace - The building of an AWS CLI Tool for CloudFormation and CodeDeploy - Part 3</h1>

            

            

            

            <div class="post-body e-content">
                <h1 id="intro">Intro</h1>
<p>Hi folks.</p>
<p>Previously on this blog: <a href="http://skarlso.github.io/2017/03/16/building-furnace-part-1/">Part 1</a>. <a href="https://skarlso.github.io/2017/03/19/building-furnace-part-2/">Part 2</a>. <a href="https://skarlso.github.io/2017/04/16/building-furnace-part-4/">Part 4</a>.</p>
<p>In this part, I&rsquo;m going to talk about the experimental plugin system of Furnace.</p>
<h1 id="go-experimental-plugins">Go Experimental Plugins</h1>
<p>Since Go 1.8 was released, an exciting and new feature was introduced called a Plug-in system. This system works with dynamic
libraries built with a special switch to <code>go build</code>. These libraries, <code>.so</code> or <code>.dylib</code> (later), are than loaded and once that
succeeds, specific functions can be called from them (symbol resolution).</p>
<p>We will see how this works. For package information, visit the plugin packages Go doc page
<a href="https://tip.golang.org/pkg/plugin/">here</a>.</p>
<h1 id="furnace-plugins">Furnace Plugins</h1>
<p>So, what does furnace use plugins for? Furnace uses plugins to execute arbitery code in, currently, four given locations / events.</p>
<p>These are: <code>pre_create, post_create, pre_delete, post_delete</code>. These events are called, as their name suggests, before and after
the creation and deletion of the CloudFormation stack. It allows the user to execute some code without having to rebuild the whole
project. It does that by defining a single entry point for the custom code called <code>RunPlugin</code>. Any number of functions can be
implemented, but the plugin MUST provide this single, exported function. Otherwise it will fail and ignore that plugin.</p>
<h2 id="using-plugins">Using Plugins</h2>
<p>It&rsquo;s really easy to implement, and use these plugins. I&rsquo;m not going into the detail of how to load them, because that is done by
Furnace, but only how to write and use them.</p>
<p>To use a plugin, create a go file called: <code>0001_mailer.go</code>. The <code>0001</code> before it will define WHEN it&rsquo;s executed.
Having multiple plugins is completely okay. Execution of order however, depends on the names of the files.</p>
<p>Now, in 0001_mailer.post_create we would have something like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;log&#34;</span>

<span class="c1">// RunPlugin runs the plugin.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">RunPlugin</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;My Awesome Pre Create Plugin.&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>Next step is the build this file to be a plugin library. Note: Right now, this only works on Linux!</p>
<p>To build this file run the following:</p>
<pre><code>go build -buildmode=plugin -o 0001_mailer.pre_create 0001_mailer.go
</code></pre><p>The important part here is the extension of the file specified with <code>-o</code>. It&rsquo;s important because that&rsquo;s how Furnace identifies
what plugins it has to run.</p>
<p>Finally, copy this file to <code>~/.config/go-furnace/plugins</code> and you are all set.</p>
<h2 id="slack-notification-plugin">Slack notification Plugin</h2>
<p>To demonstrate how a plugin could be used is if you need some kind of notification once a Stack is completed. For example, you
might want to send a message to a Slack room. To do this, your plugin would look something like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;os&#34;</span>

	<span class="s">&#34;github.com/nlopes/slack&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">RunPlugin</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">stackname</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getenv</span><span class="p">(</span><span class="s">&#34;FURNACE_STACKNAME&#34;</span><span class="p">)</span>
	<span class="nx">api</span> <span class="o">:=</span> <span class="nx">slack</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;YOUR_TOKEN_HERE&#34;</span><span class="p">)</span>
	<span class="nx">params</span> <span class="o">:=</span> <span class="nx">slack</span><span class="p">.</span><span class="nx">PostMessageParameters</span><span class="p">{}</span>
	<span class="nx">channelID</span><span class="p">,</span> <span class="nx">timestamp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">api</span><span class="p">.</span><span class="nf">PostMessage</span><span class="p">(</span><span class="s">&#34;#general&#34;</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Stack with name &#39;%s&#39; is Done.&#34;</span><span class="p">,</span> <span class="nx">stackname</span><span class="p">),</span> <span class="nx">params</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Message successfully sent to channel %s at %s&#34;</span><span class="p">,</span> <span class="nx">channelID</span><span class="p">,</span> <span class="nx">timestamp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>Currently, Furnace has no ability to share information of the stack with an outside plugin. Thus &lsquo;Done&rsquo; could be anything from
Rollback to Failed to CreateComplete.</p>
<h1 id="closing-words">Closing Words</h1>
<p>That&rsquo;s it for plugins. Thanks very much for reading!
Gergely.</p>

            </div>

            


        </article>

        

        


        


        


        


        


        


        


        


        


    </div>
</main>


            

            

        </div>
        

        















    </body>
</html>
