<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Living with a new Parser for a year | Ramblings of a cloud engineer</title>
<meta name="keywords" content="">
<meta name="description" content="Living with a Parser">
<meta name="author" content="hannibal">
<link rel="canonical" href="https://skarlso.github.io/2019/04/12/living-with-a-parser/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://skarlso.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://skarlso.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://skarlso.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://skarlso.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://skarlso.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Living with a new Parser for a year" />
<meta property="og:description" content="Living with a Parser" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://skarlso.github.io/2019/04/12/living-with-a-parser/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-12T08:01:00+01:00" />
<meta property="article:modified_time" content="2019-04-12T08:01:00+01:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Living with a new Parser for a year"/>
<meta name="twitter:description" content="Living with a Parser"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://skarlso.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Living with a new Parser for a year",
      "item": "https://skarlso.github.io/2019/04/12/living-with-a-parser/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Living with a new Parser for a year",
  "name": "Living with a new Parser for a year",
  "description": "Living with a Parser",
  "keywords": [
    
  ],
  "articleBody": "Hi folks!\nToday’s post is a retrospective. I would like to gather some thoughts about living with the new parser that I wrote for JsonPath.\nAfter a little over a year, some interesting problems surfaced that I thought I’d share for people who also would like to endeavor on this path. Let’s begin.\nPreviously About, two years ago, I took over managing / fixing / improving this ruby gem: Json Parser. It’s a json parser in ruby. Amongst other problems, it used eval in the background to evaluate expressions. It was a security risk to use this gem to its full extent. Something had to be done about that.\nI proceeded to write a semi-language parser which replaced eval that can be found here: Parser. The basic intention was to replace the bare minimum of the eval behavior, and so, it was lacking some serious logic. That got improved as time went by.\nThis is a one year retrospective on living with a self-written parser. Enjoy some of the quirks I faced so you don’t have to.\nAST AST is short for Abstract Syntax Tree. It’s a data structure that is ideal for representing and parsing language syntax. All major lexers use some kind of AST in the background like this old Ruby language parser gem: Whitequark Parser. This parser is used by projects like Rubocop and line coverage reports. It’s usage is not trivial right out of the box. But as you move along you get a firm grasp of true potential.\nI decided to not use that parser a year ago mainly because I thought it’s too much for what I’m trying to accomplish. Maybe I was right, maybe not. I tried to play with Parser recently but it’s none trivial nature and lack of documentation makes it cumbersome to use.\nThe first problems What was then the first trouble that arose after I replaced eval? The parser back then was dumbed down a lot. The bug I faced was a simple infinite loop. The parser works like a lexer. It identifies tokens of certain type and tries to parse them into variables. This lexing had an error.\n- elsif t = scanner.scan(/(\\s+)?'?(\\w+)?[.,]?(\\w+)?'?(\\s+)?/) # @TODO: At this point I should trim somewhere... + elsif t = scanner.scan(/(\\s+)?'?.*'?(\\s+)?/) It was caught by this Json Path:\n$.acceptNewTasks.[?(@.taskEndpoint == \"mps/awesome\")].lastTaskPollTime The culprit was the / character. The tokenizer wasn’t prepared…\nEval would have no problem but the parser is using strict regex-s. This is where an AST would have had more luck.\nNumbers The second problem was the fact that the parser is using strings. Who would have thought that the string 2.0 in fact does not equal to string 2? In Ruby the simplest way of making sure a variable is a Number is by casting the variable to Number or Float. In case it’s not a Number we rescue and move on.\nel = Float(el) rescue el Incidentally this also solved the problem where the json path contained a number but since everything is a string this, also did not equal: '1' == 1.\nSince first the string needed to be a Number.\nSupporting regexes Next came supported operators. The parser only supported the basic operators: \u003c\u003e=. It was missing =~ from this. Which meant people who would use regexes to filter JSON would no longer be able to do so. This was only a tiny modification actually:\nFirst, the operator filter needed to be aware…\n- elsif t = scanner.scan(/(\\s+)?[\u003c\u003e=][=\u003c\u003e]?(\\s+)?/) + elsif t = scanner.scan(/(\\s+)?[\u003c\u003e=][=~]?(\\s+)?/) With that done, we just .to_regexp it with the power of ruby and send would automatically pick it up. And of course test coverage.\nRegression Once the parser was introduced I knew that it would create problems, since eval did many things that the parser could not handle. And they started to arrive slowly. One-by-one.\nBooleans Aka, the story of true == 'true'… Inherently working with strings here makes it difficult to detect when the type boolean is meant or a string which happens to say true. This one was easy to solve as well in the end:\noperand = if t == 'true' true elsif t == 'false' false else operator.to_s.strip == '=~' ? t.to_regexp : t.gsub(%r{^'|'$}, '').strip # We also handle regexp here. end Ignoring the regex part, this was all it needed.\nSyntax Some smaller tid-bits here and there also started to crop up. Things that eval did not mind at all, but my poor Parser couldn’t handle. The regex started out tightly tied. This meant that certain characters weren’t properly detected. Characters like the underscore, or @ or /… All these weren’t picked up by my tight regexp. I had to widen it a bit using .* at certain places.\nNumber formatting Formatting and comparing numbers gave me a lot of headache. I had to detect whether I’m dealing with a number or a string parsed as a number or a number but that was converted into string or a string that happened to be a number. Geez…\nI ended up making it simple like this:\nel = Float(el) rescue el operand = Float(operand) rescue operand Basically everything is a number. Doesn’t matter where it came from, what it was in the past… It’s a number if it can be converted. This, of course, also means that a test like this one fails:\ndef test_number_match json = { channels:[ { elem: 1, }, { elem: '1' } ] }.to_json assert_equal [{ 'elem' =\u003e 1 }], JsonPath.on(json, \"$..channels[?(@.elem == 1)]\") end Both will match… Even though you’d expect it only to match one. Luckily though… this is exactly how http://jsonpath.com/ works as well. An AST would detect that it’s a number type… But since I’m parsing strings here, that would be almost impossible a feat to accomplish in a nice manner.\nGroups And finally, the biggest one… Groups in conditions. A query like this one for example:\n$..book[?((@['author'] == 'Evelyn Waugh' || @['author'] == 'Herman Melville' \u0026\u0026 (@['price'] == 33 || @['price'] == 9))] Something like this was never parsed correctly. Since the parser didn’t understand grouping and order of evaluation. Let’s break it down. How do we get from a monstrous like that one above to something that can be handled? We take it one group at a time.\nParentheses As a first step, we make sure that the parentheses match. It’s possible that someone didn’t pay attention and left out a closing parentheses. Now, there are a couple of way of doing that in Ruby, but I went for the most plain blatant one.\ndef check_parenthesis_count(exp) return true unless exp.include?(\"(\") depth = 0 exp.chars.each do |c| if c == '(' depth += 1 elsif c == ')' depth -= 1 end end depth == 0 end A basic depth counter. We do this first, to avoid parsing an invalid query.\nBreaking it down Next we break down this complex thing into a query that makes more sense to the parser. To do that, we take each group and extract the operation in them and replace it with the value they provide. Meaning a query like the one above essentially should look like this:\n((false || false) \u0026\u0026 (false || true)) Neat. This is handled by this code segment: Parser.\nThe parsing function is called over and over again until there are no parentheses left in the expression. Aka, a single true or false or number remains.\nNow, who can spot an issue with that? The function bool_or_exp is there to return a float or a boolean value. If it returns a float, we still \u0026\u0026= -it together with the result… Thus, if there is a query like this one for example:\n$..book[?(@.length-5 \u0026\u0026 @.type == 'asdf')] This would fail horribly. Which means, asking for a specific index in a json in a grouped expression is not supported at the moment.\nReturn Value The parser doesn’t just return a bool value and call it a day. It also returns indexes like you read above. Indexes in cases when there is a query that returns the location of an item in the node and not if the node contains something or matches some data. For example:\n$..book[(@.length-5)] Returns the length-5-th book.\nOutstanding issues Right now there are two outstanding issues. The one mentioned above, where you can’t nest indexes and true/false notations. And the other is a submitted issue in which it’s described that it’s not possible to use something like this:\n$.phoneNumbers[?(@[0].type == 'home')] Which basically boils down to the fact that Jsonpath can’t handle nested lists like these:\n{ \"phoneNumbers\": [ [{ \"type\" : \"iPhone\", \"number\": \"0123-4567-8888\" }], [{ \"type\" : \"home\", \"number\": \"0123-4567-8910\" }] ] } That isn’t actually the problem of the parser, but Jsonpath itself.\nConclusion Like a good marriage, living with a Parser is a lot of compromise and ironing out edges and working on making it better for both parties involved. I have no doubt that there are more bugs in this code, but I’m trying to keep it concise and clear to read as much as possible.\nI hope this was as fun to read as it was to write.\nThank you for reading,\nGergely.\n",
  "wordCount" : "1533",
  "inLanguage": "en",
  "datePublished": "2019-04-12T08:01:00+01:00",
  "dateModified": "2019-04-12T08:01:00+01:00",
  "author":{
    "@type": "Person",
    "name": "hannibal"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://skarlso.github.io/2019/04/12/living-with-a-parser/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ramblings of a cloud engineer",
    "logo": {
      "@type": "ImageObject",
      "url": "https://skarlso.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://skarlso.github.io" accesskey="h" title="Ramblings of a cloud engineer (Alt + H)">Ramblings of a cloud engineer</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Living with a new Parser for a year
    </h1>
    <div class="post-description">
      Living with a Parser
    </div>
    <div class="post-meta"><span title='2019-04-12 08:01:00 +0100 +0100'>April 12, 2019</span>&nbsp;·&nbsp;hannibal

</div>
  </header> 
  <div class="post-content"><p>Hi folks!</p>
<p><img loading="lazy" src="/img/parser/hi.jpg" alt="hi"  />
</p>
<p>Today’s post is a retrospective. I would like to gather some thoughts about living with the new parser that I wrote for <a href="https://github.com/joshbuddy/jsonpath/">JsonPath</a>.</p>
<p>After a little over a year, some interesting problems surfaced that I thought I’d share for people who also would like to endeavor on this path. Let’s begin.</p>
<h1 id="previously">Previously<a hidden class="anchor" aria-hidden="true" href="#previously">#</a></h1>
<p>About, two years ago, I took over managing / fixing / improving this ruby gem: <a href="https://github.com/joshbuddy/jsonpath">Json Parser</a>. It&rsquo;s a json parser in ruby. Amongst other problems, it used <code>eval</code> in the background to evaluate expressions. It was a security risk to use this gem to its full extent. Something had to be done about that.</p>
<p>I proceeded to write a semi-language parser which replaced eval that can be found here: <a href="https://github.com/joshbuddy/jsonpath/blob/master/lib/jsonpath/parser.rb">Parser</a>. The basic intention was to replace the bare minimum of the eval behavior, and so, it was lacking some serious logic. That got improved as time went by.</p>
<p>This is a one year retrospective on living with a self-written parser. Enjoy some of the quirks I faced so you don&rsquo;t have to.</p>
<h1 id="ast">AST<a hidden class="anchor" aria-hidden="true" href="#ast">#</a></h1>
<p><img loading="lazy" src="/img/parser/ast.jpg" alt="ast"  />
</p>
<p>AST is short for <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a>. It’s a data structure that is ideal for representing and parsing language syntax. All major lexers use some kind of AST in the background like this old Ruby language parser gem: <a href="https://github.com/whitequark/parser">Whitequark Parser</a>. This parser is used by projects like Rubocop and line coverage reports. It&rsquo;s usage is not trivial right out of the box. But as you move along you get a firm grasp of true potential.</p>
<p>I decided to not use that parser a year ago mainly because I thought it’s too much for what I’m trying to accomplish. Maybe I was right, maybe not. I tried to play with Parser recently but it’s none trivial nature and lack of documentation makes it cumbersome to use.</p>
<h1 id="the-first-problems">The first problems<a hidden class="anchor" aria-hidden="true" href="#the-first-problems">#</a></h1>
<p><img loading="lazy" src="/img/parser/infinity.jpg" alt="infinity"  />
</p>
<p>What was then the first trouble that arose after I replaced eval? The parser back then was dumbed down a lot. The bug I faced was a simple infinite loop. The parser works like a lexer. It identifies tokens of certain type and tries to parse them into variables. This lexing had an error.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#f92672">-</span>        <span style="color:#66d9ef">elsif</span> t <span style="color:#f92672">=</span> scanner<span style="color:#f92672">.</span>scan(<span style="color:#e6db74">/(\s+)?&#39;?(\w+)?[.,]?(\w+)?&#39;?(\s+)?/</span>) <span style="color:#75715e"># @TODO: At this point I should trim somewhere...</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>        <span style="color:#66d9ef">elsif</span> t <span style="color:#f92672">=</span> scanner<span style="color:#f92672">.</span>scan(<span style="color:#e6db74">/(\s+)?&#39;?.*&#39;?(\s+)?/</span>)
</span></span></code></pre></div><p>It was caught by this Json Path:</p>
<pre tabindex="0"><code>$.acceptNewTasks.[?(@.taskEndpoint == &#34;mps/awesome&#34;)].lastTaskPollTime
</code></pre><p>The culprit was the <code>/</code> character. The tokenizer wasn’t prepared…</p>
<p>Eval would have no problem but the parser is using strict regex-s. This is where an AST would have had more luck.</p>
<h1 id="numbers">Numbers<a hidden class="anchor" aria-hidden="true" href="#numbers">#</a></h1>
<p><img loading="lazy" src="/img/parser/twins1.jpg" alt="twins1"  />
</p>
<p>The second problem was the fact that the parser is using strings. Who would have thought that the string <code>2.0</code> in fact does not equal to string <code>2</code>? In Ruby the simplest way of making sure a variable is a Number is by casting the variable to Number or Float. In case it’s not a Number we rescue and move on.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>el <span style="color:#f92672">=</span> Float(el) <span style="color:#66d9ef">rescue</span> el
</span></span></code></pre></div><p>Incidentally this also solved the problem where the json path contained a number but since everything is a string this, also did not equal: <code>'1' == 1</code>.</p>
<p>Since first the string needed to be a Number.</p>
<h1 id="supporting-regexes">Supporting regexes<a hidden class="anchor" aria-hidden="true" href="#supporting-regexes">#</a></h1>
<p><img loading="lazy" src="/img/parser/bouncer1.jpg" alt="bouncer1"  />
</p>
<p>Next came supported operators. The parser only supported the basic operators: <code>&lt;&gt;=</code>. It was missing <code>=~</code> from this. Which meant people who would use regexes to filter JSON would no longer be able to do so. This was only a tiny modification actually:</p>
<p>First, the operator filter needed to be aware&hellip;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#f92672">-</span> <span style="color:#66d9ef">elsif</span> t <span style="color:#f92672">=</span> scanner<span style="color:#f92672">.</span>scan(<span style="color:#e6db74">/(\s+)?[&lt;&gt;=][=&lt;&gt;]?(\s+)?/</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span> <span style="color:#66d9ef">elsif</span> t <span style="color:#f92672">=</span> scanner<span style="color:#f92672">.</span>scan(<span style="color:#e6db74">/(\s+)?[&lt;&gt;=][=~]?(\s+)?/</span>)
</span></span></code></pre></div><p>With that done, we just <code>.to_regexp</code> it with the power of ruby and <code>send</code> would automatically pick it up. And of course test coverage.</p>
<h1 id="regression">Regression<a hidden class="anchor" aria-hidden="true" href="#regression">#</a></h1>
<p>Once the parser was introduced I knew that it would create problems, since eval did many things that the parser could not handle. And they started to arrive slowly. One-by-one.</p>
<h2 id="booleans">Booleans<a hidden class="anchor" aria-hidden="true" href="#booleans">#</a></h2>
<p><img loading="lazy" src="/img/parser/twins2.jpg" alt="twins2"  />
</p>
<p>Aka, the story of <code>true == 'true'</code>&hellip; Inherently working with strings here makes it difficult to detect when the type boolean is meant or a string which happens to say <code>true</code>. This one was easy to solve as well in the end:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>operand <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> t <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;true&#39;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elsif</span> t <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;false&#39;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            operator<span style="color:#f92672">.</span>to_s<span style="color:#f92672">.</span>strip <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;=~&#39;</span> ? t<span style="color:#f92672">.</span>to_regexp : t<span style="color:#f92672">.</span>gsub(<span style="color:#e6db74">%r{^&#39;|&#39;$}</span>, <span style="color:#e6db74">&#39;&#39;</span>)<span style="color:#f92672">.</span>strip <span style="color:#75715e"># We also handle regexp here.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>Ignoring the regex part, this was all it needed.</p>
<h2 id="syntax">Syntax<a hidden class="anchor" aria-hidden="true" href="#syntax">#</a></h2>
<p><img loading="lazy" src="/img/parser/bouncer3.jpg" alt="bouncer3"  />
</p>
<p>Some smaller tid-bits here and there also started to crop up. Things that eval did not mind at all, but my poor Parser couldn&rsquo;t handle. The regex started out tightly tied. This meant that certain characters weren&rsquo;t properly detected. Characters like the underscore, or <code>@</code> or <code>/</code>&hellip; All these weren&rsquo;t picked up by my tight regexp. I had to widen it a bit using .* at certain places.</p>
<h2 id="number-formatting">Number formatting<a hidden class="anchor" aria-hidden="true" href="#number-formatting">#</a></h2>
<p>Formatting and comparing numbers gave me a lot of headache. I had to detect whether I’m dealing with a number or a string parsed as a number or a number but that was converted into string or a string that happened to be a number. Geez…</p>
<p>I ended up making it simple like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>el <span style="color:#f92672">=</span> Float(el) <span style="color:#66d9ef">rescue</span> el
</span></span><span style="display:flex;"><span>operand <span style="color:#f92672">=</span> Float(operand) <span style="color:#66d9ef">rescue</span> operand
</span></span></code></pre></div><p>Basically everything is a number. Doesn’t matter where it came from, what it was in the past… It’s a number if it can be converted. This, of course, also means that a test like this one fails:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">test_number_match</span>
</span></span><span style="display:flex;"><span>    json <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">channels</span>:<span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">elem</span>: <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">elem</span>: <span style="color:#e6db74">&#39;1&#39;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>    }<span style="color:#f92672">.</span>to_json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    assert_equal <span style="color:#f92672">[</span>{ <span style="color:#e6db74">&#39;elem&#39;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span> }<span style="color:#f92672">]</span>, <span style="color:#66d9ef">JsonPath</span><span style="color:#f92672">.</span>on(json, <span style="color:#e6db74">&#34;$..channels[?(@.elem == 1)]&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>Both will match… Even though you’d expect it only to match one. Luckily though… this is exactly how <a href="http://jsonpath.com/">http://jsonpath.com/</a> works as well. An AST would detect that it’s a number type… But since I’m parsing strings here, that would be almost impossible a feat to accomplish in a nice manner.</p>
<h2 id="groups">Groups<a hidden class="anchor" aria-hidden="true" href="#groups">#</a></h2>
<p><img loading="lazy" src="/img/parser/bouncer2.jpg" alt="bouncer2"  />
</p>
<p>And finally, the biggest one… Groups in conditions. A query like this one for example:</p>
<pre tabindex="0"><code>$..book[?((@[&#39;author&#39;] == &#39;Evelyn Waugh&#39; || @[&#39;author&#39;] == &#39;Herman Melville&#39; &amp;&amp; (@[&#39;price&#39;] == 33 || @[&#39;price&#39;] == 9))]
</code></pre><p>Something like this was never parsed correctly. Since the parser didn’t understand grouping and order of evaluation. Let’s break it down. How do we get from a monstrous like that one above to something that can be handled? We take it one group at a time.</p>
<h3 id="parentheses">Parentheses<a hidden class="anchor" aria-hidden="true" href="#parentheses">#</a></h3>
<p>As a first step, we make sure that the parentheses match. It’s possible that someone didn’t pay attention and left out a closing parentheses. Now, there are a couple of way of doing that in Ruby, but I went for the most plain blatant one.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">check_parenthesis_count</span>(exp)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span> <span style="color:#66d9ef">unless</span> exp<span style="color:#f92672">.</span>include?(<span style="color:#e6db74">&#34;(&#34;</span>)
</span></span><span style="display:flex;"><span>      depth <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>      exp<span style="color:#f92672">.</span>chars<span style="color:#f92672">.</span>each <span style="color:#66d9ef">do</span> <span style="color:#f92672">|</span>c<span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span>
</span></span><span style="display:flex;"><span>          depth <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elsif</span> c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;)&#39;</span>
</span></span><span style="display:flex;"><span>          depth <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>      depth <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>A basic depth counter. We do this first, to avoid parsing an invalid query.</p>
<h3 id="breaking-it-down">Breaking it down<a hidden class="anchor" aria-hidden="true" href="#breaking-it-down">#</a></h3>
<p>Next we break down this complex thing into a query that makes more sense to the parser. To do that, we take each group and extract the operation in them and replace it with the value they provide. Meaning a query like the one above essentially should look like this:</p>
<pre tabindex="0"><code>((false || false) &amp;&amp; (false || true))
</code></pre><p>Neat. This is handled by this code segment: <a href="https://github.com/joshbuddy/jsonpath/blob/b2525b8e8c596ddf1c8b40982529300b5a98132b/lib/jsonpath/parser.rb#L112">Parser</a>.</p>
<p>The parsing function is called over and over again until there are no parentheses left in the expression. Aka, a single true or false or number remains.</p>
<p>Now, who can spot an issue with that? The function <code>bool_or_exp</code> is there to return a float or a boolean value. If it returns a float, we still &amp;&amp;= -it together with the result&hellip; Thus, if there is a query like this one for example:</p>
<pre tabindex="0"><code>$..book[?(@.length-5 &amp;&amp; @.type == &#39;asdf&#39;)]
</code></pre><p>This would fail horribly. Which means, asking for a specific index in a json in a grouped expression is not supported at the moment.</p>
<h3 id="return-value">Return Value<a hidden class="anchor" aria-hidden="true" href="#return-value">#</a></h3>
<p>The parser doesn’t just return a bool value and call it a day. It also returns indexes like you read above. Indexes in cases when there is a query that returns the location of an item in the node and not if the node contains something or matches some data. For example:</p>
<pre tabindex="0"><code>$..book[(@.length-5)]
</code></pre><p>Returns the length-5-th book.</p>
<h1 id="outstanding-issues">Outstanding issues<a hidden class="anchor" aria-hidden="true" href="#outstanding-issues">#</a></h1>
<p>Right now there are two outstanding issues. The one mentioned above, where you can’t nest indexes and true/false notations. And the other is a submitted issue in which it’s described that it’s not possible to use something like this:</p>
<pre tabindex="0"><code>$.phoneNumbers[?(@[0].type == &#39;home&#39;)]
</code></pre><p>Which basically boils down to the fact that Jsonpath can’t handle nested lists like these:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;phoneNumbers&#34;</span>: [
</span></span><span style="display:flex;"><span>    [{
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;type&#34;</span>  : <span style="color:#e6db74">&#34;iPhone&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;number&#34;</span>: <span style="color:#e6db74">&#34;0123-4567-8888&#34;</span>
</span></span><span style="display:flex;"><span>    }],
</span></span><span style="display:flex;"><span>    [{
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;type&#34;</span>  : <span style="color:#e6db74">&#34;home&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;number&#34;</span>: <span style="color:#e6db74">&#34;0123-4567-8910&#34;</span>
</span></span><span style="display:flex;"><span>    }]
</span></span><span style="display:flex;"><span>  ]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>That isn’t actually the problem of the parser, but Jsonpath itself.</p>
<h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>Like a good marriage, living with a Parser is a lot of compromise and ironing out edges and working on making it better for both parties involved. I have no doubt that there are more bugs in this code, but I&rsquo;m trying to keep it concise and clear to read as much as possible.</p>
<p>I hope this was as fun to read as it was to write.</p>
<p>Thank you for reading,</p>
<p>Gergely.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer><div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hannibalDisqus" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://skarlso.github.io">Ramblings of a cloud engineer</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
