<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Posts &middot; Ramblings of a build engineer</title>

    <meta name="description" content="">

    <meta name="generator" content="Hugo 0.20" />
    <meta name="twitter:card" content="summary">
    
    <meta name="twitter:title" content="Posts &middot; Ramblings of a build engineer">
    <meta name="twitter:description" content="">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Posts &middot; Ramblings of a build engineer">
    <meta property="og:description" content="">

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">

    <link rel="stylesheet" href="https://skarlso.github.io//css/all.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="Ramblings of a build engineer" href="https://skarlso.github.io//index.xml" />
</head>
<body>


<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <hgroup>
            <h1 class="brand-title"><a href="https://skarlso.github.io/">Ramblings of a build engineer</a></h1>
            <h2 class="brand-tagline"></h2>
        </hgroup>

        <nav class="nav">
            <ul class="nav-list">
                
                <li class="nav-item">
                    <a class="pure-button" href="https://twitter.com/Skarlso"><i class="fa fa-twitter"></i> Twitter</a>
                </li>
                
                
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/Skarlso "><i class="fa fa-github-alt"></i> github</a>
                </li>
                
                <li class="nav-item">
                    <a class="pure-button" href="https://skarlso.github.io//index.xml"><i class="fa fa-rss"></i> rss</a>
                </li>
            </ul>
        </nav>
    </div>
</div>


    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                
                <h1 class="content-subhead">16 Apr 2017, 09:23</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://skarlso.github.io/2017/04/16/building-furnace-part-4/" class="post-title">Furnace - The building of an AWS CLI Tool for CloudFormation and CodeDeploy - Part 4</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">hannibal</strong>
                            
                            
                                under 
                                
                                <a class="post-category post-category-Golang" href="https://skarlso.github.io//categories/golang">Golang</a><a class="post-category post-category-AWS" href="https://skarlso.github.io//categories/aws">AWS</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h1 id="intro">Intro</h1>

<p>Hi folks.</p>

<p>Previously on this blog: <a href="http://skarlso.github.io/2017/03/16/building-furnace-part-1/">Part 1</a>. <a href="http://skarlso.github.io/2017/03/16/building-furnace-part-2/">Part 2</a>. <a href="http://skarlso.github.io/2017/03/22/building-furnace-part-3/">Part 3</a>.</p>

<p>In this part we are going to talk about Unit Testing Furnace and how to work some magic with AWS and Go.</p>

<h1 id="mock-stub-fake-dummy-canned-insert-name-here">Mock Stub Fake Dummy Canned <Insert Name Here></h1>

<p>Unit testing in Go usually follows the Dependency Injection model of dealing with Mocks and Stubs.</p>

<p>## DI</p>

<p>Dependency Inject in short is one object supplying the dependencies of another object. In a longer description, it&rsquo;s ideal to be used
for removing the lock on a third party library, like the AWS client. Imaging having code which solely depends on the AWS client. How
would you unit test that code without having to ACTUALLY connect to AWS? You couldn&rsquo;t. Every time you try to test the code it would run
the live code and it would try and connect to AWS and perform the operations it&rsquo;s design to do. The Ruby library with it&rsquo;s metaprogramming
allows you to set the client globally to stub responses, but, alas, this is not the world of Ruby.</p>

<p>Here is where DI comes to the rescue. If you have control over the AWS client on a very high level, and would pass it around as a function
parameter, or create that client in an <code>init()</code> function and have it globally defined; you would be able to implement your own client, and
have your code use that with stubbed responses which your tests need. For example, you would like a CreateApplication call to fail, or you
would like a DescribeStack which returns an aws.Error(&ldquo;StackAlreadyExists&rdquo;).</p>

<p>For this, however, you need the API of the AWS client. Which is provided by AWS.</p>

<h2 id="aws-client-api">AWS Client API</h2>

<p>In order for DI to work, the injected object needs to be of a certain type for us to inject our own. Luckily, AWS provides an Interface for
all of it&rsquo;s clients. Meaning, we can implement our own version for all of the clients, like S3, CloudFormation, CodeDeploy etc.</p>

<p>For each client you want to mock out, an <em>*iface</em> package should be present like this:</p>

<pre><code class="language-go">  &quot;github.com/aws/aws-sdk-go/service/cloudformation/cloudformationiface&quot;
</code></pre>

<p>In this package you find and use the interface like this:</p>

<pre><code class="language-go">type fakeCloudFormationClient struct {
	cloudformationiface.CloudFormationAPI
	err error
}
</code></pre>

<p>And with this, we have our own CloudFormation client. The real code uses the real clients as function parameters, like this:</p>

<pre><code class="language-go">// Execute defines what this command does.
func (c *Create) Execute(opts *commander.CommandHelper) {
	log.Println(&quot;Creating cloud formation session.&quot;)
	sess := session.New(&amp;aws.Config{Region: aws.String(config.REGION)})
	cfClient := cloudformation.New(sess, nil)
	client := CFClient{cfClient}
	createExecute(opts, &amp;client)
}
</code></pre>

<p>We can&rsquo;t test Execute itself, as it&rsquo;s using the real client here (or you could have a global from some library, thus allowing you to tests
even <code>Execute</code> here) but there is very little logic in this function for this very reason. All the logic is in small functions for which
the main starting point and our testing opportunity is, <code>createExecute</code>.</p>

<h2 id="stubbing-calls">Stubbing Calls</h2>

<p>Now, that we have our own client, and with the power of Go&rsquo;s interface embedding as seen above with CloudFormationAPI, we have to only stub
the functions which we are actually using, instead of every function of the given interface. This looks like this:</p>

<pre><code class="language-go">	cfClient := new(CFClient)
	cfClient.Client = &amp;fakeCloudFormationClient{err: nil}
</code></pre>

<p>Where cfClient is a struct like this:</p>

<pre><code class="language-go">// CFClient abstraction for cloudFormation client.
type CFClient struct {
	Client cloudformationiface.CloudFormationAPI
}
</code></pre>

<p>And a stubbed call can than be written as follows:</p>

<pre><code class="language-go">func (fc *fakeCreateCFClient) WaitUntilStackCreateComplete(input *cloudformation.DescribeStacksInput) error {
	return nil
}
</code></pre>

<p>This can range from a very trivial example, like the one above, to intricate ones as well, like this gem:</p>

<pre><code class="language-go">func (fc *fakePushCFClient) ListStackResources(input *cloudformation.ListStackResourcesInput) (*cloudformation.ListStackResourcesOutput, error) {
	if &quot;NoASG&quot; == *input.StackName {
		return &amp;cloudformation.ListStackResourcesOutput{
			StackResourceSummaries: []*cloudformation.StackResourceSummary{
				{
					ResourceType:       aws.String(&quot;NoASG&quot;),
					PhysicalResourceId: aws.String(&quot;arn::whatever&quot;),
				},
			},
		}, fc.err
	}
	return &amp;cloudformation.ListStackResourcesOutput{
		StackResourceSummaries: []*cloudformation.StackResourceSummary{
			{
				ResourceType:       aws.String(&quot;AWS::AutoScaling::AutoScalingGroup&quot;),
				PhysicalResourceId: aws.String(&quot;arn::whatever&quot;),
			},
		},
	}, fc.err
}
</code></pre>

<p>This ListStackResources stub lets us test two scenarios based on the stackname. If the test stackname is &lsquo;NoASG&rsquo; it will return a result
which equals to a result containing no AutoScaling Group. Otherwise, it will return the correct ResourceType for an ASG.</p>

<p>It is a common practice to line up several scenario based stubbed responses in order to test the robustness of your code.</p>

<p>Unfortunately, this also means that your tests will be a bit cluttered with stubs and mock structs and whatnots. For that, I&rsquo;m partially
using a package available struct file in which I&rsquo;m defining most of the mock structs at least. And from there on, the tests will only contain
specific stubs for that particular file. This can be further fine grained by having defaults and than only override in case you need something
else.</p>

<h1 id="testing-fatals">Testing fatals</h1>

<p>Now, the other point which is not really AWS related, but still comes to mind when dealing with Furnace, is testing error scenarios.</p>

<p>Because Furnace is a CLI application it uses Fatals to signal if something is wrong and it doesn&rsquo;t want to continue or recover because, frankly
it can&rsquo;t. If AWS throws an error, that&rsquo;s it. You can retry, but in 90% of the cases, it&rsquo;s usually something that you messed up.</p>

<p>So, how do we test for a fatal or an <code>os.Exit</code>? There are a number of points on that if you do a quick search. You may end up on this talk:
<a href="https://talks.golang.org/2014/testing.slide#23">GoTalk 2014 Testing Slide #23</a>. Which does an interesting thing. It calls the test binary in a
separate process and tests the exit code.</p>

<p>Others, and me as well, will say that you have to have your own logger implemented and use a different logger / os.Exit in your test environment.</p>

<p>Others others will tell you to not to have tests around os.Exit and fatal things, rather return an error and only the main should pop a world
ending event. I leave it up to you which you want to use. Either is fine.</p>

<p>In Furnace, I&rsquo;m using a global logger in my error handling util like this:</p>

<pre><code class="language-go">// HandleFatal handler fatal errors in Furnace.
func HandleFatal(s string, err error) {
	LogFatalf(s, err)
}
</code></pre>

<p>And <code>LogFatalf</code> is an exported variable <code>var LogFatalf = log.Fatalf</code>. Than in a test, I just override this variable with a local anonymous
function:</p>

<pre><code class="language-go">func TestCreateExecuteEmptyStack(t *testing.T) {
	failed := false
	utils.LogFatalf = func(s string, a ...interface{}) {
		failed = true
	}
	config.WAITFREQUENCY = 0
	client := new(CFClient)
	stackname := &quot;EmptyStack&quot;
	client.Client = &amp;fakeCreateCFClient{err: nil, stackname: stackname}
	opts := &amp;commander.CommandHelper{}
	createExecute(opts, client)
	if !failed {
		t.Error(&quot;expected outcome to fail during create&quot;)
	}
}
</code></pre>

<p>It can get even more granular by testing for the error message to make sure that it actually fails at the point we think we are
testing:</p>

<pre><code class="language-go">func TestCreateStackReturnsWithError(t *testing.T) {
	failed := false
	expectedMessage := &quot;failed to create stack&quot;
	var message string
	utils.LogFatalf = func(s string, a ...interface{}) {
		failed = true
		if err, ok := a[0].(error); ok {
			message = err.Error()
		}
	}
	config.WAITFREQUENCY = 0
	client := new(CFClient)
	stackname := &quot;NotEmptyStack&quot;
	client.Client = &amp;fakeCreateCFClient{err: errors.New(expectedMessage), stackname: stackname}
	config := []byte(&quot;{}&quot;)
	create(stackname, config, client)
	if !failed {
		t.Error(&quot;expected outcome to fail&quot;)
	}
	if message != expectedMessage {
		t.Errorf(&quot;message did not equal expected message of '%s', was:%s&quot;, expectedMessage, message)
	}
}
</code></pre>

<h1 id="conclusion">Conclusion</h1>

<p>This is it. That&rsquo;s all it took to write Furnace. I hope you enjoyed reading it as much as I enjoyed writing all these thoughts down.</p>

<p>I hope somebody might learn from my journey and also improve upon it.</p>

<p>Any comments are much appreciated and welcomed. Also, PRs and Issues can be submitted on the GitHub page of <a href="https://github.com/Skarlso/go-furnace">Furnace</a>.</p>

<p>Thank you for reading!
Gergely.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">22 Mar 2017, 12:03</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://skarlso.github.io/2017/03/22/building-furnace-part-3/" class="post-title">Furnace - The building of an AWS CLI Tool for CloudFormation and CodeDeploy - Part 3</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">hannibal</strong>
                            
                            
                                under 
                                
                                <a class="post-category post-category-Golang" href="https://skarlso.github.io//categories/golang">Golang</a><a class="post-category post-category-AWS" href="https://skarlso.github.io//categories/aws">AWS</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h1 id="intro">Intro</h1>

<p>Hi folks.</p>

<p>Previously on this blog: <a href="http://skarlso.github.io/2017/03/16/building-furnace-part-1/">Part 1</a>. <a href="http://skarlso.github.io/2017/03/16/building-furnace-part-2/">Part 2</a>.</p>

<p>In this part, I&rsquo;m going to talk about the experimental plugin system of Furnace.</p>

<h1 id="go-experimental-plugins">Go Experimental Plugins</h1>

<p>Since Go 1.8 was released, an exciting and new feature was introduced called a Plug-in system. This system works with dynamic
libraries built with a special switch to <code>go build</code>. These libraries, <code>.so</code> or <code>.dylib</code> (later), are than loaded and once that
succeeds, specific functions can be called from them (symbol resolution).</p>

<p>We will see how this works. For package information, visit the plugin packages Go doc page
<a href="https://tip.golang.org/pkg/plugin/">here</a>.</p>

<h1 id="furnace-plugins">Furnace Plugins</h1>

<p>So, what does furnace use plugins for? Furnace uses plugins to execute arbitery code in, currently, four given locations / events.</p>

<p>These are: <code>pre_create, post_create, pre_delete, post_delete</code>. These events are called, as their name suggests, before and after
the creation and deletion of the CloudFormation stack. It allows the user to execute some code without having to rebuild the whole
project. It does that by defining a single entry point for the custom code called <code>RunPlugin</code>. Any number of functions can be
implemented, but the plugin MUST provide this single, exported function. Otherwise it will fail and ignore that plugin.</p>

<h2 id="using-plugins">Using Plugins</h2>

<p>It&rsquo;s really easy to implement, and use these plugins. I&rsquo;m not going into the detail of how to load them, because that is done by
Furnace, but only how to write and use them.</p>

<p>To use a plugin, create a go file called: <code>0001_mailer.go</code>. The <code>0001</code> before it will define WHEN it&rsquo;s executed.
Having multiple plugins is completely okay. Execution of order however, depends on the names of the files.</p>

<p>Now, in 0001_mailer.post_create we would have something like this:</p>

<pre><code class="language-go">package main

import &quot;log&quot;

// RunPlugin runs the plugin.
func RunPlugin() {
	log.Println(&quot;My Awesome Pre Create Plugin.&quot;)
}
</code></pre>

<p>Next step is the build this file to be a plugin library. Note: Right now, this only works on Linux!</p>

<p>To build this file run the following:</p>

<pre><code>go build -buildmode=plugin -o 0001_mailer.pre_create 0001_mailer.go
</code></pre>

<p>The important part here is the extension of the file specified with <code>-o</code>. It&rsquo;s important because that&rsquo;s how Furnace identifies
what plugins it has to run.</p>

<p>Finally, copy this file to <code>~/.config/go-furnace/plugins</code> and you are all set.</p>

<h2 id="slack-notification-plugin">Slack notification Plugin</h2>

<p>To demonstrate how a plugin could be used is if you need some kind of notification once a Stack is completed. For example, you
might want to send a message to a Slack room. To do this, your plugin would look something like this:</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;os&quot;

	&quot;github.com/nlopes/slack&quot;
)

func RunPlugin() {
	stackname := os.Getenv(&quot;FURNACE_STACKNAME&quot;)
	api := slack.New(&quot;YOUR_TOKEN_HERE&quot;)
	params := slack.PostMessageParameters{}
	channelID, timestamp, err := api.PostMessage(&quot;#general&quot;, fmt.Sprintf(&quot;Stack with name '%s' is Done.&quot;, stackname), params)
	if err != nil {
		fmt.Printf(&quot;%s\n&quot;, err)
		return
	}
	fmt.Printf(&quot;Message successfully sent to channel %s at %s&quot;, channelID, timestamp)
}
</code></pre>

<p>Currently, Furnace has no ability to share information of the stack with an outside plugin. Thus &lsquo;Done&rsquo; could be anything from
Rollback to Failed to CreateComplete.</p>

<h1 id="closing-words">Closing Words</h1>

<p>That&rsquo;s it for plugins. Thanks very much for reading!
Gergely.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">19 Mar 2017, 12:03</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://skarlso.github.io/2017/03/19/building-furnace-part-2/" class="post-title">Furnace - The building of an AWS CLI Tool for CloudFormation and CodeDeploy - Part 2</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">hannibal</strong>
                            
                            
                                under 
                                
                                <a class="post-category post-category-Golang" href="https://skarlso.github.io//categories/golang">Golang</a><a class="post-category post-category-AWS" href="https://skarlso.github.io//categories/aws">AWS</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h1 id="intro">Intro</h1>

<p>Hi folks.</p>

<p>Previously on this blog: <a href="http://skarlso.github.io/2017/03/16/building-furnace-part-1/">Part 1</a>.</p>

<p>In this part, I&rsquo;m going to talk about the AWS Go SDK and begin do dissect the intricacies of Furnace.</p>

<h1 id="aws-sdk">AWS SDK</h1>

<p>Fortunately, the Go SDK for AWS is quiet verbose and littered with examples of all sorts. But that doesn&rsquo;t make it less complex
and less cryptic at times. I&rsquo;m here to lift some of the early confusions, in hopes that I can help someone to avoid wasting time.</p>

<h2 id="getting-started-and-developers-guide">Getting Started and Developers Guide</h2>

<p>As always, and common from AWS, the documentation is top notch. There is a 141 pages long developer&rsquo;s guide on the SDK containing
a getting started section and an API reference. Go check it out. I&rsquo;ll wait. <a href="http://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/aws-sdk-go-dg.pdf">AWS Go SDK DG PDF</a>. I will only talk about some gotchas and things I encountered, not the basics of the SDK.</p>

<h2 id="aws-string-and-other-types">aws.String and other types</h2>

<p>Something which is immediately visible once we take a look at the API is that everything is a pointer. Now, there are a
tremendous amount of discussions about this, but I&rsquo;m with Amazon. There are various reasons for it, but to list the most prominent
ones:
    - Type completion and compile time type safety.
    - Values for AWS API calls have valid zero values, in addition to being optional, i.e. not being provided at all.
    - Other option, like, empty interfaces with maps, or using zero values, or struct wrappers around every type, made life much
       harder rather than easier or not possible at all.
    - The AWS API is volatile. You never know when something gets to be optional, or required. Pointers made that decision easy.</p>

<p>There are good number of other discussions around this topic, for example: <a href="https://github.com/aws/aws-sdk-go/issues/363">AWS Go GitHub #363</a>.</p>

<p>In order to use primitives, AWS has helper functions like <code>aws.String</code>. Because &amp;&ldquo;asdf&rdquo; is not allowed, you would have to create a
variable and use its address in situations where a string pointer is needed, for example, name of the stack. These primitive helpers will
make in-lining possible. We&rsquo;ll see later that they are used to a great extent. Pointers, however, make life a bit difficult when
constructing Input structs and make for poor aesthetics.</p>

<p>This is something I&rsquo;m returning in a test for stubbing a client call:</p>

<pre><code class="language-go">		return &amp;cloudformation.ListStackResourcesOutput{
			StackResourceSummaries: []*cloudformation.StackResourceSummary{
				{
					ResourceType:       aws.String(&quot;NoASG&quot;),
					PhysicalResourceId: aws.String(&quot;arn::whatever&quot;),
				},
			},
		}
</code></pre>

<p>This doesn&rsquo;t look so appealing, but one gets used to it quickly.</p>

<h2 id="error-handling">Error handling</h2>

<p>Errors also have their own types. An AWS error looks like this:</p>

<pre><code class="language-go">if err != nil {
    if awsErr, ok := err.(awserr.Error); ok {
    }
}
</code></pre>

<p>First, we check if error is nil, than we type check if the error is an AWS error or something different. In the wild, this will
look something like this:</p>

<pre><code class="language-go">	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			if awsErr.Code() != codedeploy.ErrCodeDeploymentGroupAlreadyExistsException {
				log.Println(awsErr.Code())
				return err
			}
			log.Println(&quot;DeploymentGroup already exists. Nothing to do.&quot;)
			return nil
		}
		return err
	}
</code></pre>

<p>If it&rsquo;s an AWS error, we can check further for the error code that it returns in order to identify what to handle, or what to throw
on to the caller to a potential fatal. Here, I&rsquo;m ignoring the AlreadyExistsException because, if it does, we just go on to a next
action.</p>

<h2 id="examples">Examples</h2>

<p>Luckily the API doc is very mature. In most of the cases, they provide an example to an API call. These examples, however, from
time to time provide more confusion than clarity. Take CloudFormation. For me, when I first glanced upon the
description of the API it wasn&rsquo;t immediately clear that the <code>TemplateBody</code> was supposed to be the whole template, and that
the rest of the fields were almost all optional settings. Or provided overrides in special cases.</p>

<p>And since the template is not an ordinary JAML or JSON file, I was looking for something that parses it into that the Struct I
was going to use. After some time, and digging, I realized that I didn&rsquo;t need that, and that I just need to read in the template,
define some extra parameters, and give the TemplateBody the whole of the template. The parameters defined by the CloudFormation
template where extracted for me by <code>ValidateTemplate</code> API call which returned all of them in a convenient
<code>[]*cloudformation.Parameter</code> slice. These things are not described in the document or visible from the examples. I mainly found
them through playing with the API and focused experimentation.</p>

<h2 id="waiters">Waiters</h2>

<p>From other SDK implementations, we got used to Waiters. These handy methods wait for a service to become available or for certain
situations to take in effect, like a Stage being <code>CREATE_COMPLETE</code>. The Go waiters, however, don&rsquo;t allow for callback to be fired,
or for running blocks, like the ruby SDK does. For this, I wrote a handy little waiter for myself, which outputs a spinner to see
that we are currently waiting for something and not frozen in time. This waiter looks like this:</p>

<pre><code class="language-go">// WaitForFunctionWithStatusOutput waits for a function to complete its action.
func WaitForFunctionWithStatusOutput(state string, freq int, f func()) {
	var wg sync.WaitGroup
	wg.Add(1)
	done := make(chan bool)
	go func() {
		defer wg.Done()
		f()
		done &lt;- true
	}()
	go func() {
		counter := 0
		for {
			counter = (counter + 1) % len(Spinners[config.SPINNER])
			fmt.Printf(&quot;\r[%s] Waiting for state: %s&quot;, yellow(string(Spinners[config.SPINNER][counter])), red(state))
			time.Sleep(time.Duration(freq) * time.Second)
			select {
			case &lt;-done:
				fmt.Println()
				break
			default:
			}
		}
	}()

	wg.Wait()
}
</code></pre>

<p>And I&rsquo;m calling it with the following method:</p>

<pre><code class="language-go">	utils.WaitForFunctionWithStatusOutput(&quot;DELETE_COMPLETE&quot;, config.WAITFREQUENCY, func() {
		cfClient.Client.WaitUntilStackDeleteComplete(describeStackInput)
	})
</code></pre>

<p>This would output these lines to the console:</p>

<pre><code class="language-bash">[\] Waiting for state: DELETE_COMPLETE
</code></pre>

<p>The spinner can be configured to be one of the following types:</p>

<pre><code class="language-go">var Spinners = []string{`←↖↑↗→↘↓↙`,
	`▁▃▄▅▆▇█▇▆▅▄▃`,
	`┤┘┴└├┌┬┐`,
	`◰◳◲◱`,
	`◴◷◶◵`,
	`◐◓◑◒`,
	`⣾⣽⣻⢿⡿⣟⣯⣷`,
	`|/-\`}
</code></pre>

<p>Handy.</p>

<p>And with that, let&rsquo;s dive into the basics of Furnace.</p>

<h1 id="furnace">Furnace</h1>

<h2 id="directory-structure-and-packages">Directory Structure and Packages</h2>

<p>Furnace is divided into three main packages.</p>

<h3 id="commands">commands</h3>

<p>Commands package is where the gist of Furnace lies. These commands represent the commands which are used through the CLI. Each
file has the implementation for one command. The structure is devised by this library: <a href="https://github.com/Yitsushi/go-commander">Yitsushi&rsquo;s Command Library</a>.
As of the writing of this post, the following commands are available:
- create - Creates a stack using the CloudFormation template file under ~/.config/go-furnace
- delete - Deletes the created Stack. Doesn&rsquo;t do anything if the stack doesn&rsquo;t exist
- push - Pushes an application to a stack
- status - Displays information about the stack
- delete-application - Deletes the CodeDeploy application and deployment group created by <code>push</code></p>

<p>These commands represent the heart of furnace. I would like to keep these to a minimum, but I do plan on adding more, like
<code>update</code> and <code>rollout</code>. Further details and help messages on these commands can be obtained by running: <code>./furnace help</code> or
<code>./furnace help create</code>.</p>

<pre><code class="language-bash">❯ ./furnace help push
Usage: furnace push appName [-s3]

Push a version of the application to a stack

Examples:
  furnace push
  furnace push appName
  furnace push appName -s3
  furnace push -s3
</code></pre>

<h3 id="config">config</h3>

<p>Contains the configuration loader and some project wide defaults which are as follows:
- Events for the plugin system - <code>pre-create</code>, <code>post-create</code>, <code>pre-delete</code>, <code>post-delete</code>.
- CodeDeploy role name - <code>CodeDeployServiceRole</code>. This is used if none is provided to locate the CodeDeploy IAM role.
- Wait frequency - Is the setting which controls how long the waiter should sleep in between status updates. Default is <code>1s</code>.
- Spinner - Is just the number of the spinner to use.
- Plugin registry - Is a map of functions to run for the above events.</p>

<p>Further more, config loads the CloudFormation template and checks if some necessary settings are present in the environment, exp:
the configuration folder under <code>~/.config/go-furnace</code>.</p>

<h3 id="utils">utils</h3>

<p>These are some helper functions which are used throughout the project. To list them:
- error_handler - Is a simple error handler. I&rsquo;m thinking of refactoring this one to some saner version.
- spinner - Sets up which spinner to use in the waiter function.
- waiter - Contains the verbose waiter introduced above under <a href="##Waiters">Waiters</a>.</p>

<h2 id="configuration-and-environment-variables">Configuration and Environment variables</h2>

<p>Furnace is a Go application, thus it doesn&rsquo;t have the luxury of Ruby or Python where the configuration files are usually bundled
with the app. But, it does have a standard for it. Usually, configurations reside in either of these two locations. Environment
Properties or|and configuration files under a fixed location ( i.e. HOME/.config/app-name ). Furnace employs both.</p>

<p>Settings like, region, stack name, enable plugin system, are under environment properties ( though this can change ), while the
CloudFormation template lives under <code>~/.config/go-furnace/</code>. Lastly it assumes some things, like the Deployment IAM role just
exists under the used AWS account. All these are loaded and handled by the config package described above.</p>

<h2 id="usage">Usage</h2>

<p>A typical scenario for Furnace would be the following:</p>

<ul>
<li>Setup your CloudFormation template or use the one provided. The one provided sets up a highly available and self healing setting
using Auto-Scaling and Load-Balancing with a single application instance. Edit this template to your liking than copy it to
<code>~/.config/go-furnace</code>.</li>
<li>Create the configured stack with <code>./furnace create</code>.</li>
<li>Create will ask for the parameters defined in the template. If defaults are setup, simply hitting enter will use these defaults.
Take note, that the provided template sets up SSH access via a provided key. If that key is not present in CF, you won&rsquo;t be able
to SSH into the created instance.</li>
<li>Once the stack is completed, the application is ready to be pushed. To do this, run: <code>./furnace push</code>. This will locate the
appropriate version of the app from S3 or GitHub and push that version to the instances in the Auto-Scaling group. To all of
them.</li>
</ul>

<h2 id="general-practices-applied-to-the-project">General Practices Applied to the Project</h2>

<h3 id="commands-1">Commands</h3>

<p>For each command the main entry point is the <code>execute</code> function. These functions are usually calling out the small chunks of
distributed methods. Logic was kept to a bare minimum ( probably could be simplified even further ) in the execute functions
mostly for testability and the likes. We will see that in a followup post.</p>

<h3 id="errors">Errors</h3>

<p>Errors are handled immediately and usually through a fatal. If any error occurs than the application is halted. In followup
versions this might become more granular. I.e. don&rsquo;t immediately stop the world, maybe try to recover, or create a Poller or
Re-Tryer, which tries a call again for a configured amount of times.</p>

<h3 id="output-colors">Output colors</h3>

<p>Not that important, but still&hellip; Aesthetics. Displaying data to the console in a nice way gives it some extra flare.</p>

<h3 id="makefile">Makefile</h3>

<p>This project works with a Makefile for various reasons. Later on, once the project might become more complex, a Makefile makes it
really easy to handle different ways of packaging the application. Currently, for example, it provides a <code>linux</code> target which will
make Go build the project for Linux architecture on any other Architecture i.e. cross-compiling.</p>

<p>It also provides an easy way to run unit tests with <code>make test</code> and installing with <code>make &amp;&amp; make install</code>.</p>

<h1 id="closing-words">Closing Words</h1>

<p>That is all for Part 2. Join me in Part 3 where I will talk about the experimental Plugin system that Furnace employs.</p>

<p>Thank you for reading!
Gergely.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">17 Mar 2017, 09:09</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://skarlso.github.io/2017/03/17/test-new-hugo/" class="post-title">Testing new Hugo if posts are generated properly</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">hannibal</strong>
                            
                            
                                under 
                                
                                <a class="post-category post-category-Test" href="https://skarlso.github.io//categories/test">Test</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>Testing.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">16 Mar 2017, 21:49</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://skarlso.github.io/2017/03/16/building-furnace-part-1/" class="post-title">Furnace - The building of an AWS CLI Tool for CloudFormation and CodeDeploy - Part 1</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">hannibal</strong>
                            
                            
                                under 
                                
                                <a class="post-category post-category-Golang" href="https://skarlso.github.io//categories/golang">Golang</a><a class="post-category post-category-AWS" href="https://skarlso.github.io//categories/aws">AWS</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h1 id="building-furnace-part-1">Building Furnace: Part 1</h1>

<h1 id="intro">Intro</h1>

<p>Hi folks.</p>

<p>This is the first part of a 4 part series which talks about the process of building a middlish sized project in Go,
with AWS. Including Unit testing and a experimental plugin feature.</p>

<p>The first part will talk about the AWS services used in brief and will contain a basic description for those who are not familiar
with them. The second part will talk about the Go SDK and the project structure itself, how it can be used, improved, and how it can
help in everyday life. The third part will talk about the experimental plugin system, and finally, we will tackle unit testing AWS
in Go.</p>

<p>Let&rsquo;s begin, shall we?</p>

<h1 id="aws">AWS</h1>

<h2 id="cloudformation">CloudFormation</h2>

<p>If you haven&rsquo;t yet read about, or know off, AWS&rsquo; CloudFormation service, you can either go ahead and read the <a href="https://aws.amazon.com/cloudformation/">Documentation</a>
or read on for a very quick summary. If you are familiar with CF, you should skip ahead to <a href="##CodeDeploy">CodeDeploy</a> section.</p>

<p>CF is a service which bundles together other AWS services (for example: EC2, S3, ELB, ASG, RDS) into one, easily manageable stack.
After a stack has been created, all the resources can be handled as one, located, tagged and used via CF specific console commands.
It&rsquo;s also possible to define any number of parameters, so a stack can actually be very versatile. A parameter can be anything, from
SSH IP restriction to KeyPair names and list of tags to create or in what region the stack will be in.</p>

<p>To describe how these parts fit together, one must use a CloudFormation Template file which is either in JSON or in
YAML format. A simple example looks like this:</p>

<pre><code class="language-yaml">    Parameters:
      KeyName:
        Description: The EC2 Key Pair to allow SSH access to the instance
        Type: AWS::EC2::KeyPair::KeyName
    Resources:
      Ec2Instance:
        Type: AWS::EC2::Instance
        Properties:
          SecurityGroups:
          - Ref: InstanceSecurityGroup
          - MyExistingSecurityGroup
          KeyName:
            Ref: KeyName
          ImageId: ami-7a11e213
      InstanceSecurityGroup:
        Type: AWS::EC2::SecurityGroup
        Properties:
          GroupDescription: Enable SSH access via port 22
          SecurityGroupIngress:
          - IpProtocol: tcp
            FromPort: '22'
            ToPort: '22'
            CidrIp: 0.0.0.0/0
</code></pre>

<p>There are a myriad of these template samples <a href="https://aws.amazon.com/cloudformation/aws-cloudformation-templates/">here</a>.</p>

<p>I&rsquo;m not going to explain this in too much detail. Parameters define the parameters, and resources define all the AWS services which
we would like to configure. Here we can see, that we are creating an EC2 instance with a custom Security Group plus and already
existing security group. ImageId is the AMI which will be used for the EC2 instance. The InstanceSecurityGroup is only defining
some SSH access to the instance.</p>

<p>That is pretty much it. This can become bloated relatively quickly once, VPCs, ELBs, and ASGs come into play. And CloudFormation
templates can also contain simple logical switches, like, conditions, ref for variables, maps and other shenanigans.</p>

<p>For example consider this part in the above example:</p>

<pre><code class="language-yaml">      KeyName:
        Ref: KeyName
</code></pre>

<p>Here, we use the <code>KeyName</code> parameter as a Reference Value which will be interpolated to the real value, or the default one, as the
template gets processed.</p>

<h2 id="codedeploy">CodeDeploy</h2>

<p>If you haven&rsquo;t heard about CodeDeploy yet, please browse the relevant <a href="http://docs.aws.amazon.com/codedeploy/latest/userguide/welcome.html">Documentation</a>
or follow along for a &ldquo;quick&rdquo; description.</p>

<p>CodeDeploy just does what the name says. It deploys code. Any kind of code, as long as the deployment process is described in a
file called <code>appspec.yml</code>. It can be easy as coping a file to a specific location or incredibly complex with builds of various
kinds.</p>

<p>For a simple example look at this configuration:</p>

<pre><code class="language-yaml">    version: 0.0
    os: linux
    files:
      - source: /index.html
        destination: /var/www/html/
      - source: /healthy.html
        destination: /var/www/html/
    hooks:
      BeforeInstall:
        - location: scripts/install_dependencies
          timeout: 300
          runas: root
        - location: scripts/clean_up
          timeout: 300
          runas: root
        - location: scripts/start_server
          timeout: 300
          runas: root
      ApplicationStop:
        - location: scripts/stop_server
          timeout: 300
          runas: root
</code></pre>

<p>CodeDeploy applications have hooks and life-cycle events which can be used to control the deployment process of an like, starting
the WebServer; making sure files are in the right location; copying files, running configuration management software like puppet,
ansible or chef; etc, etc.</p>

<p>What can be done in an <code>appspec.yml</code> file is described here: <a href="http://docs.aws.amazon.com/codedeploy/latest/userguide/app-spec-ref.html">Appspec Reference Documentation</a>.</p>

<p>Deployment happens in one of two ways:</p>

<h3 id="github">GitHub</h3>

<p>If the preferred way to deploy the application is from GitHub a commit hash must be used to identify which &ldquo;version&rdquo; of the
application is to be deployed. For example:</p>

<pre><code class="language-go">    rev = &amp;codedeploy.RevisionLocation{
        GitHubLocation: &amp;codedeploy.GitHubLocation{
            CommitId:   aws.String(&quot;kajdf94j0f9k309klksjdfkj&quot;),
            Repository: aws.String(&quot;Skarlso/furnace-codedeploy-app&quot;),
        },
        RevisionType: aws.String(&quot;GitHub&quot;),
    }
</code></pre>

<p>Commit Id is the hash of the latest release and repository is the full account/repository pointing to the application.</p>

<h3 id="s3">S3</h3>

<p>The second way is to use an S3 bucket. The bucket will contain an archived version of the application with a given extension. I&rsquo;m
saying given extension, because it has to be specified like this (and can be either &lsquo;zip&rsquo;, or &lsquo;tar&rsquo; or &lsquo;tgz&rsquo;):</p>

<pre><code class="language-go">    rev = &amp;codedeploy.RevisionLocation{
        S3Location: &amp;codedeploy.S3Location{
            Bucket:     aws.String(&quot;my_codedeploy_bucket&quot;),
            BundleType: aws.String(&quot;zip&quot;),
            Key:        aws.String(&quot;my_awesome_app&quot;),
            Version:    aws.String(&quot;VersionId&quot;),
        },
        RevisionType: aws.String(&quot;S3&quot;),
    }
</code></pre>

<p>Here, we specify the bucket name, the extension, the name of the file and an optional version id, which can be ignored.</p>

<h3 id="deploying">Deploying</h3>

<p>So how does code deploy get either of the applications to our EC2 instances? It uses an agent which is running on all of the
instances that we create. In order to do this, the agent needs to be present on our instance. For linux this can be achieved with
the following UserData (UserData in CF is the equivalent of a bootsrap script):</p>

<pre><code class="language-bash">    &quot;UserData&quot; : {
        &quot;Fn::Base64&quot; : { &quot;Fn::Join&quot; : [ &quot;\n&quot;, [
            &quot;#!/bin/bash -v&quot;,
            &quot;sudo yum -y update&quot;,
            &quot;sudo yum -y install ruby wget&quot;,
            &quot;cd /home/ec2-user/&quot;,
            &quot;wget https://aws-codedeploy-eu-central-1.s3.amazonaws.com/latest/install&quot;,
            &quot;chmod +x ./install&quot;,
            &quot;sudo ./install auto&quot;,
            &quot;sudo service codedeploy-agent start&quot;,
        ] ] }
    }
</code></pre>

<p>A simple user data configuration in the CloudFormation template will make sure that every instance that we create will have the
CodeDeploy agent running and waiting for instructions. This agent is self updating. Which can cause some trouble if AWS releases a
broken agent. However unlikely, it can happen. Never the less, once installed, it&rsquo;s no longer a concern to be bothered with.</p>

<p>It communications on HTTPS port 443.</p>

<p>CodeDeploy identifies instances which need to be updated according to our preferences, by tagging the EC2 and Auto Scaling groups.
Tagging happens in the CloudFormation template through the AutoScalingGroup settings like this:</p>

<pre><code class="language-json">    &quot;Tags&quot; : [
        {
            &quot;Key&quot; : &quot;fu_stage&quot;,
            &quot;Value&quot; : { &quot;Ref&quot;: &quot;AWS::StackName&quot; },
            &quot;PropagateAtLaunch&quot; : true
        }
    ]
</code></pre>

<p>This will give the EC2 instance a tag called <code>fu_stage</code> with value equaling to the name of the stack. Once this is done, CodeDeploy
looks like this:</p>

<pre><code class="language-go">    params := &amp;codedeploy.CreateDeploymentInput{
        ApplicationName:               aws.String(appName),
        IgnoreApplicationStopFailures: aws.Bool(true),
        DeploymentGroupName:           aws.String(appName + &quot;DeploymentGroup&quot;),
        Revision:                      revisionLocation(),
        TargetInstances: &amp;codedeploy.TargetInstances{
            AutoScalingGroups: []*string{
                aws.String(&quot;AutoScalingGroupPhysicalID&quot;),
            },
            TagFilters: []*codedeploy.EC2TagFilter{
                {
                    Key:   aws.String(&quot;fu_stage&quot;),
                    Type:  aws.String(&quot;KEY_AND_VALUE&quot;),
                    Value: aws.String(config.STACKNAME),
                },
            },
        },
        UpdateOutdatedInstancesOnly: aws.Bool(false),
    }
</code></pre>

<p>CreateDeploymentInput is the entire parameter list that is needed in order to identify instances to deploy code to. We can see
here that it looks for an AutoScalingGroup by Physical Id and the tag labeled <code>fu_stage</code>. Once found, it will use
<code>UpdateOutdatedInstancesOnly</code> to determine if an instance needs to be updated or not. Set to false means, it always updates.</p>

<h1 id="furnace">Furnace</h1>

<p>Where does <a href="https://github.com/Skarlso/go-furnace">Furnace</a> fit in, in all of this? Furnace provides a very easy mechanism to create,
delete and push code to a CloudFormation stack using CodeDeploy, and a couple of environment properties. Furnace <code>create</code> will
create a CloudFormation stack according to the provided template, all the while asking for the parameters defined in it for
flexibility. <code>delete</code> will remove the stack and all affiliated resources except for the created CodeDeploy application. For that,
there is <code>delete-application</code>. <code>status</code> will display information about the stack: Outputs, Parameters, Id, Name, and status.
Something like this:</p>

<pre><code class="language-bash">    2017/03/16 21:14:37 Stack state is:  {
      Capabilities: [&quot;CAPABILITY_IAM&quot;],
      CreationTime: 2017-03-16 20:09:38.036 +0000 UTC,
      DisableRollback: false,
      Outputs: [{
          Description: &quot;URL of the website&quot;,
          OutputKey: &quot;URL&quot;,
          OutputValue: &quot;http://FurnaceSt-ElasticL-ID.eu-central-1.elb.amazonaws.com&quot;
        }],
      Parameters: [
        {
          ParameterKey: &quot;KeyName&quot;,
          ParameterValue: &quot;UserKeyPair&quot;
        },
        {
          ParameterKey: &quot;SSHLocation&quot;,
          ParameterValue: &quot;0.0.0.0/0&quot;
        },
        {
          ParameterKey: &quot;CodeDeployBucket&quot;,
          ParameterValue: &quot;None&quot;
        },
        {
          ParameterKey: &quot;InstanceType&quot;,
          ParameterValue: &quot;t2.nano&quot;
        }
      ],
      StackId: &quot;arn:aws:cloudformation:eu-central-1:9999999999999:stack/FurnaceStack/asdfadsf-adsfa3-432d-a-fdasdf&quot;,
      StackName: &quot;FurnaceStack&quot;,
      StackStatus: &quot;CREATE_COMPLETE&quot;
    }
</code></pre>

<p>( This will later be improved to include created resources as well. )</p>

<p>Once the stack is <code>CREATE_COMPLETE</code> a simple <code>push</code> will deliver our application on each instance in the stack. We will get into
more detail about how these commands are working in Part 2 of this series.</p>

<h1 id="final-words">Final Words</h1>

<p>This is it for now.</p>

<p>Join me next time when I will talk about the AWS Go SDK and its intricacies and we will start to look at the basics of Furnace.</p>

<p>As always,
Thanks for reading!
Gergely.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">03 Mar 2017, 18:20</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://skarlso.github.io/2017/03/03/images-on-old-posts/" class="post-title">Images on older posts</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">hannibal</strong>
                            
                            
                                under 
                                
                                <a class="post-category post-category-rant" href="https://skarlso.github.io//categories/rant">rant</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>Hi folks.</p>

<p>Just a quick headsup, that older posts and images, may have been lost unfortunately, because I made the terrible mistake, when I
migrated over from my old blog, that I forgot to download all the images from the remote host.</p>

<p>For lack of options, I deleted the images. :/ Sorry for the inconvencience!</p>

<p>Gergely.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">15 Feb 2017, 19:20</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://skarlso.github.io/2017/02/15/how-to-https-with-hugo-letsencrypt-haproxy/" class="post-title">How to HTTPS with Hugo LetsEncrypt and HAProxy</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">hannibal</strong>
                            
                            
                                under 
                                
                                <a class="post-category post-category-Hugo" href="https://skarlso.github.io//categories/hugo">Hugo</a><a class="post-category post-category-DevOps" href="https://skarlso.github.io//categories/devops">DevOps</a><a class="post-category post-category-Haproxy" href="https://skarlso.github.io//categories/haproxy">Haproxy</a><a class="post-category post-category-LetsEncrypt" href="https://skarlso.github.io//categories/letsencrypt">LetsEncrypt</a><a class="post-category post-category-HTTPS" href="https://skarlso.github.io//categories/https">HTTPS</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h1 id="intro">Intro</h1>

<p>Hi folks.</p>

<p>Today, I would like to write about how to do HTTPS for a website, without the need to buy a certificate and set it up via your DNS provider. Let&rsquo;s begin.</p>

<h2 id="abstract">Abstract</h2>

<p>What you will achieve by the end of this post:
- Every call to HTTP will be redirected to HTTPS via <a href="https://www.haproxy.com">haproxy</a>.
- HTTPS will be served with Haproxy and <a href="https://letsencrypt.org">LetsEncrypt</a> as the Certificate provider.
- Automatically update the certificate before its expiration.
- No need for IPTable rules to route 8080 to 80.
- Traffic to and from your page will be encrypted.
- This all will cost you nothing.</p>

<p>I will use a static website generator for this called <a href="https://gohugo.io">Hugo</a> which, if you know me, is my favorite generator tool. These instructions
are for haproxy and hugo, if you wish to use apache and nginx for example, you&rsquo;ll have to dig for the corresponding settings for letsencrypt and certbot.</p>

<h1 id="what-you-will-need">What You Will Need</h1>

<h2 id="hugo">Hugo</h2>

<p>You will need hugo, which can be downloaded from here: <a href="https://gohugo.io">Hugo</a>. A simple website will be enough. For themes, you can take a look
at the humongous list located here: <a href="http://themes.gohugo.io/">HugoThemes</a>.</p>

<h2 id="haproxy">Haproxy</h2>

<p>Haproxy can be found here: <a href="https://www.haproxy.com">Haproxy</a>. There are a number of options to install haproxy. I chose a simple
<code>apt-get install haproxy</code>.</p>

<h2 id="let-s-encrypt">Let&rsquo;s Encrypt</h2>

<p>Information about Let&rsquo;s Encrypt can be found on their website here: <a href="https://letsencrypt.org">Let&rsquo;s Encrypt</a>.
Let&rsquo;s Encrypt&rsquo;s client is now called <a href="https://certbot.eff.org/">Certbot</a> which is used to generate the certificates. To get the latest code
you either clone the repository <a href="https://github.com/certbot/certbot">Certbot</a>, or use an auto downloader:</p>

<pre><code class="language-bash">user@webserver:~$ wget https://dl.eff.org/certbot-auto
user@webserver:~$ chmod a+x ./certbot-auto
user@webserver:~$ ./certbot-auto --help
</code></pre>

<p>Either way, I&rsquo;m using the current latest version: <em>v0.11.1</em>.</p>

<h2 id="sudo">Sudo</h2>

<p>This goes without saying, but that these operations will require you to have sudo privileges. I suggest staying in sudo for ease of use.
This means that the commands, I&rsquo;ll write here, will assume you are in <code>sudo su</code> mode thus no <code>sudo</code> prefix will be used.</p>

<h2 id="portforwarding">Portforwarding</h2>

<p>In order for your website to work under https this guide assumes that you have port <em>80</em> and <em>443</em> open on your router / network security group.</p>

<h1 id="setup">Setup</h1>

<h2 id="single-server-environment">Single Server Environment</h2>

<p>It is possible for haproxy, certbot and your website to run on designated servers. Haproxy&rsquo;s abilities allows to define multiple server sources.
In this guide, my haproxy, website and certbot will all run on the same server; thus redirecting to 127.0.0.1 and local ips. This is more
convenient, because otherwise the haproxy IP would have to be a permanent local/remote ip. Or an automated script would have to be setup which is
notified upon IP change and updates the ip records.</p>

<h2 id="creating-a-certificate">Creating a Certificate</h2>

<p>Diving in, the first thing you will require is a certificate. A certificate will allow for encrypted traffic and an authenticated website.
Let&rsquo;s Encrypt which is basically functioning as an independent, free, automated CA (Certificate Authority). Usually,
the process would be to pay a CA to give you a signed, generated certificate for your website, and you would have to set that up with your DNS
provider. Let&rsquo;s Encrypt has that all automated, and free of any charge. Neat.</p>

<h3 id="certbot">Certbot</h3>

<p>So let&rsquo;s get started. Clone the repository into <code>/opt/letsencrypt</code> for further usage.</p>

<pre><code class="language-bash">git clone https://github.com/certbot/certbot /opt/letsencrypt
</code></pre>

<h3 id="generating-the-certificate">Generating the certificate</h3>

<p>Make sure that there is nothing listening on ports: 80, 443. To list usage:</p>

<pre><code class="language-bash">netstat -nlt | grep ':80\s'
netstat -nlt | grep ':443\s'
</code></pre>

<p>Kill everything that might be on these ports, like apache2 and httpd. These will be used by haproxy and certbot for challenges
and redirecting traffic.</p>

<p>You will be creating a <a href="https://certbot.eff.org/docs/using.html#standalone">standalone</a> certificate. This is the reason we need port 80 and 443 open.
Run certbot by defining the <code>certonly</code> and <code>--standalone</code> flags. For domain validation you are going to use port 443, tls-sni-01 challenge.
The whole command looks like this:</p>

<pre><code class="language-bash">cd /opt/letsencrypt
./certbot-auto certonly --standalon -d example.com -d www.example.com
</code></pre>

<p>If this displays something like, &ldquo;couldn&rsquo;t connect&rdquo; you probably still have something running on a port it tries to use. The
generated certificate will be located under <code>/etc/letsencrypt/archive</code> and <code>/etc/letsencrypt/keys</code> while <code>/etc/letsencrypt/live</code> is
a symlink to the latest version of the cert. It&rsquo;s wise to not copy these away from here, since the live link is always updated to the latest version.
Our script will handle haproxy, which requires one cert file made from privkey + fullchain|.pem files.</p>

<h3 id="setup-auto-renewal">Setup Auto-Renewal</h3>

<p>Let&rsquo;s Encrypt issues short lived certificates (90 days). In order to not have to do this procedure every 89 days, certbot provides a nifty
command called <code>renew</code>. However, for the cert to be generated, the port 443 has to be open. This means, haproxy needs to be stopped before
doing the renew. Now, you COULD write a script which stops it, and after the certificate has been renewed, starts it again, but certbot has
you covered again in that department. It provides hooks called <code>pre-hook</code> and <code>post-hook</code>. Thus, all you have to write is the following:</p>

<pre><code class="language-bash">#!/bin/bash

cd /opt/letsencrypt
./certbot-auto renew --pre-hook &quot;service haproxy stop&quot; --post-hook &quot;service haproxy start&quot;
DOMAIN='example.com' sudo -E bash -c 'cat /etc/letsencrypt/live/$DOMAIN/fullchain.pem /etc/letsencrypt/live/$DOMAIN/privkey.pem &gt; /etc/haproxy/certs/$DOMAIN.pem'
</code></pre>

<p>If you would like to test it first, just include the switch <code>--dry-run</code>.</p>

<p>In case of success you should see something like this:</p>

<pre><code class="language-bash">root@raspberrypi:/opt/letsencrypt# ./certbot-auto renew --pre-hook &quot;service haproxy stop&quot; --post-hook &quot;service haproxy start&quot; --dry-run
Saving debug log to /var/log/letsencrypt/letsencrypt.log

-------------------------------------------------------------------------------
Processing /etc/letsencrypt/renewal/example.com.conf
-------------------------------------------------------------------------------
Cert not due for renewal, but simulating renewal for dry run
Running pre-hook command: service haproxy stop
Renewing an existing certificate
Performing the following challenges:
tls-sni-01 challenge for example.com
Waiting for verification...
Cleaning up challenges
Generating key (2048 bits): /etc/letsencrypt/keys/0002_key-certbot.pem
Creating CSR: /etc/letsencrypt/csr/0002_csr-certbot.pem
** DRY RUN: simulating 'certbot renew' close to cert expiry
**          (The test certificates below have not been saved.)

Congratulations, all renewals succeeded. The following certs have been renewed:
  /etc/letsencrypt/live/example.com/fullchain.pem (success)
** DRY RUN: simulating 'certbot renew' close to cert expiry
**          (The test certificates above have not been saved.)
Running post-hook command: service haproxy start
</code></pre>

<p>Put this script into a crontab to run every 89 days like this:</p>

<pre><code class="language-bash">crontab -e
# Open crontab for edit and paste in this line
* * */89 * * /root/renew-cert.sh
</code></pre>

<p>And you should be all set. Now we move on the configure haproxy to redirect and to use our newly generated certificate.</p>

<h2 id="haproxy-1">Haproxy</h2>

<p>Like I said, haproxy requires a single file certificate in order to encrypt traffic to and from the website. To do this, we need to combine
<code>privkey.pem</code> and <code>fullchain.pem</code>. As of this writing, there are a couple of solutions to automate this via a post hook on renewal. And also,
there is an open ticket with certbot to implement a simpler solution located here: <a href="https://github.com/certbot/certbot/issues/1201">https://github.com/certbot/certbot/issues/1201</a>. I, for now,
have chosen to simply concatenate the two files together with <code>cat</code> like this:</p>

<pre><code class="language-bash">DOMAIN='example.com' sudo -E bash -c 'cat /etc/letsencrypt/live/$DOMAIN/fullchain.pem /etc/letsencrypt/live/$DOMAIN/privkey.pem &gt; /etc/haproxy/certs/$DOMAIN.pem'
</code></pre>

<p>It will create a combined cert under <code>/etc/haproxy/certs/example.com.pem</code>.</p>

<h3 id="haproxy-configuration">Haproxy configuration</h3>

<p>If haproxy happens to be running, stop it with <code>service haproxy stop</code>.</p>

<p>First, save the default configuration file: <code>cp /etc/haproxy/haproxy.cfg /etc/haproxy/haproxy.cfg.old</code>. Now, overwrite the old one with this
new one (comments about what each setting does, are in-lined; they are safe to copy):</p>

<pre><code class="language-bash">global
    daemon
    # Set this to your desired maximum connection count.
    maxconn 2048
    # https://cbonte.github.io/haproxy-dconv/configuration-1.5.html#3.2-tune.ssl.default-dh-param
    # bit setting for Diffie - Hellman key size.
    tune.ssl.default-dh-param 2048

defaults
    option forwardfor
    option http-server-close

    log     global
    mode    http
    option  httplog
    option  dontlognull
    timeout connect 5000
    timeout client  50000
    timeout server  50000
    errorfile 400 /etc/haproxy/errors/400.http
    errorfile 403 /etc/haproxy/errors/403.http
    errorfile 408 /etc/haproxy/errors/408.http
    errorfile 500 /etc/haproxy/errors/500.http
    errorfile 502 /etc/haproxy/errors/502.http
    errorfile 503 /etc/haproxy/errors/503.http
    errorfile 504 /etc/haproxy/errors/504.http

# In case it's a simple http call, we redirect to the basic backend server
# which in turn, if it isn't an SSL call, will redirect to HTTPS that is
# handled by the frontend setting called 'www-https'.
frontend www-http
    # Redirect HTTP to HTTPS
    bind *:80
    # Adds http header to end of end of the HTTP request
    reqadd X-Forwarded-Proto:\ http
    # Sets the default backend to use which is defined below with name 'www-backend'
    default_backend www-backend

# If the call is HTTPS we set a challenge to letsencrypt backend which
# verifies our certificate and than direct traffic to the backend server
# which is the running hugo site that is served under https if the challenge succeeds.
frontend www-https
    # Bind 443 with the generated letsencrypt cert.
    bind *:443 ssl crt /etc/haproxy/certs/skarlso.com.pem
    # set x-forward to https
    reqadd X-Forwarded-Proto:\ https
    # set X-SSL in case of ssl_fc &lt;- explained below
    http-request set-header X-SSL %[ssl_fc]
    # Select a Challenge
    acl letsencrypt-acl path_beg /.well-known/acme-challenge/
    # Use the challenge backend if the challenge is set
    use_backend letsencrypt-backend if letsencrypt-acl
    default_backend www-backend

backend www-backend
   # Redirect with code 301 so the browser understands it is a redirect. If it's not SSL_FC.
   # ssl_fc: Returns true when the front connection was made via an SSL/TLS transport
   # layer and is locally deciphered. This means it has matched a socket declared
   # with a &quot;bind&quot; line having the &quot;ssl&quot; option.
   redirect scheme https code 301 if !{ ssl_fc }
   # Server for the running hugo site.
   server www-1 192.168.0.17:8080 check

backend letsencrypt-backend
   # Lets encrypt backend server
   server letsencrypt 127.0.0.1:54321
</code></pre>

<p>Save this, and start haproxy with <code>services haproxy start</code>. If you did everything right, it should say nothing.
If, however, there went something wrong with starting the proxy, it usually displays something like this:</p>

<pre><code class="language-bash">Job for haproxy.service failed. See 'systemctl status haproxy.service' and 'journalctl -xn' for details.
</code></pre>

<p>You can also gather some more information on what went wrong from <code>less /var/log/haproxy.log</code>.</p>

<h1 id="starting-the-server">Starting the Server</h1>

<p>Everything should be ready to go. Hugo has the concept of a baseUrl. Everything that it loads, and tries to access
will be prefixed with it. You can either set it through it&rsquo;s <code>config.yaml</code> file, or from the command line.</p>

<p>To start the server, call this from the site&rsquo;s root folder:</p>

<pre><code class="language-bash">hugo server --bind=192.168.x.x --port=8080 --baseUrl=https://example.com --appendPort=false
</code></pre>

<p>Interesting thing here to note is <code>https</code> and the port. The IP could be 127.0.0.1 as well. I experienced problems though
with not binding to network IP when I was debugging the site from a different laptop on the same network.</p>

<p>Once the server is started, you should be able to open up your website from a different browser, not on your local network,
and see that it has a valid certificate installed. In Chrome you should see a green icon telling you that the cert is valid.</p>

<h1 id="last-words">Last Words</h1>

<p>And that is all. The site should be up and running and the proxy should auto-renew your site&rsquo;s certificate. If you happened to
change DNS or change the server, you&rsquo;ll have to reissue the certificate.</p>

<p>Thanks for reading!
Any questions or trouble setting something up, please feel free to leave a comment.</p>

<p>Cheers,
Gergely.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">02 Nov 2016, 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://skarlso.github.io/2016/11/02/google-signin-with-go-part2/" class="post-title">How to do Google Sign-In with Go - Part 2</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">hannibal</strong>
                            
                            
                                under 
                                
                                <a class="post-category post-category-Go" href="https://skarlso.github.io//categories/go">Go</a><a class="post-category post-category-Golang" href="https://skarlso.github.io//categories/golang">Golang</a><a class="post-category post-category-Web" href="https://skarlso.github.io//categories/web">Web</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h1 id="intro">Intro</h1>

<p>Hi Folks.</p>

<p>This is a follow up on my previous post about Google Sign-In. In this post we will discover what to do with the information retrieved in the first encounter, which you can find here: <a href="http://skarlso.github.io/2016/06/12/google-signin-with-go/">Google Sign-In Part 1</a>.</p>

<h1 id="forewords">Forewords</h1>

<h2 id="the-project">The Project</h2>

<p>Everything I did in the first post, and that I&rsquo;m going to do in this example, can be found in this project: <a href="https://github.com/Skarlso/google-oauth-go-sample">Google-OAuth-Go-Sample</a>.</p>

<p>Just to recap, we left off previously on the point where we successfully obtained information about the user, with a secure token and a session initiated with them. Google nicely enough provided us with some details which we can use. This information was in JSON format and looked something like this:</p>

<pre><code class="language-json">{
  &quot;sub&quot;: &quot;1111111111111111111111&quot;,
  &quot;name&quot;: &quot;Your Name&quot;,
  &quot;given_name&quot;: &quot;Your&quot;,
  &quot;family_name&quot;: &quot;Name&quot;,
  &quot;profile&quot;: &quot;https://plus.google.com/1111111111111111111111&quot;,
  &quot;picture&quot;: &quot;https://lh3.googleusercontent.com/asdfadsf/AAAAAAAAAAI/Aasdfads/Xasdfasdfs/photo.jpg&quot;,
  &quot;email&quot;: &quot;your@gmail.com&quot;,
  &quot;email_verified&quot;: true,
  &quot;gender&quot;: &quot;male&quot;
}
</code></pre>

<p>In my example, to keep things simple, I will use the email address since that has to be unique in the land of Google. You could assign an ID to the user, and you could complicate things even further, but my goal is not to write an academic paper about cryptography here.</p>

<h1 id="implementation">Implementation</h1>

<h2 id="making-something-useful-out-of-the-data">Making something useful out of the data</h2>

<p>In order for the app to recognise a user it must save some data about the user. I&rsquo;m doing that in MongoDB right now, but that could be any form of persistence layer, like, SQLite3, BoltDB, PostgresDB, etc.</p>

<h3 id="after-successful-user-authorization">After successful user authorization</h3>

<p>Once the user used google to provide us with sufficient information about him/herself, we can retrieve data about that user from our records. The data could be anything that is linked to our unique identifier like: Character Profile, Player Information, Status, Last Logged-In, etcetc. For this, there are two things that need to happen after authorization: Save/Load user information and initiate a session.</p>

<p>The session can be in the form of a cookie, or a Redis storage, or URL re-writing. I&rsquo;m choosing a cookie here.</p>

<h3 id="save-load-user-information">Save / Load user information</h3>

<p>All I&rsquo;m doing is a simple, <em>returning / new</em> user handling. The concept is simple. If the email isn&rsquo;t saved, we save it. If it&rsquo;s saved, we set a logic to our page render to greet the returning user.</p>

<p>In the <code>AuthHandler</code> I&rsquo;m doing the following:</p>

<pre><code class="language-go">...
seen := false
db := database.MongoDBConnection{}
if _, mongoErr := db.LoadUser(u.Email); mongoErr == nil {
    seen = true
} else {
    err = db.SaveUser(&amp;u)
    if err != nil {
        log.Println(err)
        c.HTML(http.StatusBadRequest, &quot;error.tmpl&quot;, gin.H{&quot;message&quot;: &quot;Error while saving user. Please try again.&quot;})
        return
    }
}
c.HTML(http.StatusOK, &quot;battle.tmpl&quot;, gin.H{&quot;email&quot;: u.Email, &quot;seen&quot;: seen})
...
</code></pre>

<p>Let&rsquo;s break this down a bit. There is a db connection here, which calls a function that either returns an error, or it doesn&rsquo;t. If it doesn&rsquo;t, that means we have our user. If it does, it means we have to save the user. This is a very simple case (disregard for now, that the error could be something else as well (If you can&rsquo;t get passed that, you could type check the error or check if the returned record contains the requested user information instead of checking for an error.)).</p>

<p>The template is than rendered depending on the <code>seen</code> boolean like this:</p>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;link rel=&quot;icon&quot;
      type=&quot;image/png&quot;
      href=&quot;/img/favicon.ico&quot; /&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/main.css&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    {{if .seen}}
        &lt;h1&gt;Welcome back to the battlefield '{{ .email }}'.&lt;/h1&gt;
    {{else}}
        &lt;h1&gt;Welcome to the battlefield '{{ .email }}'.&lt;/h1&gt;
    {{end}}
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>You can see here, that if <code>seen</code> is <em>true</em> the header message will say: &ldquo;Welcome <em>back</em>&hellip;&ldquo;.</p>

<h3 id="initiating-a-session">Initiating a session</h3>

<p>When the user is successfully authenticated, we activate a session so that the user can access pages that require authorization. Here, I have to mention that I&rsquo;m using <a href="https://github.com/gin-gonic/gin">Gin</a>, so restricted end-points are made with groups which require a middleware.</p>

<p>As I mentioned earlier, I&rsquo;m using cookies as session handlers. For this, a new session store has to be created with some secure token. This is achieved with the following code fragments ( note that I&rsquo;m using a Gin session middleware which uses gorilla&rsquo;s session handler located here: <a href="https://github.com/gin-gonic/contrib">Gin-Gonic(Sessions)</a>):</p>

<pre><code class="language-go">// RandToken in handlers.go:
// RandToken generates a random @l length token.
func RandToken(l int) string {
	b := make([]byte, l)
	rand.Read(b)
	return base64.StdEncoding.EncodeToString(b)
}

// quest.go:
// Create the cookie store in main.go.
store := sessions.NewCookieStore([]byte(handlers.RandToken(64)))
store.Options(sessions.Options{
    Path:   &quot;/&quot;,
    MaxAge: 86400 * 7,
})

// using the cookie store:
router.Use(sessions.Sessions(&quot;goquestsession&quot;, store))
</code></pre>

<p>After this <code>gin.Context</code> lets us access this session store by doing <code>session := sessions.Default(c)</code>. Now, create a session variable called <code>user-id</code> like this:</p>

<pre><code class="language-go">session.Set(&quot;user-id&quot;, u.Email)
err = session.Save()
if err != nil {
    log.Println(err)
    c.HTML(http.StatusBadRequest, &quot;error.tmpl&quot;, gin.H{&quot;message&quot;: &quot;Error while saving session. Please try again.&quot;})
    return
}
</code></pre>

<p>Don&rsquo;t forget to <code>save</code> the session. ;) That is it. If I restart the server, the cookie won&rsquo;t be usable any longer, since it will generate a new token for the cookie store. The user will have to log in again. <strong>Note</strong>: It might be that you&rsquo;ll see something like this, from <code>session</code>: <code>[sessions] ERROR! securecookie: the value is not valid</code>. You can ignore this error.</p>

<h2 id="restricting-access-to-certain-end-points-with-the-auth-middleware">Restricting access to certain end-points with the auth Middleware™</h2>

<p>Now, that our session is alive, we can use it to restrict access to some part of the application. With Gin, it looks like this:</p>

<pre><code class="language-go">authorized := router.Group(&quot;/battle&quot;)
authorized.Use(middleware.AuthorizeRequest())
{
    authorized.GET(&quot;/field&quot;, handlers.FieldHandler)
}
</code></pre>

<p>This creates a grouping of end-points under <code>/battle</code>. Which means, everything under <code>/battle</code> will only be accessible if the middleware passed to the <code>Use</code> function calls the next handler in the chain. If it aborts the call chain, the end-point will not be accessible. My middleware is pretty simple, but it gets the job done:</p>

<pre><code class="language-go">// AuthorizeRequest is used to authorize a request for a certain end-point group.
func AuthorizeRequest() gin.HandlerFunc {
	return func(c *gin.Context) {
		session := sessions.Default(c)
		v := session.Get(&quot;user-id&quot;)
		if v == nil {
			c.HTML(http.StatusUnauthorized, &quot;error.tmpl&quot;, gin.H{&quot;message&quot;: &quot;Please log in.&quot;})
			c.Abort()
		}
		c.Next()
	}
}
</code></pre>

<p>Note, that this only check if <code>user-id</code> is set or not. That&rsquo;s certainly not enough for a secure application. Its only supposed to be a simple example of the mechanics of the auth middleware. Also, the session usually contains more than one parameter. It&rsquo;s more likely that it contains several variables, which describe the user including a state for CORS protection. For CORS I&rsquo;d recommend using <a href="https://github.com/rs/cors">rs/cors</a>.</p>

<p>If you would try to access <a href="http://127.0.0.1:9090/battle/field">http://127.0.0.1:9090/battle/field</a> without logging in, you&rsquo;d be redirected to an <code>error.tmpl</code> with the message: <strong>Please log in.</strong>.</p>

<h1 id="final-words">Final Words</h1>

<p>That&rsquo;s pretty much it. Important parts are:</p>

<ul>
<li>Saving the right information</li>
<li>Secure cookie store</li>
<li>CORS for sessions</li>
<li>Checks of the users details in the cookie</li>
<li>Authorised end-points</li>
<li>Session handling</li>
</ul>

<p>Any questions, remarks, ideas, are very welcomed in the comment section. There are plenty of very nice Go frameworks which do Google OAuth2 out of the box. I recommend using them, as they save you a lot of legwork.</p>

<p>Thank you for reading!
Gergely.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">06 Oct 2016, 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://skarlso.github.io/2016/10/06/rscrap-ruby-scraping-with-cronjob-scripts/" class="post-title">RScrap scraper</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">hannibal</strong>
                            
                            
                                under 
                                
                                <a class="post-category post-category-Ruby" href="https://skarlso.github.io//categories/ruby">Ruby</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h1 id="intro">Intro</h1>

<p>Hey folks.</p>

<p>So, there is this project called <a href="https://github.com/cantino/huginn">Huginn</a> which I absolutely love.</p>

<p>But the thing is, that for a couple of scrappers ( at least for me ), I don&rsquo;t want to spin up a whole rails app.</p>

<p>Hence, I&rsquo;ve come up with <a href="https://github.com/Skarlso/rscrap">RScrap</a>. Which is a bunch of Ruby scripts run as cron jobs on a raspberry pi. And because I dislike emails as well, and most of the time, I don&rsquo;t read them, I opted for a nicer solution. Enter the world of <a href="https://telegram.org">Telegram</a>. They provide you with the ability to create bots. You basically get an API key, and than using that key, you can send private messages, or even create an interactive bot which you can send messages too.</p>

<p>In my simple example, I&rsquo;m using it to send private messages to myself, but I could just as well, make it interactive and than tell it to run one of the scripts.</p>

<h1 id="the-code">The Code</h1>

<p>Let&rsquo;s take a look at what we got.</p>

<h2 id="the-main-scraper">The main scraper</h2>

<p>The main scraper, is simply bunch of convenience methods that wrap handling and working with the database and the telegram bot. That&rsquo;s all. It&rsquo;s very simple. Very short. The Telegram part is just this bit:</p>

<pre><code class="language-ruby">def send_message(text)
  Telegram::Bot::Client.run(@token) do |bot|
    bot.api.send_message(chat_id: @id, text: text)
  end
end
</code></pre>

<p>Straightforward. Creating an interactive bot, would look something like this:</p>

<pre><code class="language-ruby">#!/usr/bin/env ruby
require 'telegram/bot'

token = 'YOUR_TELEGRAM_BOT_API_TOKEN'

Telegram::Bot::Client.run(token) do |bot|
  bot.listen do |message|
    case message.text
    when '/start'
      bot.api.send_message(chat_id: message.chat.id, text: &quot;Hello, #{message.from.first_name}&quot;)
    when '/stop'
      bot.api.send_message(chat_id: message.chat.id, text: &quot;Bye, #{message.from.first_name}&quot;)
    end
  end
end
</code></pre>

<p>Basically, it will listen, and than you can send it messages and based on the parsed <code>message.text</code> you can define functions to call. For example, for rscrap I could define something like <code>run_script(script)</code>. And the command would be: <code>/run reddit</code>. Which will execute my reddit script. The possibilities are endless.</p>

<h2 id="the-scripts">The scripts</h2>

<p>The scripts use nokogiri to parse a web page, and than return a URL which will be sent by the TelegramBot. They are also saved in the database so that when a new comic strip comes out, I know that it&rsquo;s new. For reddit, I&rsquo;m saving a timestamp as well, and I collect everything after that timestamp through the reddit API as JSON, and send it as a bundled message with shortified links to the posts using bit.ly.</p>

<p>The scraping is most of the times the same for every comic. Thus, there is a helper method for it. The script itself, is very short. For example, lets look at gunnerkrigg court.</p>

<pre><code class="language-ruby">require_relative '../rscrap'
require 'nokogiri'
require 'open-uri'

url = 'http://www.gunnerkrigg.com'
scrap = Rscrap.new
page = Nokogiri::HTML(open(url))
comic_id = page.css('img.comic_image')[0].select { |e| e if e[0] == 'src' }[0][1]
new_comic = &quot;#{url}#{comic_id}&quot;
scrap.send_new_comic(url, new_comic)
</code></pre>

<p>The interesting part of it is this bit: <code>comic_id = page.css('img.comic_image')[0].select { |e| e if e[0] == 'src' }[0][1]</code>. It extracts the URL for the comic image, and stores it as an &ldquo;id&rdquo; of the comic. This than, is sent as a message which Telegram will embed. There is no need to visit the web page, the image is in your feed and you can view it directly. Just like an RSS ready.</p>

<h2 id="cron">Cron</h2>

<p>These scripts are best used in a cron job. The comics are usually running with a daily frequency, where as the reddit gatherer is running with an hour frequency. Basically, I&rsquo;m receiving updates on an hourly basis if there are new posts by then. Running ruby from cron was a bit tricky. I&rsquo;m using bundler for the environment, and came up with this:</p>

<pre><code class="language-bash">0 6-23 * * * /bin/bash -l -c 'cd /home/&lt;youruser&gt;/rubyproj/rscrap &amp;&amp; bundle exec ruby scripts/reddit.rb'
0 8,22 * * * /bin/bash -l -c 'cd /home/&lt;youruser&gt;/rubyproj/rscrap &amp;&amp; bundle exec ruby scripts/gunnerkrigg.rb'
0 8,22 * * * /bin/bash -l -c 'cd /home/&lt;youruser&gt;/rubyproj/rscrap &amp;&amp; bundle exec ruby scripts/aws_blog.rb'
0 5,23 * * * /bin/bash -l -c 'cd /home/&lt;youruser&gt;/rubyproj/rscrap &amp;&amp; bundle exec ruby scripts/goblinscomic.rb'
0 6,20 * * * /bin/bash -l -c 'cd /home/&lt;youruser&gt;/rubyproj/rscrap &amp;&amp; bundle exec ruby scripts/xkcd.rb'
0 7,19 * * * /bin/bash -l -c 'cd /home/&lt;youruser&gt;/rubyproj/rscrap &amp;&amp; bundle exec ruby scripts/commitstrip.rb'
0 8 * * * /bin/bash -l -c 'cd /home/&lt;youruser&gt;/rubyproj/rscrap &amp;&amp; bundle exec ruby scripts/sequiential_art.rb'
</code></pre>

<p>And a telegram message for all these things, looks like this:
Reddit:
<img src="https://github.com/Skarlso/rscrap/raw/master/shorten.png" alt="TelegramIMReddit" />
Comics:
<img src="https://github.com/Skarlso/rscrap/raw/master/rscrap2.png" alt="TelegramIMComics" /></p>

<h1 id="conclusion">Conclusion</h1>

<p>That&rsquo;s it folks. Adding a new scraper is easy. I added the aws blog as a new entry as well by just copying the comics scripts. And I&rsquo;m also getting Weather Reports delivered every morning to me.</p>

<p>Have fun. Any questions, please feel free to leave a comment!</p>

<p>Thanks,
Gergely.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">17 Sep 2016, 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://skarlso.github.io/2016/09/17/simple-hometheater-with-remote-and-flirc/" class="post-title">Budget Home Theather with a Headless Raspberry Pi and Flirc for Remote Controlling</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">hannibal</strong>
                            
                            
                                under 
                                
                                <a class="post-category post-category-Hardware" href="https://skarlso.github.io//categories/hardware">Hardware</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="intro">Intro</h2>

<p>Hello folks.</p>

<p>Today, I would like to tell you about my configuration for a low budget Home Theater setup.</p>

<p>My tools are as follows:</p>

<ul>
<li><a href="https://flirc.tv/">FLIRC</a></li>
<li><a href="https://www.raspberrypi.org/products/raspberry-pi-2-model-b/">Raspberry Pi 2</a></li>
<li>500G SSD</li>
<li>An a good &lsquo;ol wifi</li>
</ul>

<h2 id="tl-dr">TL;DR</h2>

<p>Use Flirc for remote control, <code>omxplayer</code> for streaming the movie from an SSD on a headless PI controller via SSH and enjoy a nice, cold Lemon - Menta beer.</p>

<h2 id="flirc">Flirc</h2>

<p>First, the remote control. So, I like to sit in my couch and watch the movie from there. I hate getting up, or having a keyboard at arm length to control the pi. Flirc is a very easy way of doing just that with a simple remote control.</p>

<p>It costs ~$22 and is easy to setup. Works with any kind of remote control. Setting up key bindings for the control, is as simple as starting the Flirc software and pressing buttons on the remote to map to keyboard keys. Now, my pi is running headless, and the Flirc binary isn&rsquo;t quite working with raspbian; so to do the binding, I just did that on my main machine. When I was done, I just plugged in the Flirc, and proceeded to setup the pi.</p>

<h2 id="raspberry-pi-2">Raspberry Pi 2</h2>

<p>The pi 2 is a small powerhouse. However, the SD card on which it sits is simply not fast enough. From time to time, I experienced lateness in sound, or stutter in video. So, instead of having the movie on the pi, I&rsquo;m streaming through a faster SSD with <a href="https://github.com/libfuse/sshfs">SSHFS</a>. For playing, I&rsquo;m using <code>omxplayer</code>. With omxplayer, I had a few problems, because sound was not coming through the HDMI cable. A little bit of research lead me to this change in the pi&rsquo;s boot config. Uncomment this line:</p>

<pre><code class="language-bash">#hdmi_driver=2
</code></pre>

<p>After rebooting, I also, did this thing:</p>

<pre><code class="language-bash">sudo apt-get install alsa-utils
sudo modprobe snd_bcm2835
sudo amixer -c 0 cset numid=3 2
</code></pre>

<p>This saved my bacon. The whole answer can be found here: <a href="http://raspberrypi.stackexchange.com/questions/44/why-is-my-audio-sound-output-not-working">Stackoverflow</a>.</p>

<p>Once SSHFS was working, and HDMI received sound, I just executed this command: <code>omxplayer -o hdmi /media/stream/my_movie.mkv</code>. This told omxplayer to use the local HDMI connection for video output.</p>

<p>All this was from my computer through an SSH session so I never controlled the pi directly. Once done, I proceeded to sit down with a nice, cold Lemon - Menta beer and a remote control.</p>

<p>Once little gotcha &ndash; <code>omxplayer</code> is controlled through the buttons + (volume up), - (volume down), <SPACE> (stop, play), and q for quitting. Flirc is able to map any key <em>combinations</em> on a keyboard as well to any button on the remote. Combinations can be done by selecting a control key and pressing another key. So mapping <code>+</code> to the volume up button was by pressing shift and then &lsquo;=&rsquo;.</p>

<h2 id="wrapping-up">Wrapping Up</h2>

<p>I enjoyed the movie while being able to adjust the volume, or pause it, when my popcorn was ready, and close the player when the movie was done. There are a number of other ways to do this, like using <a href="https://kodi.tv/">kodi</a> + <a href="https://play.google.com/store/apps/details?id=org.leetzone.android.yatsewidgetfree&amp;hl=en">yatse</a>. Which lets you remote control a media software with your mobile phone. But I&rsquo;m using the pi for a number of other things and the GUI is rather resource heavy.</p>

<p>There you have it folks. Might not be the easiest setup, but it&rsquo;s pretty awesome anyways.</p>

<p>Cheers,
Gergely.</p>

                    </div>
                </section>
                
            </div>
            
<div class="pagination">
  <nav role="pagination" class="post-list-pagination">
      
    <span class="post-list-pagination-item post-list-pagination-item-current">Page 1 of 12</span>
    
      <a href="https://skarlso.github.io/posts/page/2/" class="post-list-pagination-item pure-button post-list-pagination-item-next">
        Older&nbsp;<i class="fa fa-angle-double-right"></i>
      </a>
    
  </nav>
</div>


            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
            <li>Powered by <a class="hugo" href="https://gohugo.io/" target="_blank">hugo</a></li>
        </ul>
    </div>
</div>
<script src="https://skarlso.github.io//js/all.min.js"></script>

        </div>
    </div>
</div>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-69463020-2', 'auto');
ga('send', 'pageview');

</script>

</body>
</html>
