<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Ramblings of a build engineer</title>
    <link>https://skarlso.github.io/posts/index.xml</link>
    <description>Recent content in Posts on Ramblings of a build engineer</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 15 Feb 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://skarlso.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>How to HTTPS with Hugo LetsEncrypt and HAProxy</title>
      <link>https://skarlso.github.io/2017/02/15/how-to-https-with-hugo-letsencrypt-haproxy</link>
      <pubDate>Wed, 15 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2017/02/15/how-to-https-with-hugo-letsencrypt-haproxy</guid>
      <description>

&lt;h1 id=&#34;intro&#34;&gt;Intro&lt;/h1&gt;

&lt;p&gt;Hi folks.&lt;/p&gt;

&lt;p&gt;Today, I would like to write about how to do HTTPS for a website, without the need to buy a certificate and set it up via your DNS provider. Let&amp;rsquo;s begin.&lt;/p&gt;

&lt;p&gt;## Abstract&lt;/p&gt;

&lt;p&gt;What you will achieve by the end of this post:
- Every call to HTTP will be redirected to HTTPS via &lt;a href=&#34;https://www.haproxy.com&#34;&gt;haproxy&lt;/a&gt;.
- HTTPS will be served with Haproxy and &lt;a href=&#34;https://letsencrypt.org&#34;&gt;LetsEncrypt&lt;/a&gt; as the Certificate provider.
- Automatically update the certificate before its expiration.
- No need for IPTable rules to route 8080 to 80.
- Traffic to and from your page will be encrypted.
- This all will cost you nothing.&lt;/p&gt;

&lt;p&gt;I will use a static website generator for this called &lt;a href=&#34;https://gohugo.io&#34;&gt;Hugo&lt;/a&gt; which, if you know me, is my favorite generator tool. These instructions
are for haproxy and hugo, if you wish to use apache and nginx for example, you&amp;rsquo;ll have to dig for the corresponding settings for letsencrypt and certbot.&lt;/p&gt;

&lt;h1 id=&#34;what-you-will-need&#34;&gt;What You Will Need&lt;/h1&gt;

&lt;p&gt;## Hugo&lt;/p&gt;

&lt;p&gt;You will need hugo, which can be downloaded from here: &lt;a href=&#34;https://gohugo.io&#34;&gt;Hugo&lt;/a&gt;. A simple website will be enough. For themes, you can take a look
at the humongus list located here: &lt;a href=&#34;http://themes.gohugo.io/&#34;&gt;HugoThemes&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;haproxy&#34;&gt;Haproxy&lt;/h2&gt;

&lt;p&gt;Haproxy can be found here: &lt;a href=&#34;https://www.haproxy.com&#34;&gt;Haproxy&lt;/a&gt;. There are a number of options to install haproxy. I chose a simple
&lt;code&gt;apt-get install haproxy&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;let-s-encrypt&#34;&gt;Let&amp;rsquo;s Encrypt&lt;/h2&gt;

&lt;p&gt;Information about Let&amp;rsquo;s Encrypt can be found on their website here: &lt;a href=&#34;https://letsencrypt.org&#34;&gt;Let&amp;rsquo;s Encrypt&lt;/a&gt;.
Let&amp;rsquo;s Encrypt&amp;rsquo;s client is now called &lt;a href=&#34;https://certbot.eff.org/&#34;&gt;Certbot&lt;/a&gt; which is used to generate the certificates. To get the latest code
you either clone the repository &lt;a href=&#34;https://github.com/certbot/certbot&#34;&gt;Certbot&lt;/a&gt;, or use an autodownloader:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;user@webserver:~$ wget https://dl.eff.org/certbot-auto
user@webserver:~$ chmod a+x ./certbot-auto
user@webserver:~$ ./certbot-auto --help
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Either way, I&amp;rsquo;m using the current latest version: &lt;em&gt;v0.11.1&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;sudo&#34;&gt;Sudo&lt;/h2&gt;

&lt;p&gt;This goes without saying, but that these operations will require you to have sudo priviliges. I suggest staying in sudo for ease of use.
This means that the commands, I&amp;rsquo;ll write here, will assume you are in &lt;code&gt;sudo su&lt;/code&gt; mode thus no &lt;code&gt;sudo&lt;/code&gt; prefix will be used.&lt;/p&gt;

&lt;h2 id=&#34;portforwarding&#34;&gt;Portforwarding&lt;/h2&gt;

&lt;p&gt;In order for your website to work under https this guide assumes that you have port &lt;em&gt;80&lt;/em&gt; and &lt;em&gt;443&lt;/em&gt; open on your router / network security group.&lt;/p&gt;

&lt;h1 id=&#34;setup&#34;&gt;Setup&lt;/h1&gt;

&lt;h2 id=&#34;single-server-environment&#34;&gt;Single Server Environment&lt;/h2&gt;

&lt;p&gt;It is possible for haproxy, certbot and your website to run on designated servers. Haproxy&amp;rsquo;s abilities allows to define multiple server sources.
In this guied, my haproxy, website and certbot will all run on the same server; thus redirecting to 127.0.0.1 and local ips. This is more
convinient, because otherwise the haproxy IP would have to be a permanent local/remote ip. Or an automated script would have to be setup which is
notified upon IP change and updates the ip records.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-certificate&#34;&gt;Creating a Certificate&lt;/h2&gt;

&lt;p&gt;Diving in, the first thing you will require is a certificate. A certificate will allow for encrypted traffic and an authenticated website.
Let&amp;rsquo;s Encrypt which is baseically functioning as an indipendent, free, automated CA (Certificate Authority). Usually,
the process would be to pay a CA to give you a signed, generated certificate for your website, and you would have to set that up with your DNS
provider. Let&amp;rsquo;s Encrypt has that all automated, and free of any charge. Neat.&lt;/p&gt;

&lt;p&gt;### Certbot&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s get started. Clone the repository into &lt;code&gt;/opt/letsencrypt&lt;/code&gt; for further usage.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/certbot/certbot /opt/letsencrypt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;generating-the-certificate&#34;&gt;Generating the certificate&lt;/h3&gt;

&lt;p&gt;Make sure that there is nothing listening on ports: 80, 443. To list usage:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;netstat -na | grep &#39;:80.*LISTEN&#39;
netstat -na | grep &#39;:443.*LISTEN&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kill everything that might be on these ports, like apache2 and httpd. These will be used by haproxy and certbot for challenges
and redirecting traffic.&lt;/p&gt;

&lt;p&gt;You will be creating a &lt;a href=&#34;https://certbot.eff.org/docs/using.html#standalone&#34;&gt;standalone&lt;/a&gt; certificate. This is the reason we need port 80 and 443 open.
Run certbot by defining the &lt;code&gt;certonly&lt;/code&gt; and &lt;code&gt;--standalone&lt;/code&gt; flags. For domain validation you are going to use port 443, tls-sni-01 challenge.
The whole command looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd /opt/letsencrypt
./certbot-auto certonly --standalon -d example.com -d www.example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If this displays something like, &amp;ldquo;couldn&amp;rsquo;t connect&amp;rdquo; you probably still have something running on a port it tries to use. The
generated certificate will be located under &lt;code&gt;/etc/letsencrypt/archive&lt;/code&gt; and &lt;code&gt;/etc/letsencrypt/keys&lt;/code&gt; while &lt;code&gt;/etc/letsencrypt/live&lt;/code&gt; is
a symlink to the latest version of the cert. It&amp;rsquo;s wise to not copy these away from here, since the live link is always updated to the latest version.
Our script will handle haproxy, which requires one cert file made from privkey + fullchain|.pem files.&lt;/p&gt;

&lt;p&gt;### Setup Auto-Renewal&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s Encrypt issues short lived certificates (90 days). In order to not have to do this procedure every 89 days, certbot provides a nifty
command called &lt;code&gt;renew&lt;/code&gt;. However, for the cert to be generated, the port 443 has to be open. This means, haproxy needs to be stopped before
doing the renew. Now, you COULD write a script which stops it, and after the certificate has been renewed, starts it again, but certbot has
you covered again in that department. It provides hooks called &lt;code&gt;pre-hook&lt;/code&gt; and &lt;code&gt;post-hook&lt;/code&gt;. Thus, all you have to write is the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

cd /opt/letsencrypt
./certbot-auto renew --pre-hook &amp;quot;service haproxy stop&amp;quot; --post-hook &amp;quot;service haproxy start&amp;quot;
DOMAIN=&#39;example.com&#39; sudo -E bash -c &#39;cat /etc/letsencrypt/live/$DOMAIN/fullchain.pem /etc/letsencrypt/live/$DOMAIN/privkey.pem &amp;gt; /etc/haproxy/certs/$DOMAIN.pem&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you would like to test it first, just include the switch &lt;code&gt;--dry-run&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In case of success you should see something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@raspberrypi:/opt/letsencrypt# ./certbot-auto renew --pre-hook &amp;quot;service haproxy stop&amp;quot; --post-hook &amp;quot;service haproxy start&amp;quot; --dry-run
Saving debug log to /var/log/letsencrypt/letsencrypt.log

-------------------------------------------------------------------------------
Processing /etc/letsencrypt/renewal/example.com.conf
-------------------------------------------------------------------------------
Cert not due for renewal, but simulating renewal for dry run
Running pre-hook command: service haproxy stop
Renewing an existing certificate
Performing the following challenges:
tls-sni-01 challenge for example.com
Waiting for verification...
Cleaning up challenges
Generating key (2048 bits): /etc/letsencrypt/keys/0002_key-certbot.pem
Creating CSR: /etc/letsencrypt/csr/0002_csr-certbot.pem
** DRY RUN: simulating &#39;certbot renew&#39; close to cert expiry
**          (The test certificates below have not been saved.)

Congratulations, all renewals succeeded. The following certs have been renewed:
  /etc/letsencrypt/live/example.com/fullchain.pem (success)
** DRY RUN: simulating &#39;certbot renew&#39; close to cert expiry
**          (The test certificates above have not been saved.)
Running post-hook command: service haproxy start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Put this script into a crontab to run every 89 days like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;crontab -e
# Open crontab for edit and paste in this line
* * */89 * * /root/renew-cert.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And you should be all set. Now we move on the configure haproxy to redirect and to use our newly generated certificate.&lt;/p&gt;

&lt;h2 id=&#34;haproxy-1&#34;&gt;Haproxy&lt;/h2&gt;

&lt;p&gt;Like I said, haproxy requires a single file certificate in order to encrypt traffic to and from the website. To do this, we need to combine
&lt;code&gt;privkey.pem&lt;/code&gt; and &lt;code&gt;fullchain.pem&lt;/code&gt;. As of this writing, there are a couple of solutions to automate this via a post hook on renewal. And also,
there is an open ticket with certbot to implement a simpler solution located here: &lt;a href=&#34;https://github.com/certbot/certbot/issues/1201&#34;&gt;https://github.com/certbot/certbot/issues/1201&lt;/a&gt;. I, for now,
have chosen to simply concatenate the two files together with &lt;code&gt;cat&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;DOMAIN=&#39;example.com&#39; sudo -E bash -c &#39;cat /etc/letsencrypt/live/$DOMAIN/fullchain.pem /etc/letsencrypt/live/$DOMAIN/privkey.pem &amp;gt; /etc/haproxy/certs/$DOMAIN.pem&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will create a combined cert under &lt;code&gt;/etc/haproxy/certs/example.com.pem&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;### Haproxy configuration&lt;/p&gt;

&lt;p&gt;If haproxy happens to be running, stop it with &lt;code&gt;service haproxy stop&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;First, save the default configuration file: &lt;code&gt;cp /etc/haproxy/haproxy.cfg /etc/haproxy/haproxy.cfg.old&lt;/code&gt;. Now, overwrite the old one with this
new one (comments about what each setting does, are in-lined; they are safe to copy):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;global
    daemon
    # Set this to your desired maximum connection count.
    maxconn 2048
    # https://cbonte.github.io/haproxy-dconv/configuration-1.5.html#3.2-tune.ssl.default-dh-param
    # bit setting for Diffie - Hellman key size.
    tune.ssl.default-dh-param 2048

defaults
    option forwardfor
    option http-server-close

    log     global
    mode    http
    option  httplog
    option  dontlognull
    timeout connect 5000
    timeout client  50000
    timeout server  50000
    errorfile 400 /etc/haproxy/errors/400.http
    errorfile 403 /etc/haproxy/errors/403.http
    errorfile 408 /etc/haproxy/errors/408.http
    errorfile 500 /etc/haproxy/errors/500.http
    errorfile 502 /etc/haproxy/errors/502.http
    errorfile 503 /etc/haproxy/errors/503.http
    errorfile 504 /etc/haproxy/errors/504.http

# In case it&#39;s a simple http call, we redirect to the basic backend server
# which in turn, if it isn&#39;t an SSL call, will redirect to HTTPS that is
# handled by the frontend setting called &#39;www-https&#39;.
frontend www-http
    # Redirect HTTP to HTTPS
    bind *:80
    # Adds http header to end of end of the HTTP request
    reqadd X-Forwarded-Proto:\ http
    # Sets the default backend to use which is defined below with name &#39;www-backend&#39;
    default_backend www-backend

# If the call is HTTPS we set a challenge to letsencrypt backend which
# verifies our certificate and than direct traffic to the backend server
# which is the running hugo site that is served under https if the challenge succeeds.
frontend www-https
    # Bind 443 with the generated letsencrypt cert.
    bind *:443 ssl crt /etc/haproxy/certs/skarlso.com.pem
    # set x-forward to https
    reqadd X-Forwarded-Proto:\ https
    # set X-SSL in case of ssl_fc &amp;lt;- explained below
    http-request set-header X-SSL %[ssl_fc]
    # Select a Challenge
    acl letsencrypt-acl path_beg /.well-known/acme-challenge/
    # Use the challenge backend if the challenge is set
    use_backend letsencrypt-backend if letsencrypt-acl
    default_backend www-backend

backend www-backend
   # Redirect with code 301 so the browser understands it is a redirect. If it&#39;s not SSL_FC.
   # ssl_fc: Returns true when the front connection was made via an SSL/TLS transport
   # layer and is locally deciphered. This means it has matched a socket declared
   # with a &amp;quot;bind&amp;quot; line having the &amp;quot;ssl&amp;quot; option.
   redirect scheme https code 301 if !{ ssl_fc }
   # Server for the running hugo site.
   server www-1 192.168.0.17:8080 check

backend letsencrypt-backend
   # Lets encrypt backend server
   server letsencrypt 127.0.0.1:54321
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save this, and start haproxy with &lt;code&gt;services haproxy start&lt;/code&gt;. If you did everything right, it should say nothing.
If, however, there went something wrong with starting the proxy, it usually displays something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Job for haproxy.service failed. See &#39;systemctl status haproxy.service&#39; and &#39;journalctl -xn&#39; for details.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also gather some more information on what went wrong from &lt;code&gt;less /var/log/haproxy.log&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;starting-the-server&#34;&gt;Starting the Server&lt;/h1&gt;

&lt;p&gt;Everything should be ready to go. Hugo has the concept of a baseUrl. Everything that it loads, and tries to access
will be prefixed with it. You can either set it through it&amp;rsquo;s &lt;code&gt;config.yaml&lt;/code&gt; file, or from the command line.&lt;/p&gt;

&lt;p&gt;To start the server, call this from the site&amp;rsquo;s root folder:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;hugo server --bind=192.168.x.x --port=8080 --baseUrl=https://example.com --appendPort=false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Interesting thing here to note is &lt;code&gt;https&lt;/code&gt; and the port. The IP could be 127.0.0.1 as well. I experienced problems though
with not binding to network IP when I was debugging the site from a different laptop on the same network.&lt;/p&gt;

&lt;p&gt;Once the server is started, you should be able to open up your website from a different browser, not on your local network,
and see that it has a valid certificate installed. In Chrome you should see a green icon telling you that the cert is valid.&lt;/p&gt;

&lt;h1 id=&#34;last-words&#34;&gt;Last Words&lt;/h1&gt;

&lt;p&gt;And that is all. The site should be up and running and the proxy should auto-renew your site&amp;rsquo;s certificate. If you happened to
change DNS or change the server, you&amp;rsquo;ll have to reissue the certificate.&lt;/p&gt;

&lt;p&gt;Thanks for reading!
Any questions or trouble setting something up, please feel free to leave a comment.&lt;/p&gt;

&lt;p&gt;Cheers,
Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to do Google Sign-In with Go - Part 2</title>
      <link>https://skarlso.github.io/2016/11/02/google-signin-with-go-part2</link>
      <pubDate>Wed, 02 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/11/02/google-signin-with-go-part2</guid>
      <description>

&lt;h1 id=&#34;intro&#34;&gt;Intro&lt;/h1&gt;

&lt;p&gt;Hi Folks.&lt;/p&gt;

&lt;p&gt;This is a follow up on my previous post about Google Sign-In. In this post we will discover what to do with the information retrieved in the first encounter, which you can find here: &lt;a href=&#34;http://skarlso.github.io/2016/06/12/google-signin-with-go/&#34;&gt;Google Sign-In Part 1&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;forewords&#34;&gt;Forewords&lt;/h1&gt;

&lt;h2 id=&#34;the-project&#34;&gt;The Project&lt;/h2&gt;

&lt;p&gt;Everything I did in the first post, and that I&amp;rsquo;m going to do in this example, can be found in this project: &lt;a href=&#34;https://github.com/Skarlso/google-oauth-go-sample&#34;&gt;Google-OAuth-Go-Sample&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Just to recap, we left off previously on the point where we successfully obtained information about the user, with a secure token and a session initiated with them. Google nicely enough provided us with some details which we can use. This information was in JSON format and looked something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;sub&amp;quot;: &amp;quot;1111111111111111111111&amp;quot;,
  &amp;quot;name&amp;quot;: &amp;quot;Your Name&amp;quot;,
  &amp;quot;given_name&amp;quot;: &amp;quot;Your&amp;quot;,
  &amp;quot;family_name&amp;quot;: &amp;quot;Name&amp;quot;,
  &amp;quot;profile&amp;quot;: &amp;quot;https://plus.google.com/1111111111111111111111&amp;quot;,
  &amp;quot;picture&amp;quot;: &amp;quot;https://lh3.googleusercontent.com/asdfadsf/AAAAAAAAAAI/Aasdfads/Xasdfasdfs/photo.jpg&amp;quot;,
  &amp;quot;email&amp;quot;: &amp;quot;your@gmail.com&amp;quot;,
  &amp;quot;email_verified&amp;quot;: true,
  &amp;quot;gender&amp;quot;: &amp;quot;male&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In my example, to keep things simple, I will use the email address since that has to be unique in the land of Google. You could assign an ID to the user, and you could complicate things even further, but my goal is not to write an academic paper about cryptography here.&lt;/p&gt;

&lt;h1 id=&#34;implementation&#34;&gt;Implementation&lt;/h1&gt;

&lt;h2 id=&#34;making-something-useful-out-of-the-data&#34;&gt;Making something useful out of the data&lt;/h2&gt;

&lt;p&gt;In order for the app to recognise a user it must save some data about the user. I&amp;rsquo;m doing that in MongoDB right now, but that could be any form of persistence layer, like, SQLite3, BoltDB, PostgresDB, etc.&lt;/p&gt;

&lt;h3 id=&#34;after-successful-user-authorization&#34;&gt;After successful user authorization&lt;/h3&gt;

&lt;p&gt;Once the user used google to provide us with sufficient information about him/herself, we can retrieve data about that user from our records. The data could be anything that is linked to our unique identifier like: Character Profile, Player Information, Status, Last Logged-In, etcetc. For this, there are two things that need to happen after authorization: Save/Load user information and initiate a session.&lt;/p&gt;

&lt;p&gt;The session can be in the form of a cookie, or a Redis storage, or URL re-writing. I&amp;rsquo;m choosing a cookie here.&lt;/p&gt;

&lt;h3 id=&#34;save-load-user-information&#34;&gt;Save / Load user information&lt;/h3&gt;

&lt;p&gt;All I&amp;rsquo;m doing is a simple, &lt;em&gt;returning / new&lt;/em&gt; user handling. The concept is simple. If the email isn&amp;rsquo;t saved, we save it. If it&amp;rsquo;s saved, we set a logic to our page render to greet the returning user.&lt;/p&gt;

&lt;p&gt;In the &lt;code&gt;AuthHandler&lt;/code&gt; I&amp;rsquo;m doing the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;...
seen := false
db := database.MongoDBConnection{}
if _, mongoErr := db.LoadUser(u.Email); mongoErr == nil {
    seen = true
} else {
    err = db.SaveUser(&amp;amp;u)
    if err != nil {
        log.Println(err)
        c.HTML(http.StatusBadRequest, &amp;quot;error.tmpl&amp;quot;, gin.H{&amp;quot;message&amp;quot;: &amp;quot;Error while saving user. Please try again.&amp;quot;})
        return
    }
}
c.HTML(http.StatusOK, &amp;quot;battle.tmpl&amp;quot;, gin.H{&amp;quot;email&amp;quot;: u.Email, &amp;quot;seen&amp;quot;: seen})
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s break this down a bit. There is a db connection here, which calls a function that either returns an error, or it doesn&amp;rsquo;t. If it doesn&amp;rsquo;t, that means we have our user. If it does, it means we have to save the user. This is a very simple case (disregard for now, that the error could be something else as well (If you can&amp;rsquo;t get passed that, you could type check the error or check if the returned record contains the requested user information instead of checking for an error.)).&lt;/p&gt;

&lt;p&gt;The template is than rendered depending on the &lt;code&gt;seen&lt;/code&gt; boolean like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;link rel=&amp;quot;icon&amp;quot;
      type=&amp;quot;image/png&amp;quot;
      href=&amp;quot;/img/favicon.ico&amp;quot; /&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;/css/main.css&amp;quot;&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    {{if .seen}}
        &amp;lt;h1&amp;gt;Welcome back to the battlefield &#39;{{ .email }}&#39;.&amp;lt;/h1&amp;gt;
    {{else}}
        &amp;lt;h1&amp;gt;Welcome to the battlefield &#39;{{ .email }}&#39;.&amp;lt;/h1&amp;gt;
    {{end}}
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see here, that if &lt;code&gt;seen&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; the header message will say: &amp;ldquo;Welcome &lt;em&gt;back&lt;/em&gt;&amp;hellip;&amp;ldquo;.&lt;/p&gt;

&lt;h3 id=&#34;initiating-a-session&#34;&gt;Initiating a session&lt;/h3&gt;

&lt;p&gt;When the user is successfully authenticated, we activate a session so that the user can access pages that require authorization. Here, I have to mention that I&amp;rsquo;m using &lt;a href=&#34;https://github.com/gin-gonic/gin&#34;&gt;Gin&lt;/a&gt;, so restricted end-points are made with groups which require a middleware.&lt;/p&gt;

&lt;p&gt;As I mentioned earlier, I&amp;rsquo;m using cookies as session handlers. For this, a new session store has to be created with some secure token. This is achieved with the following code fragments ( note that I&amp;rsquo;m using a Gin session middleware which uses gorilla&amp;rsquo;s session handler located here: &lt;a href=&#34;https://github.com/gin-gonic/contrib&#34;&gt;Gin-Gonic(Sessions)&lt;/a&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// RandToken in handlers.go:
// RandToken generates a random @l length token.
func RandToken(l int) string {
	b := make([]byte, l)
	rand.Read(b)
	return base64.StdEncoding.EncodeToString(b)
}

// quest.go:
// Create the cookie store in main.go.
store := sessions.NewCookieStore([]byte(handlers.RandToken(64)))
store.Options(sessions.Options{
    Path:   &amp;quot;/&amp;quot;,
    MaxAge: 86400 * 7,
})

// using the cookie store:
router.Use(sessions.Sessions(&amp;quot;goquestsession&amp;quot;, store))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After this &lt;code&gt;gin.Context&lt;/code&gt; lets us access this session store by doing &lt;code&gt;session := sessions.Default(c)&lt;/code&gt;. Now, create a session variable called &lt;code&gt;user-id&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;session.Set(&amp;quot;user-id&amp;quot;, u.Email)
err = session.Save()
if err != nil {
    log.Println(err)
    c.HTML(http.StatusBadRequest, &amp;quot;error.tmpl&amp;quot;, gin.H{&amp;quot;message&amp;quot;: &amp;quot;Error while saving session. Please try again.&amp;quot;})
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;rsquo;t forget to &lt;code&gt;save&lt;/code&gt; the session. ;) That is it. If I restart the server, the cookie won&amp;rsquo;t be usable any longer, since it will generate a new token for the cookie store. The user will have to log in again. &lt;strong&gt;Note&lt;/strong&gt;: It might be that you&amp;rsquo;ll see something like this, from &lt;code&gt;session&lt;/code&gt;: &lt;code&gt;[sessions] ERROR! securecookie: the value is not valid&lt;/code&gt;. You can ignore this error.&lt;/p&gt;

&lt;h2 id=&#34;restricting-access-to-certain-end-points-with-the-auth-middleware&#34;&gt;Restricting access to certain end-points with the auth Middleware™&lt;/h2&gt;

&lt;p&gt;Now, that our session is alive, we can use it to restrict access to some part of the application. With Gin, it looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;authorized := router.Group(&amp;quot;/battle&amp;quot;)
authorized.Use(middleware.AuthorizeRequest())
{
    authorized.GET(&amp;quot;/field&amp;quot;, handlers.FieldHandler)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates a grouping of end-points under &lt;code&gt;/battle&lt;/code&gt;. Which means, everything under &lt;code&gt;/battle&lt;/code&gt; will only be accessible if the middleware passed to the &lt;code&gt;Use&lt;/code&gt; function calls the next handler in the chain. If it aborts the call chain, the end-point will not be accessible. My middleware is pretty simple, but it gets the job done:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// AuthorizeRequest is used to authorize a request for a certain end-point group.
func AuthorizeRequest() gin.HandlerFunc {
	return func(c *gin.Context) {
		session := sessions.Default(c)
		v := session.Get(&amp;quot;user-id&amp;quot;)
		if v == nil {
			c.HTML(http.StatusUnauthorized, &amp;quot;error.tmpl&amp;quot;, gin.H{&amp;quot;message&amp;quot;: &amp;quot;Please log in.&amp;quot;})
			c.Abort()
		}
		c.Next()
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note, that this only check if &lt;code&gt;user-id&lt;/code&gt; is set or not. That&amp;rsquo;s certainly not enough for a secure application. Its only supposed to be a simple example of the mechanics of the auth middleware. Also, the session usually contains more than one parameter. It&amp;rsquo;s more likely that it contains several variables, which describe the user including a state for CORS protection. For CORS I&amp;rsquo;d recommend using &lt;a href=&#34;https://github.com/rs/cors&#34;&gt;rs/cors&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you would try to access &lt;a href=&#34;http://127.0.0.1:9090/battle/field&#34;&gt;http://127.0.0.1:9090/battle/field&lt;/a&gt; without logging in, you&amp;rsquo;d be redirected to an &lt;code&gt;error.tmpl&lt;/code&gt; with the message: &lt;strong&gt;Please log in.&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&#34;final-words&#34;&gt;Final Words&lt;/h1&gt;

&lt;p&gt;That&amp;rsquo;s pretty much it. Important parts are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Saving the right information&lt;/li&gt;
&lt;li&gt;Secure cookie store&lt;/li&gt;
&lt;li&gt;CORS for sessions&lt;/li&gt;
&lt;li&gt;Checks of the users details in the cookie&lt;/li&gt;
&lt;li&gt;Authorised end-points&lt;/li&gt;
&lt;li&gt;Session handling&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Any questions, remarks, ideas, are very welcomed in the comment section. There are plenty of very nice Go frameworks which do Google OAuth2 out of the box. I recommend using them, as they save you a lot of legwork.&lt;/p&gt;

&lt;p&gt;Thank you for reading!
Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RScrap scraper</title>
      <link>https://skarlso.github.io/2016/10/06/rscrap-ruby-scraping-with-cronjob-scripts</link>
      <pubDate>Thu, 06 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/10/06/rscrap-ruby-scraping-with-cronjob-scripts</guid>
      <description>

&lt;h1 id=&#34;intro&#34;&gt;Intro&lt;/h1&gt;

&lt;p&gt;Hey folks.&lt;/p&gt;

&lt;p&gt;So, there is this project called &lt;a href=&#34;https://github.com/cantino/huginn&#34;&gt;Huginn&lt;/a&gt; which I absolutely love.&lt;/p&gt;

&lt;p&gt;But the thing is, that for a couple of scrappers ( at least for me ), I don&amp;rsquo;t want to spin up a whole rails app.&lt;/p&gt;

&lt;p&gt;Hence, I&amp;rsquo;ve come up with &lt;a href=&#34;https://github.com/Skarlso/rscrap&#34;&gt;RScrap&lt;/a&gt;. Which is a bunch of Ruby scripts run as cron jobs on a raspberry pi. And because I dislike emails as well, and most of the time, I don&amp;rsquo;t read them, I opted for a nicer solution. Enter the world of &lt;a href=&#34;https://telegram.org&#34;&gt;Telegram&lt;/a&gt;. They provide you with the ability to create bots. You basically get an API key, and than using that key, you can send private messages, or even create an interactive bot which you can send messages too.&lt;/p&gt;

&lt;p&gt;In my simple example, I&amp;rsquo;m using it to send private messages to myself, but I could just as well, make it interactive and than tell it to run one of the scripts.&lt;/p&gt;

&lt;h1 id=&#34;the-code&#34;&gt;The Code&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at what we got.&lt;/p&gt;

&lt;h2 id=&#34;the-main-scraper&#34;&gt;The main scraper&lt;/h2&gt;

&lt;p&gt;The main scraper, is simply bunch of convenience methods that wrap handling and working with the database and the telegram bot. That&amp;rsquo;s all. It&amp;rsquo;s very simple. Very short. The Telegram part is just this bit:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def send_message(text)
  Telegram::Bot::Client.run(@token) do |bot|
    bot.api.send_message(chat_id: @id, text: text)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Straightforward. Creating an interactive bot, would look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#!/usr/bin/env ruby
require &#39;telegram/bot&#39;

token = &#39;YOUR_TELEGRAM_BOT_API_TOKEN&#39;

Telegram::Bot::Client.run(token) do |bot|
  bot.listen do |message|
    case message.text
    when &#39;/start&#39;
      bot.api.send_message(chat_id: message.chat.id, text: &amp;quot;Hello, #{message.from.first_name}&amp;quot;)
    when &#39;/stop&#39;
      bot.api.send_message(chat_id: message.chat.id, text: &amp;quot;Bye, #{message.from.first_name}&amp;quot;)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, it will listen, and than you can send it messages and based on the parsed &lt;code&gt;message.text&lt;/code&gt; you can define functions to call. For example, for rscrap I could define something like &lt;code&gt;run_script(script)&lt;/code&gt;. And the command would be: &lt;code&gt;/run reddit&lt;/code&gt;. Which will execute my reddit script. The possibilities are endless.&lt;/p&gt;

&lt;h2 id=&#34;the-scripts&#34;&gt;The scripts&lt;/h2&gt;

&lt;p&gt;The scripts use nokogiri to parse a web page, and than return a URL which will be sent by the TelegramBot. They are also saved in the database so that when a new comic strip comes out, I know that it&amp;rsquo;s new. For reddit, I&amp;rsquo;m saving a timestamp as well, and I collect everything after that timestamp through the reddit API as JSON, and send it as a bundled message with shortified links to the posts using bit.ly.&lt;/p&gt;

&lt;p&gt;The scraping is most of the times the same for every comic. Thus, there is a helper method for it. The script itself, is very short. For example, lets look at gunnerkrigg court.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require_relative &#39;../rscrap&#39;
require &#39;nokogiri&#39;
require &#39;open-uri&#39;

url = &#39;http://www.gunnerkrigg.com&#39;
scrap = Rscrap.new
page = Nokogiri::HTML(open(url))
comic_id = page.css(&#39;img.comic_image&#39;)[0].select { |e| e if e[0] == &#39;src&#39; }[0][1]
new_comic = &amp;quot;#{url}#{comic_id}&amp;quot;
scrap.send_new_comic(url, new_comic)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The interesting part of it is this bit: &lt;code&gt;comic_id = page.css(&#39;img.comic_image&#39;)[0].select { |e| e if e[0] == &#39;src&#39; }[0][1]&lt;/code&gt;. It extracts the URL for the comic image, and stores it as an &amp;ldquo;id&amp;rdquo; of the comic. This than, is sent as a message which Telegram will embed. There is no need to visit the web page, the image is in your feed and you can view it directly. Just like an RSS ready.&lt;/p&gt;

&lt;h2 id=&#34;cron&#34;&gt;Cron&lt;/h2&gt;

&lt;p&gt;These scripts are best used in a cron job. The comics are usually running with a daily frequency, where as the reddit gatherer is running with an hour frequency. Basically, I&amp;rsquo;m receiving updates on an hourly basis if there are new posts by then. Running ruby from cron was a bit tricky. I&amp;rsquo;m using bundler for the environment, and came up with this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;0 6-23 * * * /bin/bash -l -c &#39;cd /home/&amp;lt;youruser&amp;gt;/rubyproj/rscrap &amp;amp;&amp;amp; bundle exec ruby scripts/reddit.rb&#39;
0 8,22 * * * /bin/bash -l -c &#39;cd /home/&amp;lt;youruser&amp;gt;/rubyproj/rscrap &amp;amp;&amp;amp; bundle exec ruby scripts/gunnerkrigg.rb&#39;
0 8,22 * * * /bin/bash -l -c &#39;cd /home/&amp;lt;youruser&amp;gt;/rubyproj/rscrap &amp;amp;&amp;amp; bundle exec ruby scripts/aws_blog.rb&#39;
0 5,23 * * * /bin/bash -l -c &#39;cd /home/&amp;lt;youruser&amp;gt;/rubyproj/rscrap &amp;amp;&amp;amp; bundle exec ruby scripts/goblinscomic.rb&#39;
0 6,20 * * * /bin/bash -l -c &#39;cd /home/&amp;lt;youruser&amp;gt;/rubyproj/rscrap &amp;amp;&amp;amp; bundle exec ruby scripts/xkcd.rb&#39;
0 7,19 * * * /bin/bash -l -c &#39;cd /home/&amp;lt;youruser&amp;gt;/rubyproj/rscrap &amp;amp;&amp;amp; bundle exec ruby scripts/commitstrip.rb&#39;
0 8 * * * /bin/bash -l -c &#39;cd /home/&amp;lt;youruser&amp;gt;/rubyproj/rscrap &amp;amp;&amp;amp; bundle exec ruby scripts/sequiential_art.rb&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And a telegram message for all these things, looks like this:
Reddit:
&lt;img src=&#34;https://github.com/Skarlso/rscrap/raw/master/shorten.png&#34; alt=&#34;TelegramIMReddit&#34; /&gt;
Comics:
&lt;img src=&#34;https://github.com/Skarlso/rscrap/raw/master/rscrap2.png&#34; alt=&#34;TelegramIMComics&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;That&amp;rsquo;s it folks. Adding a new scraper is easy. I added the aws blog as a new entry as well by just copying the comics scripts. And I&amp;rsquo;m also getting Weather Reports delivered every morning to me.&lt;/p&gt;

&lt;p&gt;Have fun. Any questions, please feel free to leave a comment!&lt;/p&gt;

&lt;p&gt;Thanks,
Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Budget Home Theather with a Headless Raspberry Pi and Flirc for Remote Controlling</title>
      <link>https://skarlso.github.io/2016/09/17/simple-hometheater-with-remote-and-flirc</link>
      <pubDate>Sat, 17 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/09/17/simple-hometheater-with-remote-and-flirc</guid>
      <description>

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Hello folks.&lt;/p&gt;

&lt;p&gt;Today, I would like to tell you about my configuration for a low budget Home Theater setup.&lt;/p&gt;

&lt;p&gt;My tools are as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://flirc.tv/&#34;&gt;FLIRC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.raspberrypi.org/products/raspberry-pi-2-model-b/&#34;&gt;Raspberry Pi 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;500G SSD&lt;/li&gt;
&lt;li&gt;An a good &amp;lsquo;ol wifi&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tl-dr&#34;&gt;TL;DR&lt;/h2&gt;

&lt;p&gt;Use Flirc for remote control, &lt;code&gt;omxplayer&lt;/code&gt; for streaming the movie from an SSD on a headless PI controller via SSH and enjoy a nice, cold Lemon - Menta beer.&lt;/p&gt;

&lt;h2 id=&#34;flirc&#34;&gt;Flirc&lt;/h2&gt;

&lt;p&gt;First, the remote control. So, I like to sit in my couch and watch the movie from there. I hate getting up, or having a keyboard at arm length to control the pi. Flirc is a very easy way of doing just that with a simple remote control.&lt;/p&gt;

&lt;p&gt;It costs ~$22 and is easy to setup. Works with any kind of remote control. Setting up key bindings for the control, is as simple as starting the Flirc software and pressing buttons on the remote to map to keyboard keys. Now, my pi is running headless, and the Flirc binary isn&amp;rsquo;t quite working with raspbian; so to do the binding, I just did that on my main machine. When I was done, I just plugged in the Flirc, and proceeded to setup the pi.&lt;/p&gt;

&lt;h2 id=&#34;raspberry-pi-2&#34;&gt;Raspberry Pi 2&lt;/h2&gt;

&lt;p&gt;The pi 2 is a small powerhouse. However, the SD card on which it sits is simply not fast enough. From time to time, I experienced lateness in sound, or stutter in video. So, instead of having the movie on the pi, I&amp;rsquo;m streaming through a faster SSD with &lt;a href=&#34;https://github.com/libfuse/sshfs&#34;&gt;SSHFS&lt;/a&gt;. For playing, I&amp;rsquo;m using &lt;code&gt;omxplayer&lt;/code&gt;. With omxplayer, I had a few problems, because sound was not coming through the HDMI cable. A little bit of research lead me to this change in the pi&amp;rsquo;s boot config. Uncomment this line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#hdmi_driver=2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After rebooting, I also, did this thing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install alsa-utils
sudo modprobe snd_bcm2835
sudo amixer -c 0 cset numid=3 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This saved my bacon. The whole answer can be found here: &lt;a href=&#34;http://raspberrypi.stackexchange.com/questions/44/why-is-my-audio-sound-output-not-working&#34;&gt;Stackoverflow&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once SSHFS was working, and HDMI received sound, I just executed this command: &lt;code&gt;omxplayer -o hdmi /media/stream/my_movie.mkv&lt;/code&gt;. This told omxplayer to use the local HDMI connection for video output.&lt;/p&gt;

&lt;p&gt;All this was from my computer through an SSH session so I never controlled the pi directly. Once done, I proceeded to sit down with a nice, cold Lemon - Menta beer and a remote control.&lt;/p&gt;

&lt;p&gt;Once little gotcha &amp;ndash; &lt;code&gt;omxplayer&lt;/code&gt; is controlled through the buttons + (volume up), - (volume down), &lt;SPACE&gt; (stop, play), and q for quitting. Flirc is able to map any key &lt;em&gt;combinations&lt;/em&gt; on a keyboard as well to any button on the remote. Combinations can be done by selecting a control key and pressing another key. So mapping &lt;code&gt;+&lt;/code&gt; to the volume up button was by pressing shift and then &amp;lsquo;=&amp;rsquo;.&lt;/p&gt;

&lt;h2 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h2&gt;

&lt;p&gt;I enjoyed the movie while being able to adjust the volume, or pause it, when my popcorn was ready, and close the player when the movie was done. There are a number of other ways to do this, like using &lt;a href=&#34;https://kodi.tv/&#34;&gt;kodi&lt;/a&gt; + &lt;a href=&#34;https://play.google.com/store/apps/details?id=org.leetzone.android.yatsewidgetfree&amp;amp;hl=en&#34;&gt;yatse&lt;/a&gt;. Which lets you remote control a media software with your mobile phone. But I&amp;rsquo;m using the pi for a number of other things and the GUI is rather resource heavy.&lt;/p&gt;

&lt;p&gt;There you have it folks. Might not be the easiest setup, but it&amp;rsquo;s pretty awesome anyways.&lt;/p&gt;

&lt;p&gt;Cheers,
Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Always Go with []byte</title>
      <link>https://skarlso.github.io/2016/08/19/always-go-with-bytes</link>
      <pubDate>Fri, 19 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/08/19/always-go-with-bytes</guid>
      <description>&lt;p&gt;Another quick reminder&amp;hellip; Always go with []byte if possible. I said it before, and I&amp;rsquo;m going to say it over and over again. It&amp;rsquo;s crucial.&lt;/p&gt;

&lt;p&gt;Here is a little code from exercism.io. First, with strings:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package igpay

import (
    &amp;quot;strings&amp;quot;
)

// PigLatin translates reguler old English into awesome pig-latin.
func PigLatin(in string) (ret string) {
    for _, v := range strings.Fields(in) {
        ret += pigLatin(v) + &amp;quot; &amp;quot;
    }

    return strings.Trim(ret, &amp;quot; &amp;quot;)
}

func pigLatin(in string) (ret string) {
    if strings.IndexAny(in, &amp;quot;aeiou&amp;quot;) == 0 {
        ret += in + &amp;quot;ay&amp;quot;
        return
    }

    for i := 0; i &amp;lt; len(in); i++ {
        vowelPos := strings.IndexAny(in, &amp;quot;aeiou&amp;quot;)

        if (in[0] == &#39;y&#39; || in[0] == &#39;x&#39;) &amp;amp;&amp;amp; vowelPos &amp;gt; 1 {
            vowelPos = 0
            ret = in
        }
        if vowelPos != 0 {
            adjustPosition := vowelPos

            if in[adjustPosition] == &#39;u&#39; &amp;amp;&amp;amp; in[adjustPosition - 1] == &#39;q&#39; {
                adjustPosition++
            }

            ret = in[adjustPosition:] + in[:adjustPosition]
        }
    }
    ret += &amp;quot;ay&amp;quot;
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Than with []byte:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package igpay

import (
    // &amp;quot;fmt&amp;quot;
    &amp;quot;bytes&amp;quot;
)

// PigLatin translates reguler old English into awesome pig-latin.
func PigLatin(in string) (ret string) {
    inBytes := []byte(in)
    var retBytes [][]byte
    for _, v := range bytes.Fields(inBytes) {
        v2 := make([]byte, len(v))
        copy(v2, v)
        retBytes = append(retBytes, pigLatin(v2))
    }

    ret = string(bytes.Join(retBytes, []byte(&amp;quot; &amp;quot;)))
    return
}

func pigLatin(in []byte) (ret []byte) {
    if bytes.IndexAny(in, &amp;quot;aeiou&amp;quot;) == 0 {
        ret = append(in, []byte(&amp;quot;ay&amp;quot;)...)
        return
    }

    for i := 0; i &amp;lt; len(in); i++ {
        vowelPos := bytes.IndexAny(in, &amp;quot;aeiou&amp;quot;)

        if (in[0] == &#39;y&#39; || in[0] == &#39;x&#39;) &amp;amp;&amp;amp; vowelPos &amp;gt; 1 {
            vowelPos = 0
            ret = in
        }
        if vowelPos != 0 {
            adjustPosition := vowelPos

            if in[adjustPosition] == &#39;u&#39; &amp;amp;&amp;amp; in[adjustPosition - 1] == &#39;q&#39; {
                adjustPosition++
            }

            in = append(in[adjustPosition:], in[:adjustPosition]...)
            ret = in
            // fmt.Printf(&amp;quot;%s\n&amp;quot;, ret)
        }
    }
    ret = append(ret, []byte(&amp;quot;ay&amp;quot;)...)
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And than,the benchmarks of course:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;BenchmarkPigLatin-8          	  200000	     10688 ns/op
BenchmarkPigLatinStrings-8   	  100000	     15211 ns/op
PASS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The improvement is not massive in this case, but it&amp;rsquo;s more than enough to matter. And in a bigger, more complicated program, string concatenation will take a LOT of time away.&lt;/p&gt;

&lt;p&gt;In Go, the &lt;code&gt;bytes&lt;/code&gt; package has a 1-1 map compared to the &lt;code&gt;strings&lt;/code&gt; packages, so chances are, if you are doing strings concatenations you will be able to port that piece of code easily to []byte.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all folks.&lt;/p&gt;

&lt;p&gt;Happy coding,
Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Global variable for never changing regex</title>
      <link>https://skarlso.github.io/2016/08/16/never-changing-regex</link>
      <pubDate>Tue, 16 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/08/16/never-changing-regex</guid>
      <description>&lt;p&gt;Quick reminder. If you have a never changing regex in Go, do NOT put it into a frequently called function. ALWAYS put it into a global variable. I&amp;rsquo;ll show you why.&lt;/p&gt;

&lt;p&gt;Benchmark for code with a variable in a frequently called function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;BenchmarkNumber-8     	   30000	     41633 ns/op
BenchmarkAreaCode-8   	   50000	     27736 ns/op
BenchmarkFormat-8     	   50000	     29263 ns/op
PASS
ok  	_/phone-number	5.110s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Benchmark for code with the same variable outside in a global scope:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;BenchmarkNumber-8     	  300000	      5618 ns/op
BenchmarkAreaCode-8   	  500000	      3884 ns/op
BenchmarkFormat-8     	  300000	      4696 ns/op
PASS
ok  	_/phone-number	5.197s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the magnitude change in ns/op! That&amp;rsquo;s something to keep an eye out for.&lt;/p&gt;

&lt;p&gt;Thanks for reading!
Cheers,
Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Drupal missing ToolBar and settings not saving</title>
      <link>https://skarlso.github.io/2016/08/13/drupal-missing-toolbar-and-settings-not-saving</link>
      <pubDate>Sat, 13 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/08/13/drupal-missing-toolbar-and-settings-not-saving</guid>
      <description>&lt;p&gt;Hi folks.&lt;/p&gt;

&lt;p&gt;Quick gotcha, when working with Drupal. If you just freshly installed it, and everything seems to work fine, and yet you are experiencing things like, the admin toolbar is randomly disappearing, or configuration is not saved; than you might not have modrewrite enabled on your apache server.&lt;/p&gt;

&lt;p&gt;Because, by default, Drupal has clean url enabled, that needs URL rewriting on apache.&lt;/p&gt;

&lt;p&gt;So, step one.&lt;/p&gt;

&lt;p&gt;Have this in your .htaccess file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;lt;IfModule mod_rewrite.c&amp;gt;
  RewriteEngine on
  ... # and than a bunch of rewrite rules according to your leisure
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Than look up this line in your httpd.conf file and remove the prefix &amp;lsquo;#&amp;rsquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#LoadModule rewrite_module libexec/apache2/mod_rewrite.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is all. From there on, everything should work. If, you don&amp;rsquo;t want the clean url setting, yet you can&amp;rsquo;t disable it, and don&amp;rsquo;t want to restart the server and edit the settings.php file; use drush like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;drush vset clean_url 0 --yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should disable it and bust the cache in the process so it&amp;rsquo;s immediately visible.&lt;/p&gt;

&lt;p&gt;That is all folks.&lt;/p&gt;

&lt;p&gt;Cheers,
Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jenkins Best Practices Talk</title>
      <link>https://skarlso.github.io/2016/07/28/jenkins-best-practices</link>
      <pubDate>Thu, 28 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/07/28/jenkins-best-practices</guid>
      <description>&lt;p&gt;Hi folks.&lt;/p&gt;

&lt;p&gt;I wanted to take the time to share with you a talk that I recently did.&lt;/p&gt;

&lt;p&gt;The slides and the source I used, can be found here: &lt;a href=&#34;https://github.com/Skarlso/jenkinsbestpractices&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;And then, there is also a docker image which contains all the plugins, job configurations and all the practices which I did during the talk. Please feel free to have a go with it. &lt;a href=&#34;https://hub.docker.com/r/skarlso/jenkinsbestpractices&#34;&gt;DockerHub - Jenkins Best Practices&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For easy access and reading, here are the slides on Slideshare: &lt;a href=&#34;http://www.slideshare.net/GergelyBrautigam/jenkins-best-practices-meetup-slides&#34;&gt;Jenkins Best Practices Slides&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I, gladly answer any questions which should arise.&lt;/p&gt;

&lt;p&gt;Thanks!
Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ruby Sieve</title>
      <link>https://skarlso.github.io/2016/07/12/ruby-sieve</link>
      <pubDate>Tue, 12 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/07/12/ruby-sieve</guid>
      <description>&lt;p&gt;Though it could be done better, I&amp;rsquo;m sure, but I&amp;rsquo;m actually pretty satisfied with this one. It loops only twice as opposed to filtered ranges and whatnot other solutions to the sieve. I was thinking of rather creating a list and deleting elements from it, but that&amp;rsquo;s already three loops.&lt;/p&gt;

&lt;p&gt;Maybe I&amp;rsquo;ll do a benchmark later on more solutions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Sieve contains a function to return a set of primes
class Sieve
  def initialize(n)
    @n = n
  end

  # Returns a list of primes up to a certain limit
  # @param n limit
  # @return list of primes
  def primes
    marked = []
    primes = []
    (2..@n).each do |e|
      unless marked.include?(e)
        primes.push e
        (e..@n).step(e) { |s| marked.push s }
      end
    end
    primes
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cheers,
Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Simple hook to rid of trouble</title>
      <link>https://skarlso.github.io/2016/07/12/simple-hook-to-rid-of-trouble</link>
      <pubDate>Tue, 12 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/07/12/simple-hook-to-rid-of-trouble</guid>
      <description>&lt;p&gt;Hi folks.&lt;/p&gt;

&lt;p&gt;This is but a simple git hook to run a test in order to ensure you can push. It also ignores the vendor folder if you happen to have on in your directory.&lt;/p&gt;

&lt;p&gt;Edit the file under &lt;code&gt;.git/hooks/pre-push.sample&lt;/code&gt; and add this at the end before the &lt;code&gt;exit 0&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go test $(go list ./... |grep -v vendor)
RESULT=$?
if [ $RESULT -ne 0 ]; then
    echo &amp;quot;Failed test run. Disallowing push.&amp;quot;
    exit 1
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After this, rename the file to &lt;code&gt;pre-push&lt;/code&gt; removing the .sample from it.&lt;/p&gt;

&lt;p&gt;If you now, mess something up, you should see something like this before your push:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# github.com/Skarlso/goprogressquest
./create.go:40: undefined: sha1 in sha1.Sum
./create.go:41: undefined: fmt in fmt.Sprintf
./create.go:115: undefined: json in json.Unmarshal
./create.go:130: undefined: json in json.Unmarshal
FAIL	github.com/Skarlso/goprogressquest [build failed]
Failed test run. Disallowing push.
error: failed to push some refs to &#39;git@github.com:Skarlso/goprogressquest.git&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is all.&lt;/p&gt;

&lt;p&gt;Cheers,
Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to do Google sign-in with Go</title>
      <link>https://skarlso.github.io/2016/06/12/google-signin-with-go</link>
      <pubDate>Sun, 12 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/06/12/google-signin-with-go</guid>
      <description>&lt;p&gt;Hi folks.&lt;/p&gt;

&lt;p&gt;Today, I would like to write up a step - by - step guide with a sample web app on how to do Google Sign-In and authorization.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started.&lt;/p&gt;

&lt;h1 id=&#34;setup&#34;&gt;Setup&lt;/h1&gt;

&lt;h2 id=&#34;google-oauth-token&#34;&gt;Google OAuth token&lt;/h2&gt;

&lt;p&gt;First what you need is, to register your application with Google, so you&amp;rsquo;ll get a Token that you can use to authorize later calls to Google services.&lt;/p&gt;

&lt;p&gt;You can do that here: &lt;a href=&#34;https://console.developers.google.com/iam-admin/projects&#34;&gt;Google Developer Console&lt;/a&gt;. You&amp;rsquo;ll have to create a new project. Once it&amp;rsquo;s done, click on &lt;code&gt;Credentials&lt;/code&gt; and create an OAuth token. You should see something like this: &amp;ldquo;To create an OAuth client ID, you must first set a product name on the consent screen.&amp;rdquo;. Go through the questions, like, what type your application is, and once you arrive at stage where it&amp;rsquo;s asking for your application&amp;rsquo;s name &amp;ndash; there is a section asking for redirect URLs; there, write the url you wish to use when authorising your user. If you don&amp;rsquo;t know this yet, don&amp;rsquo;t fret, you can come back and change it later. Do NOT use &lt;code&gt;localhost&lt;/code&gt;. If you are running on your own, use &lt;a href=&#34;http://127.0.0.1:port/whatever&#34;&gt;http://127.0.0.1:port/whatever&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This will get you a &lt;code&gt;client ID&lt;/code&gt; and a &lt;code&gt;client secret&lt;/code&gt;. I&amp;rsquo;m going to save these into a file which will sit next to my web app. It could be stored more securely, for example, in a database or a mounted secure, encrypted drive, and so and so forth.&lt;/p&gt;

&lt;p&gt;Your application can now be identified through Google services.&lt;/p&gt;

&lt;h1 id=&#34;the-application&#34;&gt;The Application&lt;/h1&gt;

&lt;h2 id=&#34;libraries&#34;&gt;Libraries&lt;/h2&gt;

&lt;p&gt;Google has a nice library to use with OAuth 2.0. The library is available here: &lt;a href=&#34;https://github.com/golang/oauth2&#34;&gt;Google OAth 2.0&lt;/a&gt;. It&amp;rsquo;s a bit cryptic at first, but not to worry. After a bit of fiddling you&amp;rsquo;ll understand fast what it does. I&amp;rsquo;m also using &lt;a href=&#34;https://github.com/gin-gonic/gin&#34;&gt;Gin&lt;/a&gt;, and Gin&amp;rsquo;s session handling middleware &lt;a href=&#34;https://github.com/gin-gonic/contrib/tree/master/sessions&#34;&gt;Gin-Session&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;setup-credentials&#34;&gt;Setup - Credentials&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s create a setup which configures your credentials from the file you saved earlier. This is pretty straightforward.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Credentials which stores google ids.
type Credentials struct {
    Cid string `json:&amp;quot;cid&amp;quot;`
    Csecret string `json:&amp;quot;csecret&amp;quot;`
}

func init() {
    var c Credentials
    file, err := ioutil.ReadFile(&amp;quot;./creds.json&amp;quot;)
    if err != nil {
        fmt.Printf(&amp;quot;File error: %v\n&amp;quot;, err)
        os.Exit(1)
    }
    json.Unmarshal(file, &amp;amp;c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you have the creds loaded, you can now go on to construct the OAuth client.&lt;/p&gt;

&lt;h2 id=&#34;setup-oauth-client&#34;&gt;Setup - OAuth client&lt;/h2&gt;

&lt;p&gt;Construct the OAuth config like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;conf := &amp;amp;oauth2.Config{
  ClientID:     c.Cid,
  ClientSecret: c.Csecret,
  RedirectURL:  &amp;quot;http://localhost:9090/auth&amp;quot;,
  Scopes: []string{
    &amp;quot;https://www.googleapis.com/auth/userinfo.email&amp;quot;, // You have to select your own scope from here -&amp;gt; https://developers.google.com/identity/protocols/googlescopes#google_sign-in
  },
  Endpoint: google.Endpoint,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will give you a struct which you can then use to Authorize the user in the google domain. Next, all you need to do is call &lt;code&gt;AuthCodeURL&lt;/code&gt; on this config. It will give you a URL which redirects to a Google Sign-In form. Once the user fills that out and clicks &amp;lsquo;Allow&amp;rsquo;, you&amp;rsquo;ll get back a TOKEN in the &lt;code&gt;code&lt;/code&gt; query parameter and a &lt;code&gt;state&lt;/code&gt; which helps protect against CSRF attacks. Always check if the provided state is the same which you provided with AuthCodeURL. This will look something like this &lt;code&gt;http://127.0.0.1:9090/auth?code=4FLKFskdjflf3343d4f&amp;amp;state=lhfu3f983j;asdf&lt;/code&gt;. Small function for this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func getLoginURL(state string) string {
    // State can be some kind of random generated hash string.
    // See relevant RFC: http://tools.ietf.org/html/rfc6749#section-10.12
    return conf.AuthCodeURL(state)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Construct a button which the user can click and be redirected to the Google Sign-In form. When constructing the url, we must do one more thing. Create a secure state token and save it in the form of a cookie for the current user.&lt;/p&gt;

&lt;h2 id=&#34;random-state-and-button-construction&#34;&gt;Random State and Button construction&lt;/h2&gt;

&lt;p&gt;Small piece of code random token:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func randToken() string {
	b := make([]byte, 32)
	rand.Read(b)
	return base64.StdEncoding.EncodeToString(b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Storing it in a session and constructing the button:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func loginHandler(c *gin.Context) {
    state = randToken()
    session := sessions.Default(c)
    session.Set(&amp;quot;state&amp;quot;, state)
    session.Save()
    c.Writer.Write([]byte(&amp;quot;&amp;lt;html&amp;gt;&amp;lt;title&amp;gt;Golang Google&amp;lt;/title&amp;gt; &amp;lt;body&amp;gt; &amp;lt;a href=&#39;&amp;quot; + getLoginURL() + &amp;quot;&#39;&amp;gt;&amp;lt;button&amp;gt;Login with Google!&amp;lt;/button&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s not the nicest button I ever come up with, but it will have to do.&lt;/p&gt;

&lt;h1 id=&#34;user-information&#34;&gt;User Information&lt;/h1&gt;

&lt;p&gt;After you got the token, you can construct an authorised Google HTTP Client, which let&amp;rsquo;s you call Google related services and retrieve information about the user.&lt;/p&gt;

&lt;h2 id=&#34;getting-the-client&#34;&gt;Getting the Client&lt;/h2&gt;

&lt;p&gt;Before we construct a client, we must check if the retrieved state is still the same compared to the one we provided. I&amp;rsquo;m doing this before constructing the client. Together this looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func authHandler(c *gin.Context) {
    // Check state validity.
    session := sessions.Default(c)
    retrievedState := session.Get(&amp;quot;state&amp;quot;)
    if retrievedState != c.Query(&amp;quot;state&amp;quot;) {
        c.AbortWithError(http.StatusUnauthorized, fmt.Errorf(&amp;quot;Invalid session state: %s&amp;quot;, retrievedState))
        return
    }
    // Handle the exchange code to initiate a transport.
  	tok, err := conf.Exchange(oauth2.NoContext, c.Query(&amp;quot;code&amp;quot;))
  	if err != nil {
  		c.AbortWithError(http.StatusBadRequest, err)
          return
  	}
    // Construct the client.
    client := conf.Client(oauth2.NoContext, tok)
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;obtaining-information&#34;&gt;Obtaining information&lt;/h2&gt;

&lt;p&gt;Our next step is to retrieve information about the user. To achieve this, call Google&amp;rsquo;s API with the authorised client. The code for that is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;...
resp, err := client.Get(&amp;quot;https://www.googleapis.com/oauth2/v3/userinfo&amp;quot;)
if err != nil {
    c.AbortWithError(http.StatusBadRequest, err)
    return
}
defer resp.Body.Close()
data, _ := ioutil.ReadAll(resp.Body)
log.Println(&amp;quot;Resp body: &amp;quot;, string(data))
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this will yield a body like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;sub&amp;quot;: &amp;quot;1111111111111111111111&amp;quot;,
  &amp;quot;name&amp;quot;: &amp;quot;Your Name&amp;quot;,
  &amp;quot;given_name&amp;quot;: &amp;quot;Your&amp;quot;,
  &amp;quot;family_name&amp;quot;: &amp;quot;Name&amp;quot;,
  &amp;quot;profile&amp;quot;: &amp;quot;https://plus.google.com/1111111111111111111111&amp;quot;,
  &amp;quot;picture&amp;quot;: &amp;quot;https://lh3.googleusercontent.com/asdfadsf/AAAAAAAAAAI/Aasdfads/Xasdfasdfs/photo.jpg&amp;quot;,
  &amp;quot;email&amp;quot;: &amp;quot;your@gmail.com&amp;quot;,
  &amp;quot;email_verified&amp;quot;: true,
  &amp;quot;gender&amp;quot;: &amp;quot;male&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Parse it, and you&amp;rsquo;ve got an email which you can store somewhere for registration purposes. At this point, your user is not yet Authenticated. For that, I&amp;rsquo;m going to post a second post, which describes how to go on. Retrieving the stored email address, and user session handling with Gin and MongoDB.&lt;/p&gt;

&lt;h1 id=&#34;putting-it-all-together&#34;&gt;Putting it all together&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;crypto/rand&amp;quot;
    &amp;quot;encoding/base64&amp;quot;
    &amp;quot;encoding/json&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;net/http&amp;quot;

    &amp;quot;github.com/gin-gonic/contrib/sessions&amp;quot;
    &amp;quot;github.com/gin-gonic/gin&amp;quot;
    &amp;quot;golang.org/x/oauth2&amp;quot;
    &amp;quot;golang.org/x/oauth2/google&amp;quot;
)

// Credentials which stores google ids.
type Credentials struct {
    Cid     string `json:&amp;quot;cid&amp;quot;`
    Csecret string `json:&amp;quot;csecret&amp;quot;`
}

// User is a retrieved and authentiacted user.
type User struct {
    Sub string `json:&amp;quot;sub&amp;quot;`
    Name string `json:&amp;quot;name&amp;quot;`
    GivenName string `json:&amp;quot;given_name&amp;quot;`
    FamilyName string `json:&amp;quot;family_name&amp;quot;`
    Profile string `json:&amp;quot;profile&amp;quot;`
    Picture string `json:&amp;quot;picture&amp;quot;`
    Email string `json:&amp;quot;email&amp;quot;`
    EmailVerified string `json:&amp;quot;email_verified&amp;quot;`
    Gender string `json:&amp;quot;gender&amp;quot;`
}

var cred Credentials
var conf *oauth2.Config
var state string
var store = sessions.NewCookieStore([]byte(&amp;quot;secret&amp;quot;))

func randToken() string {
	b := make([]byte, 32)
	rand.Read(b)
	return base64.StdEncoding.EncodeToString(b)
}

func init() {
    file, err := ioutil.ReadFile(&amp;quot;./creds.json&amp;quot;)
    if err != nil {
        log.Printf(&amp;quot;File error: %v\n&amp;quot;, err)
        os.Exit(1)
    }
    json.Unmarshal(file, &amp;amp;cred)

    conf = &amp;amp;oauth2.Config{
        ClientID:     cred.Cid,
        ClientSecret: cred.Csecret,
        RedirectURL:  &amp;quot;http://127.0.0.1:9090/auth&amp;quot;,
        Scopes: []string{
            &amp;quot;https://www.googleapis.com/auth/userinfo.email&amp;quot;, // You have to select your own scope from here -&amp;gt; https://developers.google.com/identity/protocols/googlescopes#google_sign-in
        },
        Endpoint: google.Endpoint,
    }
}

func indexHandler(c *gin.Context) {
    c.HTML(http.StatusOK, &amp;quot;index.tmpl&amp;quot;, gin.H{})
}

func getLoginURL(state string) string {
    return conf.AuthCodeURL(state)
}

func authHandler(c *gin.Context) {
    // Handle the exchange code to initiate a transport.
    session := sessions.Default(c)
    retrievedState := session.Get(&amp;quot;state&amp;quot;)
    if retrievedState != c.Query(&amp;quot;state&amp;quot;) {
        c.AbortWithError(http.StatusUnauthorized, fmt.Errorf(&amp;quot;Invalid session state: %s&amp;quot;, retrievedState))
        return
    }

	tok, err := conf.Exchange(oauth2.NoContext, c.Query(&amp;quot;code&amp;quot;))
	if err != nil {
		c.AbortWithError(http.StatusBadRequest, err)
        return
	}

	client := conf.Client(oauth2.NoContext, tok)
	email, err := client.Get(&amp;quot;https://www.googleapis.com/oauth2/v3/userinfo&amp;quot;)
    if err != nil {
		c.AbortWithError(http.StatusBadRequest, err)
        return
	}
    defer email.Body.Close()
    data, _ := ioutil.ReadAll(email.Body)
    log.Println(&amp;quot;Email body: &amp;quot;, string(data))
    c.Status(http.StatusOK)
}

func loginHandler(c *gin.Context) {
    state = randToken()
    session := sessions.Default(c)
    session.Set(&amp;quot;state&amp;quot;, state)
    session.Save()
    c.Writer.Write([]byte(&amp;quot;&amp;lt;html&amp;gt;&amp;lt;title&amp;gt;Golang Google&amp;lt;/title&amp;gt; &amp;lt;body&amp;gt; &amp;lt;a href=&#39;&amp;quot; + getLoginURL(state) + &amp;quot;&#39;&amp;gt;&amp;lt;button&amp;gt;Login with Google!&amp;lt;/button&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;))
}

func main() {
    router := gin.Default()
    router.Use(sessions.Sessions(&amp;quot;goquestsession&amp;quot;, store))
    router.Static(&amp;quot;/css&amp;quot;, &amp;quot;./static/css&amp;quot;)
    router.Static(&amp;quot;/img&amp;quot;, &amp;quot;./static/img&amp;quot;)
    router.LoadHTMLGlob(&amp;quot;templates/*&amp;quot;)

    router.GET(&amp;quot;/&amp;quot;, indexHandler)
    router.GET(&amp;quot;/login&amp;quot;, loginHandler)
    router.GET(&amp;quot;/auth&amp;quot;, authHandler)

    router.Run(&amp;quot;127.0.0.1:9090&amp;quot;)
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is it folks. I hope this helped. Any comments or advices are welcomed.&lt;/p&gt;

&lt;h1 id=&#34;google-api-documentation&#34;&gt;Google API Documentation&lt;/h1&gt;

&lt;p&gt;The documentation to this whole process, and MUCH more information can be found here: &lt;a href=&#34;https://developers.google.com/identity/protocols/OAuth2&#34;&gt;Google API Docs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thanks for reading,
Gergely.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Minecraft world automatic backup to AWS S3 bucket - Part 2 (Custom functions)</title>
      <link>https://skarlso.github.io/2016/04/17/minecraft-server-aws-s3-backup-part2</link>
      <pubDate>Sun, 17 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/04/17/minecraft-server-aws-s3-backup-part2</guid>
      <description>&lt;p&gt;Hi folks.&lt;/p&gt;

&lt;p&gt;Got an update for the backup script. This time, you&amp;rsquo;ll have the ability to implement your own upload capabilities. I provide a mock implementation for the required functions.&lt;/p&gt;

&lt;p&gt;Here is the script again, now modified and a bit cleaned up. I hope it&amp;rsquo;s helpful.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

if [[ -t 1 ]]; then
    colors=$(tput colors)
    if [[ $colors ]]; then
        RED=&#39;\033[0;31m&#39;
        LIGHT_GREEN=&#39;\033[1;32m&#39;
        NC=&#39;\033[0m&#39;
    fi
fi

if [[ -z ${MINECRAFT_BUCKET} ]]; then
    printf &amp;quot;Please set the env variable %bMINECRAFT_BUCKET%b to the s3 archive bucket name.\n&amp;quot; &amp;quot;${RED}&amp;quot; &amp;quot;${NC}&amp;quot;
    exit 1
fi

if [[ -z ${MINECRAFT_ARCHIVE_LIMIT} ]]; then
    printf &amp;quot;Please set the env variable %bMINECRAFT_ARCHIVE_LIMIT%b to limit the number of archives to keep.\n&amp;quot; &amp;quot;${RED}&amp;quot; &amp;quot;${NC}&amp;quot;
    exit 1
fi

if [[ -z ${MINECRAFT_WORLD} ]]; then
    printf &amp;quot;Please set the env variable %bMINECRAFT_WORLD%b to specify what world to back-up.\n&amp;quot; &amp;quot;${RED}&amp;quot; &amp;quot;${NC}&amp;quot;
    exit 1
fi

backup_world=${MINECRAFT_WORLD}
backup_bucket=${MINECRAFT_BUCKET}
backup_limit=${MINECRAFT_ARCHIVE_LIMIT}
archive_name=&amp;quot;${backup_world}-$(date +&amp;quot;%H-%M-%S-%m-%d-%Y&amp;quot;).zip&amp;quot;

function create_archive {
    printf &amp;quot;Creating archive of %b${backup_world}%b\n&amp;quot; &amp;quot;${RED}&amp;quot; &amp;quot;${NC}&amp;quot;
    zip -r $archive_name $backup_world
}

function amazon_bak {

    create_archive

    printf &amp;quot;Checking if bucket has more than %b${backup_limit}%b files already.\n&amp;quot; &amp;quot;${RED}&amp;quot; &amp;quot;${NC}&amp;quot;
    content=( $(aws s3 ls s3://$backup_bucket | awk &#39;{print $4}&#39;) )

    if [[ ${#content[@]} -eq $backup_limit || ${#content[@]} -gt $backup_limit  ]]; then
        echo &amp;quot;There are too many archives. Deleting oldest one.&amp;quot;
        # We can assume here that the list is in cronological order
    	printf &amp;quot;%bs3://${backup_bucket}/${content[0]}\n%b&amp;quot; &amp;quot;${RED}&amp;quot; &amp;quot;${NC}&amp;quot;
        aws s3 rm s3://$backup_bucket/${content[0]}
    fi

    printf &amp;quot;Uploading %b${archive_name}%b to s3 archive bucket.\n&amp;quot; &amp;quot;${RED}&amp;quot; &amp;quot;${NC}&amp;quot;
    state=$(aws s3 cp $archive_name s3://$backup_bucket)

    if [[ &amp;quot;$state&amp;quot; =~ &amp;quot;upload:&amp;quot; ]]; then
        printf &amp;quot;File upload %bsuccessful%b.\n&amp;quot; &amp;quot;${LIGHT_GREEN}&amp;quot; &amp;quot;${NC}&amp;quot;
    else
        printf &amp;quot;%bError%b occured while uploading archive. Please investigate.\n&amp;quot; &amp;quot;${RED}&amp;quot; &amp;quot;${NC}&amp;quot;
    fi
}

function custom {
    if [[ -e custom.sh ]]; then
        source ./custom.sh
    else
        echo &amp;quot;custom.sh script not found. Please implement the apropriate functions.&amp;quot;
        exit 1
    fi

    echo &amp;quot;Checking for the number of files. Limit is: $backup_limit.&amp;quot;
    files=( $(list) )
    if [[ ${#files[@]} -eq $backup_limit || ${#files[@]} -gt $backup_limit ]]; then
        echo &amp;quot;Deleting extra file.&amp;quot;
        delete ${files[0]}
        if [[ $? != 0 ]]; then
            printf &amp;quot;%bFailed%b to delete file. Please investigate failure.&amp;quot; &amp;quot;${RED}&amp;quot; &amp;quot;${NC}&amp;quot;
            exit $?
        fi
    fi

    echo &amp;quot;Zipping world.&amp;quot;
    create_archive

    echo &amp;quot;Uploading world.&amp;quot;
    upload $archive_name

    if [[ $? != 0 ]]; then
        printf &amp;quot;%bFailed%b to upload archive. Please investigate the error.&amp;quot; &amp;quot;${RED}&amp;quot; &amp;quot;${NC}&amp;quot;
        exit $?
    fi

    printf &amp;quot;Upload %bsuccessful%b&amp;quot; &amp;quot;${LIGHT_GREEN}&amp;quot; &amp;quot;${NC}&amp;quot;
}

function help {
    echo &amp;quot;Usage:&amp;quot;
    echo &amp;quot;./backup_world [METHOD]&amp;quot;
    echo &amp;quot;Exp.: ./backup_world aws|./backup_world custom|./backup_world dropbox&amp;quot;
    echo &amp;quot;Each method has it&#39;s own environment properties that it requires.&amp;quot;
    echo &amp;quot;Global: MINECRAFT_WORLD|MINECRAFT_BUCKET|MINECRAFT_ARCHIVE_LIMIT&amp;quot;
    echo &amp;quot;Custom: Have a file, called &#39;custom.sh&#39; which is sourced.&amp;quot;
    echo &amp;quot;Implement these three functions: upload | list | delete.&amp;quot;
    echo &amp;quot;upload -&amp;gt; should return exit code 0 on success, should return exit code 1 on failure.&amp;quot;
    echo &amp;quot;list -&amp;gt; should return a list of cronologically ordered items.&amp;quot;
    echo &amp;quot;delete -&amp;gt; should return exit code 0 on success, should return exit code 1 on failure.&amp;quot;
}

case $1 in
    aws )
        amazon_bak
        ;;
    custom )
        custom
        ;;
    * )
        help
        ;;
esac
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here is the sample implementation for the custom upload functionality.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

function upload {
    echo &amp;quot;uploading&amp;quot;
    local result=0
    return $result
}

function delete {
    echo &amp;quot;deleting $1&amp;quot;
    local result=0
    return $result
}

function list {
    local arr=(&amp;quot;file1&amp;quot; &amp;quot;file2&amp;quot; &amp;quot;file3&amp;quot;)
    echo &amp;quot;${arr[@]}&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thanks for reading!&lt;/p&gt;

&lt;p&gt;Gergely.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Minecraft world automatic backup to AWS S3 bucket</title>
      <link>https://skarlso.github.io/2016/04/16/minecraft-server-aws-s3-backup</link>
      <pubDate>Sat, 16 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/04/16/minecraft-server-aws-s3-backup</guid>
      <description>&lt;p&gt;Hi Folks.&lt;/p&gt;

&lt;p&gt;Previously we created a Minecraft server using Docker. After my server got popular in the family, and a lot of stuff started to pile up on it, as a good IT person, I&amp;rsquo;m backing up the world once in a while.&lt;/p&gt;

&lt;p&gt;For that, I&amp;rsquo;m using AWS S3 with the CLI and a little bash script which runs once a week.&lt;/p&gt;

&lt;p&gt;The script is really straightforward. I&amp;rsquo;m doing manual versioning, although S3 does provide one out of the box. However, amazon&amp;rsquo;s S3 versioning doesn&amp;rsquo;t allow limiting the number of versions being kept. And since I&amp;rsquo;m doing that anyways, might as well take care of the rest.&lt;/p&gt;

&lt;p&gt;Without further ado, here is the script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

if [[ -t 1 ]]; then
    colors=$(tput colors)
    if [[ $colors ]]; then
        RED=&#39;\033[0;31m&#39;
        LIGHT_GREEN=&#39;\033[1;32m&#39;
        NC=&#39;\033[0m&#39;
    fi
fi

if [[ -z ${MINECRAFT_BUCKET} ]]; then
	printf &amp;quot;Please set the env variable ${RED}MINECRAFT_BUCKET${NC} to the s3 archive bucket name.\n&amp;quot;
	exit 0
fi

if [[ -z ${MINECRAFT_ARCHIVE_LIMIT} ]]; then
	printf &amp;quot;Please set the env variable ${RED}MINECRAFT_ARCHIVE_LIMIT${NC} to limit the number of archives to keep.\n&amp;quot;
	exit 0
fi

backup_bucket=${MINECRAFT_BUCKET}
backup_limit=${MINECRAFT_ARCHIVE_LIMIT}
world=$1
printf &amp;quot;Creating archive of ${RED}${world}${NC}\n&amp;quot;
archive_name=&amp;quot;${world}-$(date +&amp;quot;%H-%M-%S-%m-%d-%Y&amp;quot;).zip&amp;quot;
zip -r $archive_name $world

printf &amp;quot;Checking if bucket has more than ${RED}${backup_limit}${NC} files already.\n&amp;quot;
content=( $(aws s3 ls s3://$backup_bucket | awk &#39;{print $4}&#39;) )

if [[ ${#content[@]} -eq $backup_limit || ${#content[@]} -gt $backup_limit  ]]; then
    echo &amp;quot;There are too many archives. Deleting oldest one.&amp;quot;
    # We can assume here that the list is in cronological order
	printf &amp;quot;${RED}s3://${backup_bucket}/${content[0]}\n&amp;quot;
    aws s3 rm s3://$backup_bucket/${content[0]}
fi

printf &amp;quot;Uploading ${RED}${archive_name}${NC} to s3 archive bucket.\n&amp;quot;
state=$(aws s3 cp $archive_name s3://$backup_bucket)

if [[ &amp;quot;$state&amp;quot; =~ &amp;quot;upload:&amp;quot; ]]; then
    printf &amp;quot;File upload ${LIGHT_GREEN}successful${NC}.\n&amp;quot;
else
    printf &amp;quot;${RED}Error${NC} occured while uploading archive. Please investigate.\n&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It uses environment properties to define where to upload the given world and how many versions to keep.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m calling this from a cron job, and it&amp;rsquo;s sitting next to where the Minecraft world is.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it folks.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll start expanding on this idea and implement various services, like your own server address, or dropbox, or what have you.&lt;/p&gt;

&lt;p&gt;Happy backing up.&lt;/p&gt;

&lt;p&gt;Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Minecraft Server with Docker on OSX &#43; Mods</title>
      <link>https://skarlso.github.io/2016/03/29/minecraft-server-with-docker-and-osx</link>
      <pubDate>Tue, 29 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/03/29/minecraft-server-with-docker-and-osx</guid>
      <description>

&lt;p&gt;Hi Folks.&lt;/p&gt;

&lt;h1 id=&#34;intro&#34;&gt;Intro&lt;/h1&gt;

&lt;p&gt;Today, I wanted to write about how to create a secure server in a container. Ideally, you don&amp;rsquo;t want to run your server on your own machine. Running it in a container gives you a much needed control and an extra layer of security.&lt;/p&gt;

&lt;h1 id=&#34;docker-on-osx&#34;&gt;Docker On OSX&lt;/h1&gt;

&lt;p&gt;While on a mac, you have a couple of options to run docker.&lt;/p&gt;

&lt;h2 id=&#34;docker-machine&#34;&gt;Docker-Machine&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/machine/&#34;&gt;Docker-Machine&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Docker machine is very simple. It just creates a Linux vm in the background on the given driver, for us it will be &lt;a href=&#34;https://www.virtualbox.org/&#34;&gt;VirtualBox&lt;/a&gt;. Network, Memory and port-forwarding can all be managed through the VM directly. Then running and starting it is trivial through &lt;code&gt;docker-machine start&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;boot2docker&#34;&gt;Boot2Docker&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://boot2docker.io/&#34;&gt;Boot2Docker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Runs a tiny linux in which you can use Docker freely. This adds the benefit of not having to mess around with VirtualBox.&lt;/p&gt;

&lt;h2 id=&#34;dlite&#34;&gt;DLite&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/nlf/dlite&#34;&gt;DLite&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;DLite is the newest addition in the Game. Since docker uses /var/run/docker.sock file to communicate with the daemon, and this file is not there on OSX, DLite takes care of that. After DLite is running, you just simply use Docker. That&amp;rsquo;s it. No VM, no fuss, just use Docker.&lt;/p&gt;

&lt;p&gt;I recommend to use DLite, however, it&amp;rsquo;s not an official tool, so for the sake of this guide, I&amp;rsquo;ll be writing up a docker-machine oriented solution.&lt;/p&gt;

&lt;h1 id=&#34;docker-container-a-vanilla-server&#34;&gt;Docker container - A Vanilla Server&lt;/h1&gt;

&lt;p&gt;First, you&amp;rsquo;ll need a Dockerfile. &lt;a href=&#34;https://github.com/Skarlso/devops/blob/master/minecraft/Dockerfile&#34;&gt;Dockerfile&lt;/a&gt;. The steps on how to setup this file are written down in the README file, located here: &lt;a href=&#34;https://github.com/Skarlso/devops/tree/master/minecraft&#34;&gt;Container Setup&lt;/a&gt;. The &lt;code&gt;pwd&lt;/code&gt; command will use your current directory as a shared volume to copy stuff into the container from your host operating system.&lt;/p&gt;

&lt;p&gt;This will download the Minecraft server version 1.9 (or whichever you define) and install java and vim. It uses /data as a shared folder. Data will also be the working directory which means we will run the server from there. This server will be a vanilla server, meaning, no modding. If you have a single player world which you would like to use, simply copy that to /data and rename it to &lt;em&gt;world&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The tricky part is to make this available on the internet. Because the container is in a VM we need to do a chain forwarding. Forward from the container to the vm, and from the vm to your host machine. If you are using a dns service like dyna or no-ip, you probably have a software which refreshes an IP for you to link to. And you&amp;rsquo;ll also have port forwarding setup on your router. I won&amp;rsquo;t be going into detail on that part. That&amp;rsquo;s a whole different post.&lt;/p&gt;

&lt;p&gt;Forwarding from virtualbox can be done through the UI or through command line. The UI is like this: &lt;em&gt;Settings =&amp;gt; Network =&amp;gt; Adapter 1 =&amp;gt; Advanced =&amp;gt; PortForwarding&lt;/em&gt;. Here, setup something like this:
Name: Minecraft; Protocol: TCP; Host IP: 192.168.0.X(x=your local machine); Host Port: 25565; Guest IP: Leave Blank; Guest Port: 25565.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://skarlso.github.io/img/network.png&#34; alt=&#34;Network&#34; /&gt;
Where the number is missing, you&amp;rsquo;ll have to define your own local IP which you are using for your domain address.&lt;/p&gt;

&lt;p&gt;This should forward any ports coming from your VM to your local IP. In the container we have an expose and as the README states it&amp;rsquo;s started using -p 25565:25565 which will make sure that from the container, 25565 is exposed to the VM. And from the VM 25565 is exposed to your local. Chain forwarding.&lt;/p&gt;

&lt;p&gt;After that, once you start your server, it should all click together and you should have a running vanilla Minecraft server available under &lt;a href=&#34;http://yourdomain:25565&#34;&gt;http://yourdomain:25565&lt;/a&gt;. You won&amp;rsquo;t be able to check this by default on your own network. Check if the port is open with a different service like: &lt;a href=&#34;http://www.yougetsignal.com/tools/open-ports/&#34;&gt;Check If Port is Open&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;docker-container-modding&#34;&gt;Docker container - Modding&lt;/h1&gt;

&lt;p&gt;If you are not looking for anything, just a simple server, the above will be enough. You can still do /tp 1 1 1 to teleport, or can still use bans and op commands, and distribute items. However, if you would like to use mods, and as far as kids are concerned, they will want it, you&amp;rsquo;ll have to be a bit more clever.&lt;/p&gt;

&lt;p&gt;I dug far and deep and found that you have two options. Either go with a Forge server, or a Bukkit server. What does that mean? The vanilla server of Minecraft does not support modding. Modding, is modifying the implementation of Minecraft. It injects code and runs a pre-server in front of the original Minecraft server in order to append functionality. But fret not, this is all taken care of for you by either solutions.&lt;/p&gt;

&lt;p&gt;In order to jump into our container with the CMD omitted, we&amp;rsquo;ll have to run the following command instead of the one in the README.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -it -v `pwd`:/data -p 25565:25565 --name mc_server minecraft:v1.9 bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will give you an interactive prompt in which now we can operate.&lt;/p&gt;

&lt;h2 id=&#34;forge&#34;&gt;Forge&lt;/h2&gt;

&lt;p&gt;Download the latest forge version from here =&amp;gt; &lt;a href=&#34;http://files.minecraftforge.net/&#34;&gt;Minecraft Forge&lt;/a&gt;. They are usually up-to-date. I&amp;rsquo;m using 1.9 so I downloaded the appropriate installer version. After I obtained it, it was a matter of running this piece of command line code from my container:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;java -jar forge-1.9-12.16.0.1813-1.9-installer.jar --extract --installServer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will unpack a bunch of things you don&amp;rsquo;t have to worry about in your current directory, which is /data. Now run the universal.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;java -jar forge-1.9-12.16.0.1813-1.9-universal.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Everything under the &lt;strong&gt;mods&lt;/strong&gt; folder will be loaded as a mod. Forge is very restrictive and can only use Forge based mods. It will usually warn you if you have a none forge mod in your mods folder. You can find these on Forge&amp;rsquo;s forum here: &lt;a href=&#34;http://www.minecraftforge.net/forum/index.php/board,30.0.html&#34;&gt;Forge Forum&lt;/a&gt;. Simply download a jar and put it into /data/mods.&lt;/p&gt;

&lt;h2 id=&#34;bukkit&#34;&gt;Bukkit&lt;/h2&gt;

&lt;p&gt;I found Bukkit to be the winner for me. Most of the mods the kid wanted worked with Bukkit and did not work with Forge. Others will swear on Forge, but it&amp;rsquo;s really up to you. Using Bukkit is similarly easy. Again, you&amp;rsquo;ll have to find and get the wrapper for your Minecraft version, which can be located here: &lt;a href=&#34;http://getspigot.org/&#34;&gt;GetSpigot&lt;/a&gt;. You can use Spigot as well, though I have no experience with that.&lt;/p&gt;

&lt;p&gt;Once, you got the wrapper, which is called &lt;code&gt;craftbukkit-1.9.jar&lt;/code&gt; for me, you run it the same way you would run Forge or Minecraft.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;java -jar craftbukkit-1.9.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will load mods from the &lt;strong&gt;plugins&lt;/strong&gt; folder. Plugins can be found here: &lt;a href=&#34;http://mods.curse.com/bukkit-plugins/minecraft/new&#34;&gt;Latest Bukkit Plugins&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the container, you can use wget or curl to get the mods, or simply use the shared volume which is setup for you.&lt;/p&gt;

&lt;h1 id=&#34;last-words&#34;&gt;Last Words&lt;/h1&gt;

&lt;p&gt;All in all this sounds complicated, but it&amp;rsquo;s actually not, once you&amp;rsquo;ll get the hang out of it. You never kill the container once it&amp;rsquo;s setup, you just do &lt;code&gt;docker stop mc_server&lt;/code&gt; and then &lt;code&gt;docker-machine stop&lt;/code&gt; if you want to stop the VM as well. To start it up simply do these steps:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker_machine start
eval $(docker-machine env)
docker start mc_server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We named the container mc_server on a previous step. If you named it something different, use that name.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it. Hope this was clear. Any feedback is appreciated. If you think you have an easier way, or if I wrote something incorrectly, feel free to tell me in the comment sections below.&lt;/p&gt;

&lt;p&gt;Thanks for reading.&lt;/p&gt;

&lt;p&gt;Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Wercker Fixed</title>
      <link>https://skarlso.github.io/2016/03/09/wercker-fixed</link>
      <pubDate>Wed, 09 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/03/09/wercker-fixed</guid>
      <description>&lt;p&gt;Hi Folks.&lt;/p&gt;

&lt;p&gt;So Wercker was not working. After a minor modification it seems to be okay now. The config file needed for it to work looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;box: golang 
build:
    steps:
        - arjen/hugo-build:
            theme: redlounge
deploy:
    steps:
        - install-packages:
            packages: git 
        - leipert/git-push:
            gh_oauth: $GIT_TOKEN
            repo: skarlso/skarlso.github.io
            branch: master
            basedir: public    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The modification is the box type to &lt;em&gt;golang&lt;/em&gt; and removed &lt;em&gt;ssh-client&lt;/em&gt; from &lt;em&gt;packages&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Thanks,
Gergely.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>