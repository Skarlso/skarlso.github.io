<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Ramblings of a build engineer</title>
    <link>https://skarlso.github.io/posts/</link>
    <description>Recent content in Posts on Ramblings of a build engineer</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 19 Aug 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://skarlso.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Always Go with []byte</title>
      <link>https://skarlso.github.io/2016/08/19/always-go-with-bytes</link>
      <pubDate>Fri, 19 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/08/19/always-go-with-bytes</guid>
      <description>&lt;p&gt;Another quick reminder&amp;hellip; Always go with []byte if possible. I said it before, and I&amp;rsquo;m going to say it over and over again. It&amp;rsquo;s crucial.&lt;/p&gt;

&lt;p&gt;Here is a little code from exercism.io. First, with strings:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package igpay

import (
    &amp;quot;strings&amp;quot;
)

// PigLatin translates reguler old English into awesome pig-latin.
func PigLatin(in string) (ret string) {
    for _, v := range strings.Fields(in) {
        ret += pigLatin(v) + &amp;quot; &amp;quot;
    }

    return strings.Trim(ret, &amp;quot; &amp;quot;)
}

func pigLatin(in string) (ret string) {
    if strings.IndexAny(in, &amp;quot;aeiou&amp;quot;) == 0 {
        ret += in + &amp;quot;ay&amp;quot;
        return
    }

    for i := 0; i &amp;lt; len(in); i++ {
        vowelPos := strings.IndexAny(in, &amp;quot;aeiou&amp;quot;)

        if (in[0] == &#39;y&#39; || in[0] == &#39;x&#39;) &amp;amp;&amp;amp; vowelPos &amp;gt; 1 {
            vowelPos = 0
            ret = in
        }
        if vowelPos != 0 {
            adjustPosition := vowelPos

            if in[adjustPosition] == &#39;u&#39; &amp;amp;&amp;amp; in[adjustPosition - 1] == &#39;q&#39; {
                adjustPosition++
            }

            ret = in[adjustPosition:] + in[:adjustPosition]
        }
    }
    ret += &amp;quot;ay&amp;quot;
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Than with []byte:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package igpay

import (
    // &amp;quot;fmt&amp;quot;
    &amp;quot;bytes&amp;quot;
)

// PigLatin translates reguler old English into awesome pig-latin.
func PigLatin(in string) (ret string) {
    inBytes := []byte(in)
    var retBytes [][]byte
    for _, v := range bytes.Fields(inBytes) {
        v2 := make([]byte, len(v))
        copy(v2, v)
        retBytes = append(retBytes, pigLatin(v2))
    }

    ret = string(bytes.Join(retBytes, []byte(&amp;quot; &amp;quot;)))
    return
}

func pigLatin(in []byte) (ret []byte) {
    if bytes.IndexAny(in, &amp;quot;aeiou&amp;quot;) == 0 {
        ret = append(in, []byte(&amp;quot;ay&amp;quot;)...)
        return
    }

    for i := 0; i &amp;lt; len(in); i++ {
        vowelPos := bytes.IndexAny(in, &amp;quot;aeiou&amp;quot;)

        if (in[0] == &#39;y&#39; || in[0] == &#39;x&#39;) &amp;amp;&amp;amp; vowelPos &amp;gt; 1 {
            vowelPos = 0
            ret = in
        }
        if vowelPos != 0 {
            adjustPosition := vowelPos

            if in[adjustPosition] == &#39;u&#39; &amp;amp;&amp;amp; in[adjustPosition - 1] == &#39;q&#39; {
                adjustPosition++
            }

            in = append(in[adjustPosition:], in[:adjustPosition]...)
            ret = in
            // fmt.Printf(&amp;quot;%s\n&amp;quot;, ret)
        }
    }
    ret = append(ret, []byte(&amp;quot;ay&amp;quot;)...)
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And than,the benchmarks of course:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;BenchmarkPigLatin-8          	  200000	     10688 ns/op
BenchmarkPigLatinStrings-8   	  100000	     15211 ns/op
PASS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The improvement is not massive in this case, but it&amp;rsquo;s more than enough to matter. And in a bigger, more complicated program, string concatenation will take a LOT of time away.&lt;/p&gt;

&lt;p&gt;In Go, the &lt;code&gt;bytes&lt;/code&gt; package has a 1-1 map compared to the &lt;code&gt;strings&lt;/code&gt; packages, so chances are, if you are doing strings concatenations you will be able to port that piece of code easily to []byte.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all folks.&lt;/p&gt;

&lt;p&gt;Happy coding,
Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Global variable for never changing regex</title>
      <link>https://skarlso.github.io/2016/08/16/never-changing-regex</link>
      <pubDate>Tue, 16 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/08/16/never-changing-regex</guid>
      <description>&lt;p&gt;Quick reminder. If you have a never changing regex in Go, do NOT put it into a frequently called function. ALWAYS put it into a global variable. I&amp;rsquo;ll show you why.&lt;/p&gt;

&lt;p&gt;Benchmark for code with a variable in a frequently called function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;BenchmarkNumber-8     	   30000	     41633 ns/op
BenchmarkAreaCode-8   	   50000	     27736 ns/op
BenchmarkFormat-8     	   50000	     29263 ns/op
PASS
ok  	_/phone-number	5.110s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Benchmark for code with the same variable outside in a global scope:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;BenchmarkNumber-8     	  300000	      5618 ns/op
BenchmarkAreaCode-8   	  500000	      3884 ns/op
BenchmarkFormat-8     	  300000	      4696 ns/op
PASS
ok  	_/phone-number	5.197s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the magnitude change in ns/op! That&amp;rsquo;s something to keep an eye out for.&lt;/p&gt;

&lt;p&gt;Thanks for reading!
Cheers,
Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Drupal missing ToolBar and settings not saving</title>
      <link>https://skarlso.github.io/2016/08/13/drupal-missing-toolbar-and-settings-not-saving</link>
      <pubDate>Sat, 13 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/08/13/drupal-missing-toolbar-and-settings-not-saving</guid>
      <description>&lt;p&gt;Hi folks.&lt;/p&gt;

&lt;p&gt;Quick gotcha, when working with Drupal. If you just freshly installed it, and everything seems to work fine, and yet you are experiencing things like, the admin toolbar is randomly disappearing, or configuration is not saved; than you might not have modrewrite enabled on your apache server.&lt;/p&gt;

&lt;p&gt;Because, by default, Drupal has clean url enabled, that needs URL rewriting on apache.&lt;/p&gt;

&lt;p&gt;So, step one.&lt;/p&gt;

&lt;p&gt;Have this in your .htaccess file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;lt;IfModule mod_rewrite.c&amp;gt;
  RewriteEngine on
  ... # and than a bunch of rewrite rules according to your leisure
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Than look up this line in your httpd.conf file and remove the prefix &amp;lsquo;#&amp;rsquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#LoadModule rewrite_module libexec/apache2/mod_rewrite.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is all. From there on, everything should work. If, you don&amp;rsquo;t want the clean url setting, yet you can&amp;rsquo;t disable it, and don&amp;rsquo;t want to restart the server and edit the settings.php file; use drush like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;drush vset clean_url 0 --yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should disable it and bust the cache in the process so it&amp;rsquo;s immediately visible.&lt;/p&gt;

&lt;p&gt;That is all folks.&lt;/p&gt;

&lt;p&gt;Cheers,
Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jenkins Best Practices Talk</title>
      <link>https://skarlso.github.io/2016/07/28/jenkins-best-practices</link>
      <pubDate>Thu, 28 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/07/28/jenkins-best-practices</guid>
      <description>&lt;p&gt;Hi folks.&lt;/p&gt;

&lt;p&gt;I wanted to take the time to share with you a talk that I recently did.&lt;/p&gt;

&lt;p&gt;The slides and the source I used, can be found here: &lt;a href=&#34;https://github.com/Skarlso/jenkinsbestpractices&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;And then, there is also a docker image which contains all the plugins, job configurations and all the practices which I did during the talk. Please feel free to have a go with it. &lt;a href=&#34;https://hub.docker.com/r/skarlso/jenkinsbestpractices&#34;&gt;DockerHub - Jenkins Best Practices&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For easy access and reading, here are the slides on Slideshare: &lt;a href=&#34;http://www.slideshare.net/GergelyBrautigam/jenkins-best-practices-meetup-slides&#34;&gt;Jenkins Best Practices Slides&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I, gladly answer any questions which should arise.&lt;/p&gt;

&lt;p&gt;Thanks!
Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ruby Sieve</title>
      <link>https://skarlso.github.io/2016/07/12/ruby-sieve</link>
      <pubDate>Tue, 12 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/07/12/ruby-sieve</guid>
      <description>&lt;p&gt;Though it could be done better, I&amp;rsquo;m sure, but I&amp;rsquo;m actually pretty satisfied with this one. It loops only twice as opposed to filtered ranges and whatnot other solutions to the sieve. I was thinking of rather creating a list and deleting elements from it, but that&amp;rsquo;s already three loops.&lt;/p&gt;

&lt;p&gt;Maybe I&amp;rsquo;ll do a benchmark later on more solutions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Sieve contains a function to return a set of primes
class Sieve
  def initialize(n)
    @n = n
  end

  # Returns a list of primes up to a certain limit
  # @param n limit
  # @return list of primes
  def primes
    marked = []
    primes = []
    (2..@n).each do |e|
      unless marked.include?(e)
        primes.push e
        (e..@n).step(e) { |s| marked.push s }
      end
    end
    primes
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cheers,
Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Simple hook to rid of trouble</title>
      <link>https://skarlso.github.io/2016/07/12/simple-hook-to-rid-of-trouble</link>
      <pubDate>Tue, 12 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/07/12/simple-hook-to-rid-of-trouble</guid>
      <description>&lt;p&gt;Hi folks.&lt;/p&gt;

&lt;p&gt;This is but a simple git hook to run a test in order to ensure you can push. It also ignores the vendor folder if you happen to have on in your directory.&lt;/p&gt;

&lt;p&gt;Edit the file under &lt;code&gt;.git/hooks/pre-push.sample&lt;/code&gt; and add this at the end before the &lt;code&gt;exit 0&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go test $(go list ./... |grep -v vendor)
RESULT=$?
if [ $RESULT -ne 0 ]; then
    echo &amp;quot;Failed test run. Disallowing push.&amp;quot;
    exit 1
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After this, rename the file to &lt;code&gt;pre-push&lt;/code&gt; removing the .sample from it.&lt;/p&gt;

&lt;p&gt;If you now, mess something up, you should see something like this before your push:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# github.com/Skarlso/goprogressquest
./create.go:40: undefined: sha1 in sha1.Sum
./create.go:41: undefined: fmt in fmt.Sprintf
./create.go:115: undefined: json in json.Unmarshal
./create.go:130: undefined: json in json.Unmarshal
FAIL	github.com/Skarlso/goprogressquest [build failed]
Failed test run. Disallowing push.
error: failed to push some refs to &#39;git@github.com:Skarlso/goprogressquest.git&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is all.&lt;/p&gt;

&lt;p&gt;Cheers,
Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to do Google sign-in with Go</title>
      <link>https://skarlso.github.io/2016/06/12/google-signin-with-go</link>
      <pubDate>Sun, 12 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/06/12/google-signin-with-go</guid>
      <description>

&lt;p&gt;Hi folks.&lt;/p&gt;

&lt;p&gt;Today, I would like to write up a step - by - step guide with a sample web app on how to do Google Sign-In and authorization.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started.&lt;/p&gt;

&lt;h1 id=&#34;setup&#34;&gt;Setup&lt;/h1&gt;

&lt;h2 id=&#34;google-oauth-token&#34;&gt;Google OAuth token&lt;/h2&gt;

&lt;p&gt;First what you need is, to register your application with Google, so you&amp;rsquo;ll get a Token that you can use to authorize later calls to Google services.&lt;/p&gt;

&lt;p&gt;You can do that here: &lt;a href=&#34;https://console.developers.google.com/iam-admin/projects&#34;&gt;Google Developer Console&lt;/a&gt;. You&amp;rsquo;ll have to create a new project. Once it&amp;rsquo;s done, click on &lt;code&gt;Credentials&lt;/code&gt; and create an OAuth token. You should see something like this: &amp;ldquo;To create an OAuth client ID, you must first set a product name on the consent screen.&amp;rdquo;. Go through the questions, like, what type your application is, and once you arrive at stage where it&amp;rsquo;s asking for your application&amp;rsquo;s name &amp;ndash; there is a section asking for redirect URLs; there, write the url you wish to use when authorising your user. If you don&amp;rsquo;t know this yet, don&amp;rsquo;t fret, you can come back and change it later. Do NOT use &lt;code&gt;localhost&lt;/code&gt;. If you are running on your own, use &lt;a href=&#34;http://127.0.0.1:port/whatever&#34;&gt;http://127.0.0.1:port/whatever&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This will get you a &lt;code&gt;client ID&lt;/code&gt; and a &lt;code&gt;client secret&lt;/code&gt;. I&amp;rsquo;m going to save these into a file which will sit next to my web app. It could be stored more securely, for example, in a database or a mounted secure, encrypted drive, and so and so forth.&lt;/p&gt;

&lt;p&gt;Your application can now be identified through Google services.&lt;/p&gt;

&lt;h1 id=&#34;the-application&#34;&gt;The Application&lt;/h1&gt;

&lt;h2 id=&#34;libraries&#34;&gt;Libraries&lt;/h2&gt;

&lt;p&gt;Google has a nice library to use with OAuth 2.0. The library is available here: &lt;a href=&#34;https://github.com/golang/oauth2&#34;&gt;Google OAth 2.0&lt;/a&gt;. It&amp;rsquo;s a bit cryptic at first, but not to worry. After a bit of fiddling you&amp;rsquo;ll understand fast what it does. I&amp;rsquo;m also using &lt;a href=&#34;https://github.com/gin-gonic/gin&#34;&gt;Gin&lt;/a&gt;, and Gin&amp;rsquo;s session handling middleware &lt;a href=&#34;https://github.com/gin-gonic/contrib/tree/master/sessions&#34;&gt;Gin-Session&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;setup-credentials&#34;&gt;Setup - Credentials&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s create a setup which configures your credentials from the file you saved earlier. This is pretty straightforward.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Credentials which stores google ids.
type Credentials struct {
    Cid string `json:&amp;quot;cid&amp;quot;`
    Csecret string `json:&amp;quot;csecret&amp;quot;`
}

func init() {
    var c Credentials
    file, err := ioutil.ReadFile(&amp;quot;./creds.json&amp;quot;)
    if err != nil {
        fmt.Printf(&amp;quot;File error: %v\n&amp;quot;, err)
        os.Exit(1)
    }
    json.Unmarshal(file, &amp;amp;c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you have the creds loaded, you can now go on to construct the OAuth client.&lt;/p&gt;

&lt;h2 id=&#34;setup-oauth-client&#34;&gt;Setup - OAuth client&lt;/h2&gt;

&lt;p&gt;Construct the OAuth config like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;conf := &amp;amp;oauth2.Config{
  ClientID:     c.Cid,
  ClientSecret: c.Csecret,
  RedirectURL:  &amp;quot;http://localhost:9090/auth&amp;quot;,
  Scopes: []string{
    &amp;quot;https://www.googleapis.com/auth/userinfo.email&amp;quot;, // You have to select your own scope from here -&amp;gt; https://developers.google.com/identity/protocols/googlescopes#google_sign-in
  },
  Endpoint: google.Endpoint,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will give you a struct which you can then use to Authorize the user in the google domain. Next, all you need to do is call &lt;code&gt;AuthCodeURL&lt;/code&gt; on this config. It will give you a URL which redirects to a Google Sign-In form. Once the user fills that out and clicks &amp;lsquo;Allow&amp;rsquo;, you&amp;rsquo;ll get back a TOKEN in the &lt;code&gt;code&lt;/code&gt; query parameter and a &lt;code&gt;state&lt;/code&gt; which helps protect against CSRF attacks. Always check if the provided state is the same which you provided with AuthCodeURL. This will look something like this &lt;code&gt;http://127.0.0.1:9090/auth?code=4FLKFskdjflf3343d4f&amp;amp;state=lhfu3f983j;asdf&lt;/code&gt;. Small function for this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func getLoginURL(state string) string {
    // State can be some kind of random generated hash string.
    // See relevant RFC: http://tools.ietf.org/html/rfc6749#section-10.12
    return conf.AuthCodeURL(state)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Construct a button which the user can click and be redirected to the Google Sign-In form. When constructing the url, we must do one more thing. Create a secure state token and save it in the form of a cookie for the current user.&lt;/p&gt;

&lt;h2 id=&#34;random-state-and-button-construction&#34;&gt;Random State and Button construction&lt;/h2&gt;

&lt;p&gt;Small piece of code random token:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func randToken() string {
	b := make([]byte, 32)
	rand.Read(b)
	return base64.StdEncoding.EncodeToString(b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Storing it in a session and constructing the button:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func loginHandler(c *gin.Context) {
    state = randToken()
    session := sessions.Default(c)
    session.Set(&amp;quot;state&amp;quot;, state)
    session.Save()
    c.Writer.Write([]byte(&amp;quot;&amp;lt;html&amp;gt;&amp;lt;title&amp;gt;Golang Google&amp;lt;/title&amp;gt; &amp;lt;body&amp;gt; &amp;lt;a href=&#39;&amp;quot; + getLoginURL() + &amp;quot;&#39;&amp;gt;&amp;lt;button&amp;gt;Login with Google!&amp;lt;/button&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s not the nicest button I ever come up with, but it will have to do.&lt;/p&gt;

&lt;h1 id=&#34;user-information&#34;&gt;User Information&lt;/h1&gt;

&lt;p&gt;After you got the token, you can construct an authorised Google HTTP Client, which let&amp;rsquo;s you call Google related services and retrieve information about the user.&lt;/p&gt;

&lt;h2 id=&#34;getting-the-client&#34;&gt;Getting the Client&lt;/h2&gt;

&lt;p&gt;Before we construct a client, we must check if the retrieved state is still the same compared to the one we provided. I&amp;rsquo;m doing this before constructing the client. Together this looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func authHandler(c *gin.Context) {
    // Check state validity.
    session := sessions.Default(c)
    retrievedState := session.Get(&amp;quot;state&amp;quot;)
    if retrievedState != c.Query(&amp;quot;state&amp;quot;) {
        c.AbortWithError(http.StatusUnauthorized, fmt.Errorf(&amp;quot;Invalid session state: %s&amp;quot;, retrievedState))
        return
    }
    // Handle the exchange code to initiate a transport.
  	tok, err := conf.Exchange(oauth2.NoContext, c.Query(&amp;quot;code&amp;quot;))
  	if err != nil {
  		c.AbortWithError(http.StatusBadRequest, err)
          return
  	}
    // Construct the client.
    client := conf.Client(oauth2.NoContext, tok)
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;obtaining-information&#34;&gt;Obtaining information&lt;/h2&gt;

&lt;p&gt;Our next step is to retrieve information about the user. To achieve this, call Google&amp;rsquo;s API with the authorised client. The code for that is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;...
resp, err := client.Get(&amp;quot;https://www.googleapis.com/oauth2/v3/userinfo&amp;quot;)
if err != nil {
    c.AbortWithError(http.StatusBadRequest, err)
    return
}
defer resp.Body.Close()
data, _ := ioutil.ReadAll(resp.Body)
log.Println(&amp;quot;Resp body: &amp;quot;, string(data))
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this will yield a body like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;sub&amp;quot;: &amp;quot;1111111111111111111111&amp;quot;,
  &amp;quot;name&amp;quot;: &amp;quot;Your Name&amp;quot;,
  &amp;quot;given_name&amp;quot;: &amp;quot;Your&amp;quot;,
  &amp;quot;family_name&amp;quot;: &amp;quot;Name&amp;quot;,
  &amp;quot;profile&amp;quot;: &amp;quot;https://plus.google.com/1111111111111111111111&amp;quot;,
  &amp;quot;picture&amp;quot;: &amp;quot;https://lh3.googleusercontent.com/asdfadsf/AAAAAAAAAAI/Aasdfads/Xasdfasdfs/photo.jpg&amp;quot;,
  &amp;quot;email&amp;quot;: &amp;quot;your@gmail.com&amp;quot;,
  &amp;quot;email_verified&amp;quot;: true,
  &amp;quot;gender&amp;quot;: &amp;quot;male&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Parse it, and you&amp;rsquo;ve got an email which you can store somewhere for registration purposes. At this point, your user is not yet Authenticated. For that, I&amp;rsquo;m going to post a second post, which describes how to go on. Retrieving the stored email address, and user session handling with Gin and MongoDB.&lt;/p&gt;

&lt;h1 id=&#34;putting-it-all-together&#34;&gt;Putting it all together&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;crypto/rand&amp;quot;
    &amp;quot;encoding/base64&amp;quot;
    &amp;quot;encoding/json&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;net/http&amp;quot;

    &amp;quot;github.com/gin-gonic/contrib/sessions&amp;quot;
    &amp;quot;github.com/gin-gonic/gin&amp;quot;
    &amp;quot;golang.org/x/oauth2&amp;quot;
    &amp;quot;golang.org/x/oauth2/google&amp;quot;
)

// Credentials which stores google ids.
type Credentials struct {
    Cid     string `json:&amp;quot;cid&amp;quot;`
    Csecret string `json:&amp;quot;csecret&amp;quot;`
}

// User is a retrieved and authentiacted user.
type User struct {
    Sub string `json:&amp;quot;sub&amp;quot;`
    Name string `json:&amp;quot;name&amp;quot;`
    GivenName string `json:&amp;quot;given_name&amp;quot;`
    FamilyName string `json:&amp;quot;family_name&amp;quot;`
    Profile string `json:&amp;quot;profile&amp;quot;`
    Picture string `json:&amp;quot;picture&amp;quot;`
    Email string `json:&amp;quot;email&amp;quot;`
    EmailVerified string `json:&amp;quot;email_verified&amp;quot;`
    Gender string `json:&amp;quot;gender&amp;quot;`
}

var cred Credentials
var conf *oauth2.Config
var state string
var store = sessions.NewCookieStore([]byte(&amp;quot;secret&amp;quot;))

func randToken() string {
	b := make([]byte, 32)
	rand.Read(b)
	return base64.StdEncoding.EncodeToString(b)
}

func init() {
    file, err := ioutil.ReadFile(&amp;quot;./creds.json&amp;quot;)
    if err != nil {
        log.Printf(&amp;quot;File error: %v\n&amp;quot;, err)
        os.Exit(1)
    }
    json.Unmarshal(file, &amp;amp;cred)

    conf = &amp;amp;oauth2.Config{
        ClientID:     cred.Cid,
        ClientSecret: cred.Csecret,
        RedirectURL:  &amp;quot;http://127.0.0.1:9090/auth&amp;quot;,
        Scopes: []string{
            &amp;quot;https://www.googleapis.com/auth/userinfo.email&amp;quot;, // You have to select your own scope from here -&amp;gt; https://developers.google.com/identity/protocols/googlescopes#google_sign-in
        },
        Endpoint: google.Endpoint,
    }
}

func indexHandler(c *gin.Context) {
    c.HTML(http.StatusOK, &amp;quot;index.tmpl&amp;quot;, gin.H{})
}

func getLoginURL(state string) string {
    return conf.AuthCodeURL(state)
}

func authHandler(c *gin.Context) {
    // Handle the exchange code to initiate a transport.
    session := sessions.Default(c)
    retrievedState := session.Get(&amp;quot;state&amp;quot;)
    if retrievedState != c.Query(&amp;quot;state&amp;quot;) {
        c.AbortWithError(http.StatusUnauthorized, fmt.Errorf(&amp;quot;Invalid session state: %s&amp;quot;, retrievedState))
        return
    }

	tok, err := conf.Exchange(oauth2.NoContext, c.Query(&amp;quot;code&amp;quot;))
	if err != nil {
		c.AbortWithError(http.StatusBadRequest, err)
        return
	}

	client := conf.Client(oauth2.NoContext, tok)
	email, err := client.Get(&amp;quot;https://www.googleapis.com/oauth2/v3/userinfo&amp;quot;)
    if err != nil {
		c.AbortWithError(http.StatusBadRequest, err)
        return
	}
    defer email.Body.Close()
    data, _ := ioutil.ReadAll(email.Body)
    log.Println(&amp;quot;Email body: &amp;quot;, string(data))
    c.Status(http.StatusOK)
}

func loginHandler(c *gin.Context) {
    state = randToken()
    session := sessions.Default(c)
    session.Set(&amp;quot;state&amp;quot;, state)
    session.Save()
    c.Writer.Write([]byte(&amp;quot;&amp;lt;html&amp;gt;&amp;lt;title&amp;gt;Golang Google&amp;lt;/title&amp;gt; &amp;lt;body&amp;gt; &amp;lt;a href=&#39;&amp;quot; + getLoginURL(state) + &amp;quot;&#39;&amp;gt;&amp;lt;button&amp;gt;Login with Google!&amp;lt;/button&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;))
}

func main() {
    router := gin.Default()
    router.Use(sessions.Sessions(&amp;quot;goquestsession&amp;quot;, store))
    router.Static(&amp;quot;/css&amp;quot;, &amp;quot;./static/css&amp;quot;)
    router.Static(&amp;quot;/img&amp;quot;, &amp;quot;./static/img&amp;quot;)
    router.LoadHTMLGlob(&amp;quot;templates/*&amp;quot;)

    router.GET(&amp;quot;/&amp;quot;, indexHandler)
    router.GET(&amp;quot;/login&amp;quot;, loginHandler)
    router.GET(&amp;quot;/auth&amp;quot;, authHandler)

    router.Run(&amp;quot;127.0.0.1:9090&amp;quot;)
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is it folks. I hope this helped. Any comments or advices are welcomed.&lt;/p&gt;

&lt;h1 id=&#34;google-api-documentation&#34;&gt;Google API Documentation&lt;/h1&gt;

&lt;p&gt;The documentation to this whole process, and MUCH more information can be found here: &lt;a href=&#34;https://developers.google.com/identity/protocols/OAuth2&#34;&gt;Google API Docs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thanks for reading,
Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Minecraft world automatic backup to AWS S3 bucket - Part 2 (Custom functions)</title>
      <link>https://skarlso.github.io/2016/04/17/minecraft-server-aws-s3-backup-part2</link>
      <pubDate>Sun, 17 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/04/17/minecraft-server-aws-s3-backup-part2</guid>
      <description>&lt;p&gt;Hi folks.&lt;/p&gt;

&lt;p&gt;Got an update for the backup script. This time, you&amp;rsquo;ll have the ability to implement your own upload capabilities. I provide a mock implementation for the required functions.&lt;/p&gt;

&lt;p&gt;Here is the script again, now modified and a bit cleaned up. I hope it&amp;rsquo;s helpful.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

if [[ -t 1 ]]; then
    colors=$(tput colors)
    if [[ $colors ]]; then
        RED=&#39;\033[0;31m&#39;
        LIGHT_GREEN=&#39;\033[1;32m&#39;
        NC=&#39;\033[0m&#39;
    fi
fi

if [[ -z ${MINECRAFT_BUCKET} ]]; then
    printf &amp;quot;Please set the env variable %bMINECRAFT_BUCKET%b to the s3 archive bucket name.\n&amp;quot; &amp;quot;${RED}&amp;quot; &amp;quot;${NC}&amp;quot;
    exit 1
fi

if [[ -z ${MINECRAFT_ARCHIVE_LIMIT} ]]; then
    printf &amp;quot;Please set the env variable %bMINECRAFT_ARCHIVE_LIMIT%b to limit the number of archives to keep.\n&amp;quot; &amp;quot;${RED}&amp;quot; &amp;quot;${NC}&amp;quot;
    exit 1
fi

if [[ -z ${MINECRAFT_WORLD} ]]; then
    printf &amp;quot;Please set the env variable %bMINECRAFT_WORLD%b to specify what world to back-up.\n&amp;quot; &amp;quot;${RED}&amp;quot; &amp;quot;${NC}&amp;quot;
    exit 1
fi

backup_world=${MINECRAFT_WORLD}
backup_bucket=${MINECRAFT_BUCKET}
backup_limit=${MINECRAFT_ARCHIVE_LIMIT}
archive_name=&amp;quot;${backup_world}-$(date +&amp;quot;%H-%M-%S-%m-%d-%Y&amp;quot;).zip&amp;quot;

function create_archive {
    printf &amp;quot;Creating archive of %b${backup_world}%b\n&amp;quot; &amp;quot;${RED}&amp;quot; &amp;quot;${NC}&amp;quot;
    zip -r $archive_name $backup_world
}

function amazon_bak {

    create_archive

    printf &amp;quot;Checking if bucket has more than %b${backup_limit}%b files already.\n&amp;quot; &amp;quot;${RED}&amp;quot; &amp;quot;${NC}&amp;quot;
    content=( $(aws s3 ls s3://$backup_bucket | awk &#39;{print $4}&#39;) )

    if [[ ${#content[@]} -eq $backup_limit || ${#content[@]} -gt $backup_limit  ]]; then
        echo &amp;quot;There are too many archives. Deleting oldest one.&amp;quot;
        # We can assume here that the list is in cronological order
    	printf &amp;quot;%bs3://${backup_bucket}/${content[0]}\n%b&amp;quot; &amp;quot;${RED}&amp;quot; &amp;quot;${NC}&amp;quot;
        aws s3 rm s3://$backup_bucket/${content[0]}
    fi

    printf &amp;quot;Uploading %b${archive_name}%b to s3 archive bucket.\n&amp;quot; &amp;quot;${RED}&amp;quot; &amp;quot;${NC}&amp;quot;
    state=$(aws s3 cp $archive_name s3://$backup_bucket)

    if [[ &amp;quot;$state&amp;quot; =~ &amp;quot;upload:&amp;quot; ]]; then
        printf &amp;quot;File upload %bsuccessful%b.\n&amp;quot; &amp;quot;${LIGHT_GREEN}&amp;quot; &amp;quot;${NC}&amp;quot;
    else
        printf &amp;quot;%bError%b occured while uploading archive. Please investigate.\n&amp;quot; &amp;quot;${RED}&amp;quot; &amp;quot;${NC}&amp;quot;
    fi
}

function custom {
    if [[ -e custom.sh ]]; then
        source ./custom.sh
    else
        echo &amp;quot;custom.sh script not found. Please implement the apropriate functions.&amp;quot;
        exit 1
    fi

    echo &amp;quot;Checking for the number of files. Limit is: $backup_limit.&amp;quot;
    files=( $(list) )
    if [[ ${#files[@]} -eq $backup_limit || ${#files[@]} -gt $backup_limit ]]; then
        echo &amp;quot;Deleting extra file.&amp;quot;
        delete ${files[0]}
        if [[ $? != 0 ]]; then
            printf &amp;quot;%bFailed%b to delete file. Please investigate failure.&amp;quot; &amp;quot;${RED}&amp;quot; &amp;quot;${NC}&amp;quot;
            exit $?
        fi
    fi

    echo &amp;quot;Zipping world.&amp;quot;
    create_archive

    echo &amp;quot;Uploading world.&amp;quot;
    upload $archive_name

    if [[ $? != 0 ]]; then
        printf &amp;quot;%bFailed%b to upload archive. Please investigate the error.&amp;quot; &amp;quot;${RED}&amp;quot; &amp;quot;${NC}&amp;quot;
        exit $?
    fi

    printf &amp;quot;Upload %bsuccessful%b&amp;quot; &amp;quot;${LIGHT_GREEN}&amp;quot; &amp;quot;${NC}&amp;quot;
}

function help {
    echo &amp;quot;Usage:&amp;quot;
    echo &amp;quot;./backup_world [METHOD]&amp;quot;
    echo &amp;quot;Exp.: ./backup_world aws|./backup_world custom|./backup_world dropbox&amp;quot;
    echo &amp;quot;Each method has it&#39;s own environment properties that it requires.&amp;quot;
    echo &amp;quot;Global: MINECRAFT_WORLD|MINECRAFT_BUCKET|MINECRAFT_ARCHIVE_LIMIT&amp;quot;
    echo &amp;quot;Custom: Have a file, called &#39;custom.sh&#39; which is sourced.&amp;quot;
    echo &amp;quot;Implement these three functions: upload | list | delete.&amp;quot;
    echo &amp;quot;upload -&amp;gt; should return exit code 0 on success, should return exit code 1 on failure.&amp;quot;
    echo &amp;quot;list -&amp;gt; should return a list of cronologically ordered items.&amp;quot;
    echo &amp;quot;delete -&amp;gt; should return exit code 0 on success, should return exit code 1 on failure.&amp;quot;
}

case $1 in
    aws )
        amazon_bak
        ;;
    custom )
        custom
        ;;
    * )
        help
        ;;
esac
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here is the sample implementation for the custom upload functionality.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

function upload {
    echo &amp;quot;uploading&amp;quot;
    local result=0
    return $result
}

function delete {
    echo &amp;quot;deleting $1&amp;quot;
    local result=0
    return $result
}

function list {
    local arr=(&amp;quot;file1&amp;quot; &amp;quot;file2&amp;quot; &amp;quot;file3&amp;quot;)
    echo &amp;quot;${arr[@]}&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thanks for reading!&lt;/p&gt;

&lt;p&gt;Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Minecraft world automatic backup to AWS S3 bucket</title>
      <link>https://skarlso.github.io/2016/04/16/minecraft-server-aws-s3-backup</link>
      <pubDate>Sat, 16 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/04/16/minecraft-server-aws-s3-backup</guid>
      <description>&lt;p&gt;Hi Folks.&lt;/p&gt;

&lt;p&gt;Previously we created a Minecraft server using Docker. After my server got popular in the family, and a lot of stuff started to pile up on it, as a good IT person, I&amp;rsquo;m backing up the world once in a while.&lt;/p&gt;

&lt;p&gt;For that, I&amp;rsquo;m using AWS S3 with the CLI and a little bash script which runs once a week.&lt;/p&gt;

&lt;p&gt;The script is really straightforward. I&amp;rsquo;m doing manual versioning, although S3 does provide one out of the box. However, amazon&amp;rsquo;s S3 versioning doesn&amp;rsquo;t allow limiting the number of versions being kept. And since I&amp;rsquo;m doing that anyways, might as well take care of the rest.&lt;/p&gt;

&lt;p&gt;Without further ado, here is the script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

if [[ -t 1 ]]; then
    colors=$(tput colors)
    if [[ $colors ]]; then
        RED=&#39;\033[0;31m&#39;
        LIGHT_GREEN=&#39;\033[1;32m&#39;
        NC=&#39;\033[0m&#39;
    fi
fi

if [[ -z ${MINECRAFT_BUCKET} ]]; then
	printf &amp;quot;Please set the env variable ${RED}MINECRAFT_BUCKET${NC} to the s3 archive bucket name.\n&amp;quot;
	exit 0
fi

if [[ -z ${MINECRAFT_ARCHIVE_LIMIT} ]]; then
	printf &amp;quot;Please set the env variable ${RED}MINECRAFT_ARCHIVE_LIMIT${NC} to limit the number of archives to keep.\n&amp;quot;
	exit 0
fi

backup_bucket=${MINECRAFT_BUCKET}
backup_limit=${MINECRAFT_ARCHIVE_LIMIT}
world=$1
printf &amp;quot;Creating archive of ${RED}${world}${NC}\n&amp;quot;
archive_name=&amp;quot;${world}-$(date +&amp;quot;%H-%M-%S-%m-%d-%Y&amp;quot;).zip&amp;quot;
zip -r $archive_name $world

printf &amp;quot;Checking if bucket has more than ${RED}${backup_limit}${NC} files already.\n&amp;quot;
content=( $(aws s3 ls s3://$backup_bucket | awk &#39;{print $4}&#39;) )

if [[ ${#content[@]} -eq $backup_limit || ${#content[@]} -gt $backup_limit  ]]; then
    echo &amp;quot;There are too many archives. Deleting oldest one.&amp;quot;
    # We can assume here that the list is in cronological order
	printf &amp;quot;${RED}s3://${backup_bucket}/${content[0]}\n&amp;quot;
    aws s3 rm s3://$backup_bucket/${content[0]}
fi

printf &amp;quot;Uploading ${RED}${archive_name}${NC} to s3 archive bucket.\n&amp;quot;
state=$(aws s3 cp $archive_name s3://$backup_bucket)

if [[ &amp;quot;$state&amp;quot; =~ &amp;quot;upload:&amp;quot; ]]; then
    printf &amp;quot;File upload ${LIGHT_GREEN}successful${NC}.\n&amp;quot;
else
    printf &amp;quot;${RED}Error${NC} occured while uploading archive. Please investigate.\n&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It uses environment properties to define where to upload the given world and how many versions to keep.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m calling this from a cron job, and it&amp;rsquo;s sitting next to where the Minecraft world is.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it folks.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll start expanding on this idea and implement various services, like your own server address, or dropbox, or what have you.&lt;/p&gt;

&lt;p&gt;Happy backing up.&lt;/p&gt;

&lt;p&gt;Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Minecraft Server with Docker on OSX &#43; Mods</title>
      <link>https://skarlso.github.io/2016/03/29/minecraft-server-with-docker-and-osx</link>
      <pubDate>Tue, 29 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/03/29/minecraft-server-with-docker-and-osx</guid>
      <description>

&lt;p&gt;Hi Folks.&lt;/p&gt;

&lt;h1 id=&#34;intro&#34;&gt;Intro&lt;/h1&gt;

&lt;p&gt;Today, I wanted to write about how to create a secure server in a container. Ideally, you don&amp;rsquo;t want to run your server on your own machine. Running it in a container gives you a much needed control and an extra layer of security.&lt;/p&gt;

&lt;h1 id=&#34;docker-on-osx&#34;&gt;Docker On OSX&lt;/h1&gt;

&lt;p&gt;While on a mac, you have a couple of options to run docker.&lt;/p&gt;

&lt;h2 id=&#34;docker-machine&#34;&gt;Docker-Machine&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/machine/&#34;&gt;Docker-Machine&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Docker machine is very simple. It just creates a Linux vm in the background on the given driver, for us it will be &lt;a href=&#34;https://www.virtualbox.org/&#34;&gt;VirtualBox&lt;/a&gt;. Network, Memory and port-forwarding can all be managed through the VM directly. Then running and starting it is trivial through &lt;code&gt;docker-machine start&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;boot2docker&#34;&gt;Boot2Docker&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://boot2docker.io/&#34;&gt;Boot2Docker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Runs a tiny linux in which you can use Docker freely. This adds the benefit of not having to mess around with VirtualBox.&lt;/p&gt;

&lt;h2 id=&#34;dlite&#34;&gt;DLite&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/nlf/dlite&#34;&gt;DLite&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;DLite is the newest addition in the Game. Since docker uses /var/run/docker.sock file to communicate with the daemon, and this file is not there on OSX, DLite takes care of that. After DLite is running, you just simply use Docker. That&amp;rsquo;s it. No VM, no fuss, just use Docker.&lt;/p&gt;

&lt;p&gt;I recommend to use DLite, however, it&amp;rsquo;s not an official tool, so for the sake of this guide, I&amp;rsquo;ll be writing up a docker-machine oriented solution.&lt;/p&gt;

&lt;h1 id=&#34;docker-container-a-vanilla-server&#34;&gt;Docker container - A Vanilla Server&lt;/h1&gt;

&lt;p&gt;First, you&amp;rsquo;ll need a Dockerfile. &lt;a href=&#34;https://github.com/Skarlso/devops/blob/master/minecraft/Dockerfile&#34;&gt;Dockerfile&lt;/a&gt;. The steps on how to setup this file are written down in the README file, located here: &lt;a href=&#34;https://github.com/Skarlso/devops/tree/master/minecraft&#34;&gt;Container Setup&lt;/a&gt;. The &lt;code&gt;pwd&lt;/code&gt; command will use your current directory as a shared volume to copy stuff into the container from your host operating system.&lt;/p&gt;

&lt;p&gt;This will download the Minecraft server version 1.9 (or whichever you define) and install java and vim. It uses /data as a shared folder. Data will also be the working directory which means we will run the server from there. This server will be a vanilla server, meaning, no modding. If you have a single player world which you would like to use, simply copy that to /data and rename it to &lt;em&gt;world&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The tricky part is to make this available on the internet. Because the container is in a VM we need to do a chain forwarding. Forward from the container to the vm, and from the vm to your host machine. If you are using a dns service like dyna or no-ip, you probably have a software which refreshes an IP for you to link to. And you&amp;rsquo;ll also have port forwarding setup on your router. I won&amp;rsquo;t be going into detail on that part. That&amp;rsquo;s a whole different post.&lt;/p&gt;

&lt;p&gt;Forwarding from virtualbox can be done through the UI or through command line. The UI is like this: &lt;em&gt;Settings =&amp;gt; Network =&amp;gt; Adapter 1 =&amp;gt; Advanced =&amp;gt; PortForwarding&lt;/em&gt;. Here, setup something like this:
Name: Minecraft; Protocol: TCP; Host IP: 192.168.0.X(x=your local machine); Host Port: 25565; Guest IP: Leave Blank; Guest Port: 25565.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://skarlso.github.io/img/network.png&#34; alt=&#34;Network&#34; /&gt;
Where the number is missing, you&amp;rsquo;ll have to define your own local IP which you are using for your domain address.&lt;/p&gt;

&lt;p&gt;This should forward any ports coming from your VM to your local IP. In the container we have an expose and as the README states it&amp;rsquo;s started using -p 25565:25565 which will make sure that from the container, 25565 is exposed to the VM. And from the VM 25565 is exposed to your local. Chain forwarding.&lt;/p&gt;

&lt;p&gt;After that, once you start your server, it should all click together and you should have a running vanilla Minecraft server available under &lt;a href=&#34;http://yourdomain:25565&#34;&gt;http://yourdomain:25565&lt;/a&gt;. You won&amp;rsquo;t be able to check this by default on your own network. Check if the port is open with a different service like: &lt;a href=&#34;http://www.yougetsignal.com/tools/open-ports/&#34;&gt;Check If Port is Open&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;docker-container-modding&#34;&gt;Docker container - Modding&lt;/h1&gt;

&lt;p&gt;If you are not looking for anything, just a simple server, the above will be enough. You can still do /tp 1 1 1 to teleport, or can still use bans and op commands, and distribute items. However, if you would like to use mods, and as far as kids are concerned, they will want it, you&amp;rsquo;ll have to be a bit more clever.&lt;/p&gt;

&lt;p&gt;I dug far and deep and found that you have two options. Either go with a Forge server, or a Bukkit server. What does that mean? The vanilla server of Minecraft does not support modding. Modding, is modifying the implementation of Minecraft. It injects code and runs a pre-server in front of the original Minecraft server in order to append functionality. But fret not, this is all taken care of for you by either solutions.&lt;/p&gt;

&lt;p&gt;In order to jump into our container with the CMD omitted, we&amp;rsquo;ll have to run the following command instead of the one in the README.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -it -v `pwd`:/data -p 25565:25565 --name mc_server minecraft:v1.9 bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will give you an interactive prompt in which now we can operate.&lt;/p&gt;

&lt;h2 id=&#34;forge&#34;&gt;Forge&lt;/h2&gt;

&lt;p&gt;Download the latest forge version from here =&amp;gt; &lt;a href=&#34;http://files.minecraftforge.net/&#34;&gt;Minecraft Forge&lt;/a&gt;. They are usually up-to-date. I&amp;rsquo;m using 1.9 so I downloaded the appropriate installer version. After I obtained it, it was a matter of running this piece of command line code from my container:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;java -jar forge-1.9-12.16.0.1813-1.9-installer.jar --extract --installServer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will unpack a bunch of things you don&amp;rsquo;t have to worry about in your current directory, which is /data. Now run the universal.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;java -jar forge-1.9-12.16.0.1813-1.9-universal.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Everything under the &lt;strong&gt;mods&lt;/strong&gt; folder will be loaded as a mod. Forge is very restrictive and can only use Forge based mods. It will usually warn you if you have a none forge mod in your mods folder. You can find these on Forge&amp;rsquo;s forum here: &lt;a href=&#34;http://www.minecraftforge.net/forum/index.php/board,30.0.html&#34;&gt;Forge Forum&lt;/a&gt;. Simply download a jar and put it into /data/mods.&lt;/p&gt;

&lt;h2 id=&#34;bukkit&#34;&gt;Bukkit&lt;/h2&gt;

&lt;p&gt;I found Bukkit to be the winner for me. Most of the mods the kid wanted worked with Bukkit and did not work with Forge. Others will swear on Forge, but it&amp;rsquo;s really up to you. Using Bukkit is similarly easy. Again, you&amp;rsquo;ll have to find and get the wrapper for your Minecraft version, which can be located here: &lt;a href=&#34;http://getspigot.org/&#34;&gt;GetSpigot&lt;/a&gt;. You can use Spigot as well, though I have no experience with that.&lt;/p&gt;

&lt;p&gt;Once, you got the wrapper, which is called &lt;code&gt;craftbukkit-1.9.jar&lt;/code&gt; for me, you run it the same way you would run Forge or Minecraft.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;java -jar craftbukkit-1.9.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will load mods from the &lt;strong&gt;plugins&lt;/strong&gt; folder. Plugins can be found here: &lt;a href=&#34;http://mods.curse.com/bukkit-plugins/minecraft/new&#34;&gt;Latest Bukkit Plugins&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the container, you can use wget or curl to get the mods, or simply use the shared volume which is setup for you.&lt;/p&gt;

&lt;h1 id=&#34;last-words&#34;&gt;Last Words&lt;/h1&gt;

&lt;p&gt;All in all this sounds complicated, but it&amp;rsquo;s actually not, once you&amp;rsquo;ll get the hang out of it. You never kill the container once it&amp;rsquo;s setup, you just do &lt;code&gt;docker stop mc_server&lt;/code&gt; and then &lt;code&gt;docker-machine stop&lt;/code&gt; if you want to stop the VM as well. To start it up simply do these steps:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker_machine start
eval $(docker-machine env)
docker start mc_server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We named the container mc_server on a previous step. If you named it something different, use that name.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it. Hope this was clear. Any feedback is appreciated. If you think you have an easier way, or if I wrote something incorrectly, feel free to tell me in the comment sections below.&lt;/p&gt;

&lt;p&gt;Thanks for reading.&lt;/p&gt;

&lt;p&gt;Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Wercker Fixed</title>
      <link>https://skarlso.github.io/2016/03/09/wercker-fixed</link>
      <pubDate>Wed, 09 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/03/09/wercker-fixed</guid>
      <description>&lt;p&gt;Hi Folks.&lt;/p&gt;

&lt;p&gt;So Wercker was not working. After a minor modification it seems to be okay now. The config file needed for it to work looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;box: golang 
build:
    steps:
        - arjen/hugo-build:
            theme: redlounge
deploy:
    steps:
        - install-packages:
            packages: git 
        - leipert/git-push:
            gh_oauth: $GIT_TOKEN
            repo: skarlso/skarlso.github.io
            branch: master
            basedir: public    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The modification is the box type to &lt;em&gt;golang&lt;/em&gt; and removed &lt;em&gt;ssh-client&lt;/em&gt; from &lt;em&gt;packages&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Thanks,
Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Wercker Test</title>
      <link>https://skarlso.github.io/2016/03/04/wercker-test-2</link>
      <pubDate>Fri, 04 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/03/04/wercker-test-2</guid>
      <description>

&lt;h2 id=&#34;basics&#34;&gt;Basics&lt;/h2&gt;

&lt;p&gt;This is a wercker Test.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo Autodeploy with Wercker and Github - Pages</title>
      <link>https://skarlso.github.io/2016/02/10/hugo-autodeploy-with-wercker</link>
      <pubDate>Wed, 10 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/02/10/hugo-autodeploy-with-wercker</guid>
      <description>&lt;p&gt;There already is a nice tutorial on how to create github-pages with Hugo &lt;a href=&#34;https://gohugo.io/tutorials/github-pages-blog/&#34;&gt;Here&lt;/a&gt; if you prefer deplying your pages to a different branch on the same repo. There is also a post about Wercker and Hugo &lt;a href=&#34;https://gohugo.io/tutorials/automated-deployments/&#34;&gt;Here&lt;/a&gt; deploying pages to said separate branch.&lt;/p&gt;

&lt;p&gt;However, I took an easier approach on the matter with a completely separate branch for my blog source and my compiled github pages.&lt;/p&gt;

&lt;p&gt;This blog sits here: &lt;a href=&#34;https://github.com/Skarlso/skarlso.github.io&#34;&gt;https://github.com/Skarlso/skarlso.github.io&lt;/a&gt;. In order to deploy to it, I just have to commit a new blog post to this repository: &lt;a href=&#34;https://github.com/Skarlso/blogsource&#34;&gt;Blog Source&lt;/a&gt;. After that, &lt;a href=&#34;http://wercker.com/&#34;&gt;Wercker&lt;/a&gt; takes care of the rest. It builds my blog, and pushes the generated pages to my blog&amp;rsquo;s repository to the master branch without creating the gh-pages branch.&lt;/p&gt;

&lt;p&gt;The Wercker yml for that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;box: debian
build:
    steps:
        - arjen/hugo-build:
            theme: redlounge
deploy:
    steps:
        - install-packages:
            packages: git ssh-client
        - leipert/git-push:
            gh_oauth: $GIT_TOKEN
            repo: skarlso/skarlso.github.io
            branch: master
            basedir: public
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pretty easy. The $GIT_TOKEN is a variable set-up on Wercker containing a restricted token which is only good for pushing. And note that you have to use an explicit package name with git-push or else Wercker will not find that step. Hugo-build will build my blog with a simple command using redlounge theme.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s it. No other setup is necessary and no new branch will be made. Any questions, please feel free to leave a comment.&lt;/p&gt;

&lt;p&gt;Thanks for reading!&lt;/p&gt;

&lt;p&gt;Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Wercker Test</title>
      <link>https://skarlso.github.io/2016/02/10/wercker-test</link>
      <pubDate>Wed, 10 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/02/10/wercker-test</guid>
      <description>

&lt;h2 id=&#34;basics&#34;&gt;Basics&lt;/h2&gt;

&lt;p&gt;This is a wercker Test.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Doing CORS in Go with Gin and JSON</title>
      <link>https://skarlso.github.io/2016/02/02/doing-cors-in-go-with-gin-and-json</link>
      <pubDate>Tue, 02 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2016/02/02/doing-cors-in-go-with-gin-and-json</guid>
      <description>

&lt;h2 id=&#34;basics&#34;&gt;Basics&lt;/h2&gt;

&lt;p&gt;Hello folks.&lt;/p&gt;

&lt;p&gt;This will be a quick post about how to do CORS with jQuery, Gin in Go with a very simple ajax GET and Json.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m choosing JSON here because basically I don&amp;rsquo;t really like JSONP. And actually, it&amp;rsquo;s not very complicated to do CORS, it&amp;rsquo;s just hidden enough so that it doesn&amp;rsquo;t become transparent.&lt;/p&gt;

&lt;p&gt;First, what is CORS? It&amp;rsquo;s Cross-Platform Resource Sharing. It has been invented so that without your explicit authorization in the header of a request, Javascript can&amp;rsquo;t reach outside of your domain and be potentially harmful to your visitors.&lt;/p&gt;

&lt;p&gt;Now, suppose you have an architecture like this.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://skarlso.github.io/img/architecture.png&#34; alt=&#34;Architecture&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You have multiple agents sitting on multiple nodes. You have one central server, and you have multiple front-ends. Everybody can only talk to the Server but the server does talk to everyone. You would like to have a dynamic front-end and would like to display data with ajax calls. Since your front-end sits on a different server, you will have to do something about CORS. This is how I solved it&amp;hellip;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m using &lt;a href=&#34;https://github.com/gin-gonic/gin&#34;&gt;Gin&lt;/a&gt; for my REST service for &lt;a href=&#34;https://github.com/Skarlso/dockmaster2&#34;&gt;Dockmaster&lt;/a&gt;. For this two work, you need to adjust two component.&lt;/p&gt;

&lt;h2 id=&#34;server&#34;&gt;Server&lt;/h2&gt;

&lt;p&gt;There is thing called a Preflight-Check. In essence, the preflight check is sent BEFORE the actual request to check if the next request is allowed to go out of the domain. The preflight check is sent to the same URI just with OPTIONS method. In order to tell the caller that the next one will be safe, you need three things.&lt;/p&gt;

&lt;p&gt;First, you need to set two Headers.
#1 -&amp;gt; Access-Control-Allow-Origin to &amp;ldquo;*&amp;ldquo;.
#2 -&amp;gt; Access-Control-Allow-Headers to &amp;ldquo;access-control-allow-origin, access-control-allow-headers&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;These are the minimum headers you can set. If you allow Access-Control-Allow-Origin you also have to allow it in the headers section because the next request will expect it to be there. Also, note here that setting Origin to * is only recommended in development environment. Otherwise it should be set to whatever your domain is.&lt;/p&gt;

&lt;p&gt;Second, you need to respond to the OPTIONS method with a 200. In order to do that, I added a simple rule with the same end-point but with OPTIONS.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    router := gin.Default()
    v1 := router.Group(APIBASE)
    {
        v1.GET(&amp;quot;/list&amp;quot;, listContainers)
        v1.POST(&amp;quot;/add&amp;quot;, addContainers)
        v1.POST(&amp;quot;/delete&amp;quot;, deleteContainers)
        v1.GET(&amp;quot;/inspect/:agentID/:containerID&amp;quot;, inspectContainer)
        v1.OPTIONS(&amp;quot;/inspect/:agentID/:containerID&amp;quot;, preflight)
        v1.POST(&amp;quot;/stopAll&amp;quot;, stopAll)
        v1.OPTIONS(&amp;quot;/stopAll&amp;quot;, preflight)
    }
    router.Run(&amp;quot;:8989&amp;quot;)
}

func preflight(c *gin.Context) {
    c.Header(&amp;quot;Access-Control-Allow-Origin&amp;quot;, &amp;quot;*&amp;quot;)
    c.Header(&amp;quot;Access-Control-Allow-Headers&amp;quot;, &amp;quot;access-control-allow-origin, access-control-allow-headers&amp;quot;)
    c.JSON(http.StatusOK, struct{}{})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that the preflight method is there for two end-points. I added it to those end-points which will reach over the domain. The others are all local, thus they don&amp;rsquo;t need that. This leads to a little duplication, but that is fine. I have a very fine control over what actually is allowed to go outside of the domain.&lt;/p&gt;

&lt;p&gt;So, how do we call this?&lt;/p&gt;

&lt;h2 id=&#34;frontend&#34;&gt;Frontend&lt;/h2&gt;

&lt;p&gt;In the front-end&amp;rsquo;s web layout, I&amp;rsquo;m doing an Ajax GET, which looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;                $.ajax({
                    url: &#39;http://localhost:8989/api/1/inspect/&#39;+data.agentid+&#39;/&#39;+data.id,
                    type: &#39;GET&#39;,
                    dataType:&amp;quot;json&amp;quot;,
                    headers: {&amp;quot;Access-Control-Allow-Origin&amp;quot;: &amp;quot;*&amp;quot;, &amp;quot;Access-Control-Allow-Headers&amp;quot;: &amp;quot;access-control-allow-origin, access-control-allow-headers&amp;quot;},
                    processData: false,
                    success: function(data) {
                        var json = JSON.stringify(data, null, 4)
                        independentPopup.html(&amp;quot;&amp;lt;pre &amp;gt;&amp;quot;+json+&amp;quot;&amp;lt;/pre&amp;gt;&amp;quot;);
                        $(link).after(independentPopup);
                    }
                });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the headers are set, the request will work nicely.&lt;/p&gt;

&lt;h2 id=&#34;y-u-no-middleware&#34;&gt;Y U No Middleware?&lt;/h2&gt;

&lt;p&gt;And now you could say that, why not just have a middleware which will always accept OPTIONS for every end-point. Because I like it better this way. Some would argue that this is too granular, but fact is, that in my opinion, this is more readable and immediatly visible. However, if you DO want to do that, you have several options to your disposal.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/itsjamie/gin-cors&#34;&gt;Cors Basic Http Middleware&lt;/a&gt; and for Gin &lt;a href=&#34;https://github.com/itsjamie/gin-cors&#34;&gt;Gin CORS Middleware&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;This is it. You can see the code in its entirety on Github. Have a better idea on how to do it? Please! Do not hesitate to share. I always like to learn.&lt;/p&gt;

&lt;p&gt;Thank you for reading!&lt;/p&gt;

&lt;p&gt;And as always,
Have a nice day!&lt;/p&gt;

&lt;p&gt;Gergely.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>