<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ramblings of a build engineer &middot; Ramblings of a build engineer</title>

    <meta name="description" content="">

    <meta name="generator" content="Hugo 0.36.1" />
    <meta name="twitter:card" content="summary">
    
    <meta name="twitter:title" content="Ramblings of a build engineer &middot; Ramblings of a build engineer">
    <meta name="twitter:description" content="">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Ramblings of a build engineer &middot; Ramblings of a build engineer">
    <meta property="og:description" content="">

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">

    <link rel="stylesheet" href="https://skarlso.github.io//css/all.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="Ramblings of a build engineer" href="https://skarlso.github.io//index.xml" />
</head>
<body>


<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <hgroup>
            <h1 class="brand-title"><a href="https://skarlso.github.io/">Ramblings of a build engineer</a></h1>
            <h2 class="brand-tagline"></h2>
        </hgroup>

        <nav class="nav">
            <ul class="nav-list">
                
                <li class="nav-item">
                    <a class="pure-button" href="https://twitter.com/Skarlso"><i class="fa fa-twitter"></i> Twitter</a>
                </li>
                
                
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/Skarlso "><i class="fa fa-github-alt"></i> github</a>
                </li>
                
                <li class="nav-item">
                    <a class="pure-button" href="https://skarlso.github.io//index.xml"><i class="fa fa-rss"></i> rss</a>
                </li>
                <li class="nav-item">
                    <style>.bmc-button img{width: 27px !important;margin-bottom: 3px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-block !important;color:#ffffff !important;background-color:#BB5794 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 23px !important;letter-spacing: 0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:'Cookie', cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#ffffff !important;}
                    </style>
                    <link href="https://fonts.googleapis.com/css?family=Cookie" rel="stylesheet">
                    <a class="bmc-button nav-item" target="_blank" href="https://www.buymeacoffee.com/skarlso">
                        <img src="https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg" alt="Buy me a coffee">
                        <span style="margin-left:5px">Buy me a coffee</span>
                    </a>
                </li>
            </ul>
        </nav>
    </div>
</div>


    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                
                <h1 class="content-subhead">06 Feb 2018, 23:01</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://skarlso.github.io/2018/02/06/go-budapest-meetup/" class="post-title">Go Budapest Meetup</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">hannibal</strong>
                            
                            
                                under 
                                
                                <a class="post-category post-category-Go" href="https://skarlso.github.io//categories/go">Go</a><a class="post-category post-category-Meetup" href="https://skarlso.github.io//categories/meetup">Meetup</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h1 id="intro">Intro</h1>

<p>So I was at <a href="https://www.meetup.com/go-budapest">Go Budapest Meetup</a> yesterday, where the brilliant <a href="https://jbrandhorst.com/">Johan Brandhorst</a>
gave a talk about his project based on <a href="https://grpc.io/">gRPC</a> using <a href="https://github.com/improbable-eng/grpc-web">gRPC-web</a> +
<a href="https://github.com/gopherjs/gopherjs">GopherJS</a> + <a href="https://github.com/google/protobuf">protobuf</a>. He also has some Go
contributions and check out his project here: <a href="https://github.com/johanbrandhorst/protobuf">Protobuf</a>. It&rsquo;s GopherJS Bindings for
ProtobufJS and gRPC-Web.</p>

<p>It was interesting to see where these projects could lead and I see the potential in them. I liked the usage of Protobuf and gRPC,
I don&rsquo;t have THAT much experience with them. However after yesterday, I&rsquo;m eager to find an excuse to do something with these libraries.
I used gRPC indirectly, well, the result of it, when dealing with Google Cloud Platform&rsquo;s API. Which is largely generated code through
gRPC and protobuf.</p>

<p>He also presented a bi-directional stream communication between the gRPC-web client and the server which was an interesting feat
to produce. It did involve the use of <a href="https://godoc.org/golang.org/x/sync/errgroup">errgroup</a>. Which is nice.</p>

<p>I didn&rsquo;t look THAT much into WebAssembly however, again, after yesterday, I will. He gave a shout out to WebAssembly developers
that he is ready to tackle the Go bindings for WASM!</p>

<p>It was a good change of pace to look at some Go code being written, I&rsquo;ll be sure to visit the meetup again, in about three months
when the next one will come.</p>

<p>Maybe, I&rsquo;ll even give a talk if they are looking for speakers. ;)</p>

<p>A huge thank you to <a href="https://www.emarsys.com/en/about-us/">Emarsys Budapest</a> for organizing the event and bringing Johan to us
for his talk.</p>

<p>Thanks,<br />
Gergely</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">23 Jan 2018, 22:34</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://skarlso.github.io/2018/01/23/nginx-certbot-ansible/" class="post-title">Ansible &#43; Nginx &#43; LetsEncrypt &#43; Wiki &#43; Nagios</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">hannibal</strong>
                            
                            
                                under 
                                
                                <a class="post-category post-category-Ansible" href="https://skarlso.github.io//categories/ansible">Ansible</a><a class="post-category post-category-Nginx" href="https://skarlso.github.io//categories/nginx">Nginx</a><a class="post-category post-category-Certbot" href="https://skarlso.github.io//categories/certbot">Certbot</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h1 id="intro">Intro</h1>

<p>Hi folks.</p>

<p>Today, I would like demonstrate how to use <a href="https://www.ansible.com/">Ansible</a> in order to construct a server hosting multiple HTTPS domains with <a href="https://www.nginx.com/">Nginx</a> and <a href="https://letsencrypt.org/">LetsEncrypt</a>. Are you ready? Let&rsquo;s dive in.</p>

<h2 id="what-you-will-need">What you will need</h2>

<p>There is really only one thing you need in order for this to work and that is Ansible. If you would like to run local tests without a remote server, than you will need <a href="https://www.vagrantup.com/">Vagrant</a> and <a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a>. But those two are optional.</p>

<h2 id="what-we-are-going-to-set-up">What We Are Going To Set Up</h2>

<p>The setup is as follows:</p>

<h3 id="nagios">Nagios</h3>

<p>We are going to have a Nagios with a custom check for pending security updates. That will run under nagios.example.com.</p>

<h3 id="hugo-website">Hugo Website</h3>

<p>The main web site is going to be a basic <a href="https://gohugo.io/">Hugo</a> site. Hugo is a static Go based web site generator. This Blog is run by it.</p>

<p>We are also going to setup <a href="https://www.noip.com/">NoIP</a> which will provide the DNS for the sites.</p>

<h3 id="wiki">Wiki</h3>

<p>The wiki is a plain, basic <a href="https://www.dokuwiki.org/dokuwiki#">DokuWiki</a>.</p>

<h3 id="https-nginx">HTTPS + Nginx</h3>

<p>And all the above will be hosted by Nginx with HTTPS provided by letsencrypt. We are going to set all these up with Ansible on top so it will be idempotent.</p>

<h3 id="repository">Repository</h3>

<p>All of the playbooks and the whole thing together can be viewed here: <a href="https://github.com/Skarlso/ansible-server-setup">Github Ansible Server Setup</a>.</p>

<h2 id="ansible">Ansible</h2>

<p>I won&rsquo;t be writing everything down to the basics about Ansible. For that you will need to go and read its documentation. But I will provide ample of clarification for using what I&rsquo;ll be using.</p>

<h3 id="some-basics">Some Basics</h3>

<p>Ansible is a configuration management tool which, unlike chef or puppet, isn&rsquo;t master - slave based. It&rsquo;s using SSH to run a set of instructions on a target machine. The instructions are written in yaml files and look something like this:</p>

<pre><code class="language-yaml">---
# tasks file for ssh
- name: Copy sshd_config
  copy: content=&quot;{{sshd_config}}&quot; dest=/etc/ssh/sshd_config
  notify:
  - SSHD Restart
</code></pre>

<p>This is a basic Task which copies over an <code>sshd_config</code> file overwriting the one already being there. It can execute in priviliged mode if root password is provided or the user has sudo rights.</p>

<p>It works from so called <code>hosts</code> files where the server details are described. This is how a basic host file would look like:</p>

<pre><code class="language-bash">[local]
127.0.0.1

[webserver1]
1.23.4.5
</code></pre>

<p>Ansible will use these settings to try and access the server. To test if the connection is working, you can send a <code>ping</code> task like this:</p>

<pre><code class="language-bash">ansible all -m ping
</code></pre>

<p>Ansible uses <code>variables</code> for things that change. They are defined under each task&rsquo;s subfolder called <code>vars</code>. Please feel free to change the varialbes there to your liking.</p>

<h3 id="ssh-access">SSH Access</h3>

<p>You can either define SSH information per host or per group or globally. In this example I have it under the groups wars called
<code>webserver1</code> like this (vars.yaml):</p>

<pre><code class="language-yaml">---
# SSH sudo keys and pass
ansible_become_pass: '{{vault_ansible_become_pass}}'
ansible_ssh_port: '{{vault_ansible_ssh_port}}'
ansible_ssh_user: '{{vault_ansible_ssh_user}}'
ansible_ssh_private_key_file: '{{vault_ansible_ssh_private_key_file}}'
home_dir: /root
</code></pre>

<h3 id="further-reading">Further reading</h3>

<p>Further readings are:</p>

<ul>
<li><a href="https://serversforhackers.com/c/an-ansible-tutorial">Servers For Hackers</a></li>
<li><a href="http://docs.ansible.com/ansible/latest/intro_getting_started.html">Ansible docs</a></li>
</ul>

<h3 id="vault">Vault</h3>

<p>The vault is the place where we can keep secure information. This file is called <code>vault</code> and usually lives under either <code>group_vars</code> or <code>host_vars</code>. The preference is up to you.</p>

<p>This file is encrypted using a password you specify. You can have the vault password stored in the following ways:</p>

<ul>
<li>Store it on a secure drive which is encrypted and only mounted when the playbook is executed</li>
<li>Store it on <a href="https://keybase.io">Keybase</a></li>
<li>Store it on an encrypted S3 bucket</li>
<li>Store it in a file next to the playbook which is never commited into source control</li>
</ul>

<p>Either way, in the end, ansible will look for a file called <code>.vault_password</code> for when it&rsquo;s trying to decrypt the file. You can
define a different file in the <code>ansible.cfg</code> file using the <code>vault_password_file</code> option.</p>

<p>You can create a vault like this:</p>

<pre><code class="language-bash">ansible-vault create vault
</code></pre>

<p>If you are following along, you are going to need these variables in the vault:</p>

<pre><code class="language-yaml">vault_ansible_become_pass: &lt;your_sudo_password&gt; # if applicable
vault_ansible_ssh_user: &lt;ssh_user&gt;
vault_ansible_ssh_private_key_file: /Users/user/.ssh/ida_rsa
vault_nagios_password: supersecurenagiosadminpassword
vault_nagios_username: nagiosadmin
vault_noip_username: youruser@gmail.com
vault_noip_password: &quot;SuperSecureNoIPPassword&quot;
vault_nginx_user: &lt;localuser&gt;
</code></pre>

<p>You can always edit the vault later on with:</p>

<pre><code class="language-bash">ansible-vault edit group_vars/webserver1/vault --vault-password-file=.vault_pass
</code></pre>

<h3 id="tasks">Tasks</h3>

<p>The following are a collection of tasks which execute in order. The end task, which is letsencrypt, relies on all the hosts being present and configured under Nginx. Otherwise it will throw an error that the host you are trying to configure HTTPS for, isn&rsquo;t defined.</p>

<h4 id="no-ip">No-IP</h4>

<p>I&rsquo;m choosing No-ip as a DNS provider because it&rsquo;s cheap and the sync tool is easy to automate. To automate the CLI of No-IP, I&rsquo;m using a package called <code>expect</code>. This looks something like this:</p>

<pre><code class="language-bash">cd {{home_dir}}
wget http://www.no-ip.com/client/linux/noip-duc-linux.tar.gz
mkdir -p noip
tar zxf noip-duc-linux.tar.gz -C noip
cd noip/*
make

/usr/bin/expect &lt;&lt;END_SCRIPT
spawn make install
expect &quot;Please enter the login/email*&quot; { send &quot;{{noip_username}}\r&quot; }
expect &quot;Please enter the password for user*&quot; { send &quot;{{noip_password}}\r&quot; }
expect {
    &quot;Do you wish to have them all updated*&quot; {
        send &quot;y&quot;
        exp_continue
    }
}
expect &quot;Please enter an update interval*&quot; { send &quot;30\r&quot; }
expect &quot;Do you wish to run something at successful update*&quot; {send &quot;N&quot; }
END_SCRIPT
</code></pre>

<p>The interesting part is the command running expect. Basically, it&rsquo;s expecting some kind of output which is outlined there. And has canned answers for those which it <code>send</code>s to the waiting command.</p>

<h4 id="to-util-or-not-to-util">To Util or Not To Util</h4>

<p>So, there are small tasks, like installing vim and wget and such which could warrant the existance of a <code>utils</code> task. Utils task would install the packages that are used as convinience and don&rsquo;t really relate to a singe task.</p>

<p>Yet I settled for the following. Each of my tasks has a dependency part. The given tasks takes care of all the packages it needs so they can be executed on their own as well as in unison.</p>

<p>This looks like this:</p>

<pre><code class="language-yaml"># Install dependencies
- name: Install dependencies
  apt: pkg=&quot;{{item}}&quot; state=installed
  with_items:
    - &quot;{{deps}}&quot;
</code></pre>

<p>For which the <code>deps</code> variable is defined as follows:</p>

<pre><code class="language-yaml"># Defined dependencies for letsencrypt task.
deps: ['git', 'python-dev', 'build-essential', 'libpython-dev', 'libpython2.7', 'augeas-lenses', 'libaugeas0', 'libffi-dev', 'libssl-dev', 'python-virtualenv', 'python3-virtualenv', 'virtualenv']
</code></pre>

<p>This is much cleaner. And if a task is no longer needed, it&rsquo;s dependencies will no longer be needed either in most of the cases.</p>

<h4 id="nagios-1">Nagios</h4>

<p>I&rsquo;m using Nagios 4 which is a real pain in the butt to install. Luckily, thanks to Ansiblei, I only ever had to figure it out once. Now I have a script for that. Installing Nagios demands several, smaller components to be installed. Thus our task uses import from outside tasks like this:</p>

<pre><code class="language-yaml">- name: Install Nagios
  block:
    - include: create_users.yml # creates the Nagios user
    - include: install_dependencies.yml # installs Nagios dependencies
    - include: core_install.yml # Installs Nagios Core
    - include: plugin_install.yml # Installs Nagios Plugins
    - include: create_htpasswd.yml # Creates a password for Nagios' admin user
    - include: setup_custom_check.yml # Adds a custom check which is to check how many security updates are pending
  when: st.stat.exists == False
</code></pre>

<p>The <code>when</code> is a check for a variable created by a file check.</p>

<pre><code class="language-yaml">- stat:
    path: /usr/local/nagios/bin/nagios
  register: st
</code></pre>

<p>It checks if Nagios is installed or not. If yes, skip.</p>

<p>I&rsquo;m not going to paste in here all the subtasks because that would be huge. You can check those out in the repository under Nagios.</p>

<h4 id="hugo">Hugo</h4>

<p>Hugo is easy to install. Its sole requirement is Go. To install hugo you simply run <code>apt-get install hugo</code>. Setting up the
site for me was just checking out the git repo and than execute hugo from the root folder like this:</p>

<pre><code class="language-bash">hugo server --bind=127.0.0.1 --port=8080 --baseUrl=https://example.com --appendPort=false --logFile hugo.log --verboseLog --verbose -v &amp;
</code></pre>

<h4 id="wiki-1">Wiki</h4>

<p>I used DokuWiki because it&rsquo;s a file based wiki so installation is basically just downloading the archive, extracting it and done. The only thing that&rsquo;s needed for it, is php-fpm to run it and a few php modules which I&rsquo;ll outline in the ansible playbook.</p>

<p>The VHOST file for DokuWiki is provided by them and looks like this:</p>

<pre><code class="language-bash">server {
    server_name   {{ wiki_server_name }};
    root {{ wiki_root }};
    index index.php index.html index.htm;
    client_max_body_size 2M;
    client_body_buffer_size 128k;
    location / {
        index doku.php;
        try_files $uri $uri/ @dokuwiki;
    }
    location @dokuwiki {
        rewrite ^/_media/(.*) /lib/exe/fetch.php?media=$1 last;
        rewrite ^/_detail/(.*) /lib/exe/detail.php?media=$1 last;
        rewrite ^/_export/([^/]+)/(.*) /doku.php?do=export_$1&amp;id=$2 last;
        rewrite ^/(.*) /doku.php?id=$1 last;
    }
    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_pass unix:/var/run/php5-fpm.sock;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }
    location ~ /\.ht {
        deny all;
    }
    location ~ /(data|conf|bin|inc)/ {
        deny all;
    }
}
</code></pre>

<h4 id="nginx">Nginx</h4>

<p>Nginx install is through apt as well. Here, however, there is a bit of magic going on with templates. The templates provide the
vhost files for the three hosts we will be running. This looks as follows:</p>

<pre><code class="language-yaml">- name: Install vhosts
  block:
    - template: src=01_example.com.j2 dest=/etc/nginx/vhosts/01_example.com
      notify:
      - Restart Nginx
    - template: src=02_wiki.example.com.j2 dest=/etc/nginx/vhosts/02_wiki_example.com
      notify:
      - Restart Nginx
    - template: src=03_nagios.example.com.j2 dest=/etc/nginx/vhosts/03_nagios.example.com
      notify:
      - Restart Nginx
</code></pre>

<p>Now, you might be wondering what <code>notify</code> is? It&rsquo;s basically a handler that gets notified to restart nginx. The great part about
it is that it does this only once, even if it was called multiple times. The handler looks like this:</p>

<pre><code class="language-yaml">- name: Restart Nginx
  service:
    name: nginx
    state: restarted
</code></pre>

<p>And lives under <code>handlers</code> sub-folder.</p>

<p>With this, Nginx is done and should be providing our sites under plain HTTP.</p>

<h4 id="letsencrypt">LetsEncrypt</h4>

<p>Now comes the part where we enable HTTPS for all these three domains. Which is as follows:</p>

<ul>
<li>example.com</li>
<li>wiki.example.com</li>
<li>nagios.example.com</li>
</ul>

<p>This is actually quiet simple now-a-days with <code>certbot-auto</code>. In fact, it will insert the configurations we need all by itself.
The only thing for us to do is to specify what domains we have and what our challenge would be. Also, we have to pass in some
variables for <code>certbot-auto</code> to run in a non-interactive mode. This looks as follows:</p>

<pre><code class="language-yaml">- name: Generate Certificate for Domains
  shell: ./certbot-auto --authenticator standalone --installer nginx -d '{{ domain_example }}' -d '{{ domain_wiki }}' -d '{{ domain_nagios }}' --email example@gmail.com --agree-tos -n --no-verify-ssl --pre-hook &quot;sudo systemctl stop nginx&quot; --post-hook &quot;sudo systemctl start nginx&quot; --redirect
  args:
    chdir: /opt/letsencrypt
</code></pre>

<p>And that&rsquo;s that. The interesting and required part here is the <code>pre-hook</code> and <code>post-hook</code>. Without those it wouldn&rsquo;t work because
the ports that certbot is performing the challenge on would be taken already. This stops nginx, performs the challenge and
generates the certs, and starts nginx again. Also note <code>--redirect</code>. This will force HTTPS on the sites and disables plain HTTP.</p>

<p>If all went well our sites should contain information like this:</p>

<pre><code class="language-bash">    listen 443 ssl; # managed by Certbot
    ssl_certificate /etc/letsencrypt/live/example.com-0001/fullchain.pem; # managed by Certbot
    ssl_certificate_key /etc/letsencrypt/live/example.com-0001/privkey.pem; # managed by Certbot
    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot
</code></pre>

<h3 id="test-run-using-vagrant">Test Run using Vagrant</h3>

<p>If you don&rsquo;t want to run all this on a live server to test out, you can do either of these two things:</p>

<ul>
<li>Use a remote dedicated test server</li>
<li>Use a local virtual machine with Vagrant</li>
</ul>

<p>Here, I&rsquo;m giving you an option for the later.</p>

<p>It&rsquo;s possible for most of the things to be tested on a local Vagrant machine. Most of the time a Vagrant box is enough to test out installing things. A sample Vagrant file looks like this:</p>

<pre><code class="language-ruby"># encoding: utf-8
# -*- mode: ruby -*-
# vi: set ft=ruby :
# Box / OS
VAGRANT_BOX = 'ubuntu/xenial64'

VM_NAME = 'ansible-practice'

Vagrant.configure(2) do |config|
  # Vagrant box from Hashicorp
  config.vm.box = VAGRANT_BOX
  # Actual machine name
  config.vm.hostname = VM_NAME
  # Set VM name in Virtualbox
  config.vm.provider 'virtualbox' do |v|
    v.name = VM_NAME
    v.memory = 2048
  end
  # Ansible provision
  config.vm.provision 'ansible_local' do |ansible|
    ansible.limit = 'all'
    ansible.inventory_path = 'hosts'
    ansible.playbook = 'local.yml'
  end
end
</code></pre>

<p>This interesting part here is the ansible provision section. It&rsquo;s running a version of Ansible that is called <code>ansible_local</code>. It&rsquo;s local, becuase it will be only on the VirtualBox. Meaning, you don&rsquo;t have to have Ansible installed to test it on a vagrant box. Neat, huh?</p>

<p>To test your playbook, simply run <code>vagrant up</code> and you should see the provisioning happening.</p>

<h2 id="room-for-improvement">Room for improvement</h2>

<p>And that should be all. Note that this setup isn&rsquo;t quiet enterprise ready. I would add the following things:</p>

<h3 id="tests-and-checks">Tests and Checks</h3>

<p>A ton of tests and checks if the commands that we are using are actually successful or not. If they aren&rsquo;t make them report the failure.</p>

<h3 id="multiple-domains">Multiple Domains</h3>

<p>If you happen to have a ton of domain names to set up, this will not be the most effective way. Right now letsencrypt creates a
single certificate file for those three domains with <code>-d</code> and that&rsquo;s not what you want with potentially hundreds of domains.</p>

<p>In that case, have a list to go through with <code>with_items</code>. Note that you&rsquo;ll have to restart nginx on each line, because you don&rsquo;t
want one of them fail and stop the process entirely. Rather have a few fail but the rest still work.</p>

<h1 id="conclusion">Conclusion</h1>

<p>That&rsquo;s it folks. Have fun setting up servers all over the place and enjoy the power of nginx and letsencrypt and not having to
worry about adding another server into the bunch.</p>

<p>Thank you for reading,<br />
Gergely.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">13 Jan 2018, 22:34</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://skarlso.github.io/2018/01/13/furnace-massive-update/" class="post-title">Huge Furnace Update</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">hannibal</strong>
                            
                            
                                under 
                                
                                <a class="post-category post-category-AWS" href="https://skarlso.github.io//categories/aws">AWS</a><a class="post-category post-category-Go" href="https://skarlso.github.io//categories/go">Go</a><a class="post-category post-category-Furnace" href="https://skarlso.github.io//categories/furnace">Furnace</a><a class="post-category post-category-GCP" href="https://skarlso.github.io//categories/gcp">GCP</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h1 id="intro">Intro</h1>

<p>Hi folks.</p>

<p>In the past couple of months I&rsquo;ve been slowly updating <a href="https://github.com/Skarlso/go-furnace">Furnace</a>.</p>

<p>There are three major changes that happened. Let&rsquo;s take a look at them, shall we?</p>

<h2 id="google-cloud-platform">Google Cloud Platform</h2>

<p>Furnace now supports <a href="https://cloud.google.com">Google Cloud Platform (GCP)</a>. It provides the same API to handle GCP resource as with AWS. Namely, <code>create</code>, <code>delete</code>, <code>status</code>, <code>update</code>. I opted to leave out <code>push</code> because Google mostly works with git based repositories, meaning a push is literary just a push, than Google handles distributing the new code by itself.</p>

<p>All the rest of the commands should work the same way as AWS.</p>

<h3 id="deployment-manager">Deployment Manager</h3>

<p>GCP has a similar service to AWS CloudFormations called <a href="https://cloud.google.com/deployment-manager/docs/">Deployment Manager</a>. The documentation is fairly detailed with a Bookshelf example app to deploy. Code and Templates can be found in their Git repositroy here: <a href="https://github.com/GoogleCloudPlatform/deploymentmanager-samples">Deployment Manager Git Repository</a>.</p>

<h3 id="setting-up-gcp">Setting up GCP</h3>

<p>As the README of Furnace outlines&hellip;</p>

<blockquote>
<p>Please carefully read and follow the instruction outlined in this document: <a href="https://cloud.google.com/sdk/#Quick_Start">Google Cloud Getting Started</a>. It will describe how to download and install the SDK and initialize cloud to a Project ID.</p>

<p>Take special attention to these documents:</p>

<p><a href="https://cloud.google.com/sdk/docs/initializing">Initializing GCloud Tools</a>
<a href="https://cloud.google.com/sdk/docs/authorizing">Authorizing Tools</a></p>

<p>Furnace uses a Google Key-File to authenticate with your Google Cloud Account and Project.
In the future, Furnace assumes these things are properly set up and in working order.</p>
</blockquote>

<p>To initialize the client, it uses the following code:</p>

<pre><code class="language-go">  ctx := context.Background()
  client, err := google.DefaultClient(ctx, dm.NdevCloudmanScope)
</code></pre>

<p>The DefaultClient in turn, does the following:</p>

<pre><code class="language-go">// FindDefaultCredentials searches for &quot;Application Default Credentials&quot;.
//
// It looks for credentials in the following places,
// preferring the first location found:
//
//   1. A JSON file whose path is specified by the
//      GOOGLE_APPLICATION_CREDENTIALS environment variable.
//   2. A JSON file in a location known to the gcloud command-line tool.
//      On Windows, this is %APPDATA%/gcloud/application_default_credentials.json.
//      On other systems, $HOME/.config/gcloud/application_default_credentials.json.
//   3. On Google App Engine it uses the appengine.AccessToken function.
//   4. On Google Compute Engine and Google App Engine Managed VMs, it fetches
//      credentials from the metadata server.
//      (In this final case any provided scopes are ignored.)
func FindDefaultCredentials(ctx context.Context, scope ...string) (*DefaultCredentials, error) {
</code></pre>

<p>Take note on the order. This is how Google will authenticate your requests.</p>

<h3 id="running-gcp">Running GCP</h3>

<p>Running gcp is largely similar to AWS. First, you create the necessary templates to your infrastructure. This is done via the Deployment Manager and it&rsquo;s templating engine. The GCP templates are Python <a href="http://jinja.pocoo.org/">JINJA</a> files. Examples are provided in the <code>template</code> directory. It&rsquo;s a bit more complicated than the CloudFormation templates in that it uses outside templates plus schema files to configure dynamic details.</p>

<p>It&rsquo;s all explained in these documents: <a href="https://cloud.google.com/deployment-manager/docs/step-by-step-guide/create-a-template">Creating a Template Step-by-step</a> and <a href="https://cloud.google.com/deployment-manager/docs/configuration/templates/create-basic-template">Creating a Basic Template</a>.</p>

<p>It&rsquo;s not trivial however. And using the API can also be confusing. The Google Code is just a generated Go code file using gRPC. But studying it may provide valuable insigth into how the API is structured. I&rsquo;m also providing some basic samples that I gathered together and the readme does a bit more explaining on how to use them.</p>

<h3 id="your-first-stack">Your First Stack</h3>

<p>Once you have everything set-up you&rsquo;ll need a configuration file for Furnace. The usage is outlined more here <a href="#YAML-Configuration">YAML Configuration</a>. The configuration file for GCP looks like this:</p>

<pre><code class="language-yaml">main:
  project_name: testplatform-1234
  spinner: 1
gcp:
  template_name: google_template.yaml
  stack_name: test-stack

</code></pre>

<p>Where <code>project_name</code> is the name you generate for your first billable Google Cloud Platform project. Template lives next to this yaml file and stack name must be DNS complient.</p>

<p>Once you have a project and a template setup, it&rsquo;s as simple as calling <code>./furnace-gcp create</code> or <code>./furnace-gcp create mycustomstack</code>.</p>

<h3 id="deleting">Deleting</h3>

<p>Deleting happens with <code>./furnace-gcp delete</code> or <code>./furnace-gcp delete mycustomstack</code>. Luckily, as with AWS, this means that every resource created with the DeploymentManager will be deleted leaving no need for search and cleanup.</p>

<h3 id="project-name-vs-project-id">Project Name vs. Project ID</h3>

<p>Unlike with AWS Google requires your stack name and project id to be DNS complient. This is most likely because all API calls and such contain that information.</p>

<h2 id="separate-binaries">Separate Binaries</h2>

<p>In order to mitigate some of Furnace&rsquo;s size, I&rsquo;m providing separate binaries for each service it supports.</p>

<p>The AWS binaries can be found in <code>aws</code> folder, and respectively, the Google Cloud Platform is located in <code>gcp</code>. Both are build-able by running <code>make</code>.</p>

<p>If you would like to run both with a single command, a top level make file is provided for your convinience. Just run <code>make</code> from the root. That will build all binaries. Later on, Digital Oceans will join the ranks.</p>

<h2 id="yaml-configuration">YAML Configuration</h2>

<p>Last but not least, Furnace now employs YAML files for configuration. However, it isn&rsquo;t JUST using YAML files. It also employs a smart configuration pattern which works as follows.</p>

<p>Since Furnace is a distributed binary file which could be running from any given location at any time. Because of that, at first I opted for a global configuration directory.</p>

<p>Now, however, furnace uses a furnace configuration file named with the following pattern: <code>.stackalias.furnace</code>. Where stackname, or stack is the name of a custom stack you would like to create for a project. The content of this file is a single entry, which is the location, relative to this file, of the YAML configuration files for the given stack. For example:</p>

<pre><code class="language-bash">stacks/mydatabasestack.yaml
</code></pre>

<p>This means, that in the directory called <code>stacks</code> there will a yaml configuration file for your database stack. The AWS config file looks like this:</p>

<pre><code class="language-YAML">main:
  stackname: FurnaceStack
  spinner: 1
aws:
  code_deploy_role: CodeDeployServiceRole
  region: us-east-1
  enable_plugin_system: false
  template_name: cloud_formation.template
  app_name: furnace_app
  code_deploy:
    # Only needed in case S3 is used for code deployment
    code_deploy_s3_bucket: furnace_code_bucket
    # The name of the zip file in case it's on a bucket
    code_deploy_s3_key: furnace_deploy_app
    # In case a Git Repository is used for the application, define these two settings
    git_account: Skarlso/furnace-codedeploy-app
    git_revision: b89451234...

</code></pre>

<p>The important part is the <code>template_name</code>. The template has to be next to this yaml file. To use this file, you simply call any of the AWS or GCP commands with an extra, optional parameter like this:</p>

<pre><code class="language-bash">./furnace-aws create mydatabase
</code></pre>

<p>Note that mydatabase will translate to <code>.mydatabase.furnace</code>.</p>

<p>The intelligent part is, that this file could be placed anywhere in the project folder structure; because furnace, when looking for a config file, traverses backwards from the current execution directory up until <code>/</code>. Where root is not included in the search.</p>

<p>Consider the following directory tree:</p>

<p>├── docs<br />
│   ├── <code>furnace-aws status mydatabase</code><br />
├── stacks<br />
│   ├── mystack.template<br />
│   └── mystack.yaml<br />
└── .mydatabase.furnace</p>

<p>You are currently in your <code>docs</code> directory and would like to ask for the status of your database. You don&rsquo;t have to move to the location of the setting file, just simply run the command from where you are. This only works if you are above the location of the file. If you would be below, furnace would say it can&rsquo;t find the file. Because it only traverses upwards.</p>

<p><code>.mydatabase.furnace</code> here contains only a single entry <code>stacks/mystack.yaml</code>. And that&rsquo;s it. This way, you could have multiple furnace files, for example a <code>.database.furnace</code>, <code>.front-end.furnace</code> and a <code>.backend.furnace</code>. All three would work in unison, and if want needs updating, simply run <code>./furnace-aws update backend</code>. And done!</p>

<h1 id="closing-words">Closing words</h1>

<p>As always, contributions are welcomed in the form of issues or pull requests. Questions anything, I tend to answer as soon as I can.</p>

<p>Always run the tests before submitting.</p>

<p>Thank you for reading.
Gergely.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">04 Dec 2017, 22:34</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://skarlso.github.io/2017/12/04/commit-build-deploy/" class="post-title">Commit-Build-Deploy With AWS CodeBuild and Lambda</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">hannibal</strong>
                            
                            
                                under 
                                
                                <a class="post-category post-category-AWS" href="https://skarlso.github.io//categories/aws">AWS</a><a class="post-category post-category-Go" href="https://skarlso.github.io//categories/go">Go</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h1 id="intro">Intro</h1>

<p>Hi All.</p>

<p>Today I would like to write about an AWS finger practice.</p>

<p>Previously, I wrote about how I build and deploy my blog with <a href="www.wercker.com">Wercker</a>. Since, I&rsquo;m a cloud engineer and I dislike Oracle and it&rsquo;s ever expending tenctacles into the abyss, I wanted to switch to use something else.</p>

<p>My build and deploy cycle is simple.</p>

<p>Commit to Blogsource Repo -&gt; Wercker WebHook -&gt; Builds my blog using Hugo -&gt; Pushed to a Different Repository which my Github Blog.</p>

<p>That&rsquo;s all.</p>

<p>It&rsquo;s quiet possible to reproduce this on AWS without infering costs. Unless you publish like&hellip; a couple 100 posts / week.</p>

<p>I&rsquo;m going to use the following services: <a href="https://aws.amazon.com/cloudformation/">CloudFormation</a>, <a href="https://aws.amazon.com/lambda/details/">AWS Lambda</a>, <a href="https://aws.amazon.com/codebuild/">CodeBuild</a>, <a href="https://aws.amazon.com/s3/">S3</a>.</p>

<p>To deploy the below describe architecture in your account in us-east-1 region simply click this button:
<a href="https://console.aws.amazon.com/cloudformation/home?region=us-east-1#/stacks/new?stackName=blogbuilder&amp;templateURL=https://s3.amazonaws.com/blog-builder-template-bucket/template.yaml"><img src="https://skarlso.github.io/img/cloudformation-launch-stack.png" alt="Launch Stack" /></a></p>

<p>BEFORE doing that though you need the following created:</p>

<p>Have a bucket for your lambda function. The lambda function can be found here:</p>

<p><a href="https://github.com/Skarlso/aws-lambda-code-pusher">Lambda Repository</a>.</p>

<p>Zip up the lambda folder contents by doing this:</p>

<pre><code class="language-bash">cd lambda
zip -r gitpusher.zip *
aws s3 cp gitpusher.zip s3://your-lambda-bucket
</code></pre>

<p>That&rsquo;s it.</p>

<p>To read a description of the stack, please continue.</p>

<h1 id="tl-dr">TL;DR;</h1>

<p>The architecture I&rsquo;m about to lay out is simple in its use and design. I tried not to complicate things, because I think the simpler something is, the less prone to failure it will be.</p>

<p>In its most basic form the flow is as follows:</p>

<p><img src="https://skarlso.github.io/img/blog_builder_flow.png" alt="Flow" />.</p>

<p>You push something into a repository you provide. CodeBuild has a webhook to this repository so on each commit it starts to build the blog. The build will use a so called <code>buildspec.yaml</code> file which describes how your blog should be built. Mine looks like this:</p>

<pre><code class="language-yaml">version: 0.2

phases:
  install:
    commands:
      - echo Installing required packages and Hugo
      - apt-get update
      - apt-get install -y git golang wget
      - wget -q https://github.com/gohugoio/hugo/releases/download/v0.31/hugo_0.31_Linux-64bit.deb -O /tmp/hugo.dep
      - dpkg -i /tmp/hugo.dep
  pre_build:
    commands:
      - echo Downloading source code
      - git clone https://github.com/Skarlso/blogsource.git /opt/app
  build:
    commands:
      - echo Build started on `date`
      - cd /opt/app &amp;&amp; hugo --theme purehugo
  post_build:
    commands:
      - echo Build completed on `date`
artifacts:
  files:
    - /opt/app/public/**/*
</code></pre>

<p>When it&rsquo;s finished, CodeBuild will upload everything in the public folder as a zip to a bucket. The bucket has a lambda attached which triggers on putObject event with the extension <code>.zip</code>. It downloads the archive, extracts it and pushes it to another repository, which is the repository for the blog.</p>

<p>And done! That&rsquo;s it. For an architecture overview, please read on.</p>

<h1 id="architecture">Architecture</h1>

<p>Now, we are going to use CloudFormation stack to deploy these resources. Because we aren&rsquo;t animals to create them by hand, yes?</p>

<p>An overview of my current architecture is best shown by this image:</p>

<p><img src="https://skarlso.github.io/img/blog_builder_cf_template.png" alt="AWS Stack" />.</p>

<p>Let&rsquo;s go over these components one - by - one.</p>

<h2 id="lambda-role">Lambda Role</h2>

<p>This is the <a href="http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html">Role</a> which allows the Lambda to access things in your account. It needs the following service access: s3, logs, lambda; and the following permissions: logs:Create*, logs:PutLogEvents, s3:GetObject, s3:ListBucket.</p>

<h2 id="code-build-role">Code Build Role</h2>

<p>This is the role which allows CodeBuild to have access to services it needs. These services are the following: s3, logs, ssm, codebuild. CodeBuild also needs the following actions allowed: logs:Create*, logs:PutLogEvents, s3:GetObject, s3:PutObject, ssm:GetParameters.</p>

<h2 id="build-bucket">Build Bucket</h2>

<p>This is the bucket in which CodeBuild will push the generated build artifact.</p>

<h2 id="blog-pusher-function">Blog Pusher Function</h2>

<p>This is the heart of this project. It contains the logic to download the zipped artifact, extract it, create a hollow repository from the extracted archive and push the changes to the repository. And just the changes.</p>

<p>This is achieve by a short Python 3.6 script which can be found in the linked repository.</p>

<h2 id="parameters">Parameters</h2>

<p>The stack requires you to provide a couple of parameters which are described in the template. Like, bucket name, github repository, git token and such. Please refer to the template for a full description of each.</p>

<h2 id="charges">Charges</h2>

<p>I recently push a couple of builds to test this configuration and I inferred 0.2 USD in charges. But that was like 10-15 builds a day.</p>

<h1 id="deploying">Deploying</h1>

<p>In order to deploy this you can use <a href="https://github.com/Skarlso/go-furnace">Furnace</a> to easily manage the template and it&rsquo;s parameters. Once you copy the template to the target directory, simply run <code>furnace aws create</code> and provide the necessary parameters.</p>

<h1 id="conclusion">Conclusion</h1>

<p>And that is all. A nice little stack which does the same as Wercker without costs but the leisure of simply pushing up some change to a repository of your choosing.</p>

<p>I hope you enjoyed this little write up as much as I enjoyed creating it.</p>

<p>As always,
Thanks for reading!
Gergely.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">06 Nov 2017, 20:34</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://skarlso.github.io/2017/11/06/furnace-ikea-manual/" class="post-title">Furnace Ikea Manual</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">hannibal</strong>
                            
                            
                                under 
                                
                                <a class="post-category post-category-Furnace" href="https://skarlso.github.io//categories/furnace">Furnace</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>Hi there folks.</p>

<p>Just a quick post, of how I went on and created an IKEA manual about <a href="https://github.com/Skarlso/go-furnace">Furnace</a>.</p>

<p>Page 1: <img src="https://skarlso.github.io/img/ikea-furnace-1.png" alt="Page 1" />.
Page 2: <img src="https://skarlso.github.io/img/ikea-furnace-2.png" alt="Page 2" />.</p>

<p>I drew these using <a href="https://krita.org/en/">Krita</a>. I mostly used a mouse but I also used a Wacom Bamboo drawing tabled, for sketches and such.</p>

<p>Thanks,
Gergely.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">03 Sep 2017, 10:34</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://skarlso.github.io/2017/09/03/furnace-binaries/" class="post-title">Furnace Binaries</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">hannibal</strong>
                            
                            
                                under 
                                
                                <a class="post-category post-category-Go" href="https://skarlso.github.io//categories/go">Go</a><a class="post-category post-category-Furnace" href="https://skarlso.github.io//categories/furnace">Furnace</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>Hey folks.</p>

<p>Quick note. Furnace now comes pre-compiled easy to access binaries which you can download and use out of the box.</p>

<p>No need to install anything, or compile the source. Just download, unzip and use.</p>

<p>Here is the website: <a href="https://skarlso.github.io/furnace-web">Furnace Website</a>.</p>

<p>Enjoy,
Cheers,
Gergely.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">31 May 2017, 06:23</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://skarlso.github.io/2017/05/31/notetaking/" class="post-title">Notetaking</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">hannibal</strong>
                            
                            
                                under 
                                
                                <a class="post-category post-category-Scribble" href="https://skarlso.github.io//categories/scribble">Scribble</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p><img src="https://skarlso.github.io/img/page1.jpeg" alt="Page1" /></p>

<p><img src="https://skarlso.github.io/img/page2.jpeg" alt="Page2" /></p>

                    </div>
                </section>
                
                <h1 class="content-subhead">28 May 2017, 19:23</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://skarlso.github.io/2017/05/28/replace-eval-with-object-send-and-a-parser/" class="post-title">Replacing Eval with Object.send and a self written Parser</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">hannibal</strong>
                            
                            
                                under 
                                
                                <a class="post-category post-category-Ruby" href="https://skarlso.github.io//categories/ruby">Ruby</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h1 id="intro">Intro</h1>

<p>A while ago, I was added as a curator for a Gem called <a href="https://github.com/joshbuddy/jsonpath">JsonPath</a>. It&rsquo;s a small but very useful and brilliant gem. It had a couple of problems which I fixed, but the hardest to eliminate proved to be a series of evals throughout the code.</p>

<p>You could opt in using <code>eval</code> with a constructor parameter, but generally, it was considered to be unsafe. Thus, normally when a project was using it, like <a href="https://github.com/huginn/huginn">Huginn</a> they had to opt out by default, thus missing out on sweet parsing like this: <code>$..book[?(@['price'] &gt; 20)]</code>.</p>

<h2 id="eval">Eval</h2>

<p>In order to remove eval, first I had to understand what it is actually doing. I had to take it apart.</p>

<p><img src="https://skarlso.github.io/img/takeevalapart.jpg" alt="apart" /></p>

<p>After much digging and understanding the code, I found, all it does is perform the given operations on the current node. And if the operation is true, it will select that node, otherwise, return false, and ignore that node.</p>

<p>For example <code>$..book[?(@['price'] &gt; 20)]</code> could be translated to:</p>

<pre><code class="language-ruby">return @_current_node['price'] &gt; 20
</code></pre>

<p>Checking first if <code>'price'</code> is even a key in <code>@_current_node</code>. Once I&rsquo;ve understood this part, I set on trying to fix eval.</p>

<h3 id="safe-4">SAFE = 4</h3>

<p>In ruby, you could extract the part where you Eval and put it into its own proc and set <code>SAFE = 4</code> which will disable some things like system calls.</p>

<pre><code class="language-ruby">proc do
  SAFE = 4
  eval(some_expression)
end.call
</code></pre>

<p>SAFE levels:</p>

<p>$SAFE   Description
0   No checking of the use of externally supplied (tainted) data is performed. This is Ruby&rsquo;s default mode.
&gt;= 1    Ruby disallows the use of tainted data by potentially dangerous operations.
&gt;= 2    Ruby prohibits the loading of program files from globally writable locations.
&gt;= 3    All newly created objects are considered tainted.
&gt;= 4    Ruby effectively partitions the running program in two. None - tainted objects may not be modified. Typically, this will be used to create a sandbox: the program sets up an environment using a lower $SAFE level, then resets $SAFE to 4 to prevent subsequent changes to that environment.</p>

<p>This has the disadvantage that anything below 4 is just, meh. But nothing above 1 will actually work with JsonPath so&hellip; scratch that.</p>

<h3 id="sandboxing">Sandboxing</h3>

<p>We could technically try and sandbox eval into it&rsquo;s own process with a PID and whitelist methods which are allowed to be called.</p>

<p>Not bad, and there are a few gems out there which are trying to do that like <a href="https://github.com/ukutaht/safe_ruby">SafeRuby</a>. But all of these project have been abandoned years ago for a good reason.</p>

<h3 id="object-send">Object.send</h3>

<p><img src="https://skarlso.github.io/img/nobodylikesyou.jpg" alt="nobodylikesyou" /></p>

<p><code>Object.send</code> is the best way to get some flexibility while still being safe. You basically just call methods on objects by describing said method on an object and giving parameters to it, like:</p>

<pre><code class="language-ruby">1.send(:+, 2) =&gt; 3
</code></pre>

<p>This is a very powerful tool in our toolbox which we will exploit immensely.</p>

<p>So let&rsquo;s get to it.</p>

<h1 id="writing-a-parser">Writing a parser</h1>

<p>Writing a parser in Ruby is a very fluid experience. It has nice tools which support that, and the one I used is <code>StringScanner</code>. It has the ability to track where you are currently at in a string and move a pointer along with regex matches. In fact, JsonPath already employs this method when parsing a json expression. So reusing that logic was in fact&hellip; elementary.</p>

<h2 id="the-expression">The expression</h2>

<p>How do we get from this:</p>

<pre><code class="language-bash">$..book[?(@['price'] &lt; 20)]
</code></pre>

<p>To this:</p>

<pre><code class="language-ruby">@_current_node['price'] &lt; 20
</code></pre>

<p>Well. By simple elimination. There are a couple of problems along the way of course. Because this wouldn&rsquo;t be a parser if it couldn&rsquo;t handle ALL the other cases&hellip;</p>

<h3 id="removing-clutter">Removing Clutter</h3>

<p>Some of this we don&rsquo;t need. Like, <code>$..book</code> part.</p>

<p><img src="https://skarlso.github.io/img/dontneed1.jpg" alt="dontneed1" /></p>

<p>The other things we don&rsquo;t need are all the <code>'[]?()</code></p>

<p><img src="https://skarlso.github.io/img/dontneed2.jpg" alt="dontneed2" /></p>

<p>Once this is done, we can move to isolating the important bits.</p>

<p><img src="https://skarlso.github.io/img/takingaim.jpg" alt="takingaim" /></p>

<h3 id="breakdown">BreakDown</h3>

<h4 id="elements">Elements</h4>

<p>How does an expression actually look like?</p>

<p>Let&rsquo;s break it down.</p>

<p><img src="https://skarlso.github.io/img/confused.jpg" alt="confused" /></p>

<p>So, this is a handful. Operations can be <code>&lt;=,&gt;=,&lt;,&gt;,==,!=</code> and operands can be either numbers, or words, and element accessor can be nested since something like this is perfectly valid: <code>$..book[?(@.written.year == 1997)]</code>.</p>

<p><img src="https://skarlso.github.io/img/feedline.jpg" alt="feedline" /></p>

<p>To avoid being overwhelmed, ruby has our back with a method called <code>dig</code>.</p>

<p><img src="https://skarlso.github.io/img/dig.jpg" alt="dig" /></p>

<p>This, basically lets us pass in some parameters into a dig function on a hash or an array with variadic parameters, which will go on and access those elements in order how they were supplied. Until it either returns a <code>nil</code> or an end result.</p>

<p>For example:</p>

<pre><code class="language-ruby">2.3.1 :001 &gt; a = {a: {b: 'c'}}
 =&gt; {:a=&gt;{:b=&gt;&quot;c&quot;}}
2.3.1 :002 &gt; a.dig(:a, :b)
 =&gt; &quot;c&quot;
</code></pre>

<p>Easy. However&hellip; Dig was only added after ruby 2.3 thus, I had to write my own dig for now, until I stop supporting anything below 2.3.</p>

<p>At first, I wanted to add it to the hash class, but it proved to be a futile attempt if I wanted to do it nicely, thus the parser got it as a private method.</p>

<pre><code class="language-ruby">    def dig(keys, hash)
      return hash unless hash.is_a? Hash
      return nil unless hash.key?(keys.first)
      return hash.fetch(keys.first) if keys.size == 1
      prev = keys.shift
      dig(keys, hash.fetch(prev))
    end
</code></pre>

<p>And the corresponding regex behind getting a multitude of elements is as follows:</p>

<pre><code class="language-ruby">...
if t = scanner.scan(/\['\w+'\]+/)
...
</code></pre>

<h4 id="operator">Operator</h4>

<p>Selecting the operator is another interesting part as it can be a single one or multiple and all sorts. Until I realized that no&hellip; it can actually be only a couple.</p>

<p><img src="https://skarlso.github.io/img/whatone.jpg" alt="whatone" /></p>

<p><img src="https://skarlso.github.io/img/whattwo.jpg" alt="whattwo" /></p>

<p>Also, after a bit of fiddling and doing and doing a silly case statement first:</p>

<pre><code class="language-ruby">case op
when '&gt;'
  dig(@_current_node, *elements) &gt; operand
when '&lt;'
  dig(@_current_node, *elements) &gt; operand
...
end
</code></pre>

<p>&hellip;I promptly saw that this is not how it should be done.</p>

<p>And here comes Object.send.</p>

<p><img src="https://skarlso.github.io/img/send.jpg" alt="send" /></p>

<p>This gave me the opportunity to write this:</p>

<pre><code class="language-ruby">dig(elements, @_current_node).send(operator, operand)
</code></pre>

<p>Much better. Now I could send all the things in the way of a node.</p>

<p><img src="https://skarlso.github.io/img/sendtwo.jpg" alt="send" /></p>

<p>Parsing an op be like:</p>

<pre><code class="language-ruby">elsif t = scanner.scan(/\s+[&lt;&gt;=][&lt;&gt;=]?\s+?/)
</code></pre>

<h4 id="operand">Operand</h4>

<p>Now comes the final piece. The value which we are comparing. This could either be a simple integer, a floating number, or a word. Hah. So coming up with a regex which fits this tightly took a little fiddling, but eventually I ended up with this:</p>

<pre><code class="language-ruby">elsif t = scanner.scan(/(\s+)?'?(\w+)?[.,]?(\w+)?'?(\s+)?/)
</code></pre>

<p>Without StackOverflow I would say this is fine ((although I need to remove all those space check, shees)). What are all the question marks? Basically, everything is optional. Because an this expression <code>$..book[?(@.price)]</code> is valid. Which is basically just asserting if a given node has a price element.</p>

<h4 id="logical-operators">Logical Operators</h4>

<p>The last thing that remains is logical operators, which if you are using eval, is pretty straight forward. It takes care of anything that you might add in like <code>&amp;&amp;, ||, |, &amp;, ^</code> etc etc.</p>

<p>Now, that&rsquo;s something I did with a case though. Until I find a nicer solution. Since we can already parse a single expression it&rsquo;s just a question of breaking down a multi structure expression as the following one: <code>$..book[?(@['price'] &gt; 20 &amp;&amp; @.written.year == 1998)]</code>.</p>

<pre><code class="language-ruby">exps = exp.split(/(&amp;&amp;)|(\|\|)/)
</code></pre>

<p>This splits up the string by either <code>&amp;&amp;</code> or <code>||</code> and the usage of groups () also includes the operators. Than I evaluate the expressions and save the whole thing in an array like <code>[true, '&amp;&amp;', false]</code>. You know what could immediately resolve this? Yep&hellip;</p>

<p><img src="https://skarlso.github.io/img/saynotoeval.jpg" alt="saynotoeval" />.</p>

<p>I&rsquo;d rather just parse it although technically an eval at this stage wouldn&rsquo;t be that big of a problem&hellip;</p>

<pre><code class="language-ruby">def parse(exp)
  exps = exp.split(/(&amp;&amp;)|(\|\|)/)
  ret = parse_exp(exps.shift)
  exps.each_with_index do |item, index|
    case item
    when '&amp;&amp;'
      ret &amp;&amp;= parse_exp(exps[index + 1])
    when '||'
      ret ||= parse_exp(exps[index + 1])
    end
  end
  ret
end
</code></pre>

<h1 id="closing-words">Closing words</h1>

<p>That&rsquo;s it folks. The parser is done. And there is no eval being used. There are some more things here that are interesting. Like, array indexing is allowed in jsonpath which is solved by sending <code>.length</code> to a current node. For example:</p>

<pre><code class="language-ruby">if scanner.scan(/\./)
  sym = scanner.scan(/\w+/)
  op = scanner.scan(/./)
  num = scanner.scan(/\d+/)
  return @_current_node.send(sym.to_sym).send(op.to_sym, num.to_i)
end
</code></pre>

<p>If an expression begins with a <code>.</code>. So you see that using <code>send</code> will help a lot, and understanding what eval is trying to evaluate and rather writing your own parser, isn&rsquo;t that hard at all using ruby.</p>

<p>I hope you enjoyed reading this little tid-bit as much as I enjoyed writing and drawing it. Leave a comment if your liked the drawings or if you did not and I should never do them again (( I don&rsquo;t really care, this is my blog haha. )). Note to self: I shouldn&rsquo;t draw on the other side of the drawing because of bleed-through.</p>

<p>Thank you!
Gergely.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">16 Apr 2017, 09:23</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://skarlso.github.io/2017/04/16/building-furnace-part-4/" class="post-title">Furnace - The building of an AWS CLI Tool for CloudFormation and CodeDeploy - Part 4</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">hannibal</strong>
                            
                            
                                under 
                                
                                <a class="post-category post-category-Golang" href="https://skarlso.github.io//categories/golang">Golang</a><a class="post-category post-category-AWS" href="https://skarlso.github.io//categories/aws">AWS</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h1 id="intro">Intro</h1>

<p>Hi folks.</p>

<p>Previously on this blog: <a href="https://skarlso.github.io/2017/03/16/building-furnace-part-1/">Part 1</a>. <a href="https://skarlso.github.io/2017/03/19/building-furnace-part-2/">Part 2</a>. <a href="https://skarlso.github.io/2017/03/22/building-furnace-part-3/">Part 3</a>.</p>

<p>In this part we are going to talk about Unit Testing Furnace and how to work some magic with AWS and Go.</p>

<h1 id="mock-stub-fake-dummy-canned-insert-name-here">Mock Stub Fake Dummy Canned <Insert Name Here></h1>

<p>Unit testing in Go usually follows the Dependency Injection model of dealing with Mocks and Stubs.</p>

<p>## DI</p>

<p>Dependency Inject in short is one object supplying the dependencies of another object. In a longer description, it&rsquo;s ideal to be used
for removing the lock on a third party library, like the AWS client. Imaging having code which solely depends on the AWS client. How
would you unit test that code without having to ACTUALLY connect to AWS? You couldn&rsquo;t. Every time you try to test the code it would run
the live code and it would try and connect to AWS and perform the operations it&rsquo;s design to do. The Ruby library with it&rsquo;s metaprogramming
allows you to set the client globally to stub responses, but, alas, this is not the world of Ruby.</p>

<p>Here is where DI comes to the rescue. If you have control over the AWS client on a very high level, and would pass it around as a function
parameter, or create that client in an <code>init()</code> function and have it globally defined; you would be able to implement your own client, and
have your code use that with stubbed responses which your tests need. For example, you would like a CreateApplication call to fail, or you
would like a DescribeStack which returns an aws.Error(&ldquo;StackAlreadyExists&rdquo;).</p>

<p>For this, however, you need the API of the AWS client. Which is provided by AWS.</p>

<h2 id="aws-client-api">AWS Client API</h2>

<p>In order for DI to work, the injected object needs to be of a certain type for us to inject our own. Luckily, AWS provides an Interface for
all of it&rsquo;s clients. Meaning, we can implement our own version for all of the clients, like S3, CloudFormation, CodeDeploy etc.</p>

<p>For each client you want to mock out, an <em>*iface</em> package should be present like this:</p>

<pre><code class="language-go">  &quot;github.com/aws/aws-sdk-go/service/cloudformation/cloudformationiface&quot;
</code></pre>

<p>In this package you find and use the interface like this:</p>

<pre><code class="language-go">type fakeCloudFormationClient struct {
	cloudformationiface.CloudFormationAPI
	err error
}
</code></pre>

<p>And with this, we have our own CloudFormation client. The real code uses the real clients as function parameters, like this:</p>

<pre><code class="language-go">// Execute defines what this command does.
func (c *Create) Execute(opts *commander.CommandHelper) {
	log.Println(&quot;Creating cloud formation session.&quot;)
	sess := session.New(&amp;aws.Config{Region: aws.String(config.REGION)})
	cfClient := cloudformation.New(sess, nil)
	client := CFClient{cfClient}
	createExecute(opts, &amp;client)
}
</code></pre>

<p>We can&rsquo;t test Execute itself, as it&rsquo;s using the real client here (or you could have a global from some library, thus allowing you to tests
even <code>Execute</code> here) but there is very little logic in this function for this very reason. All the logic is in small functions for which
the main starting point and our testing opportunity is, <code>createExecute</code>.</p>

<h2 id="stubbing-calls">Stubbing Calls</h2>

<p>Now, that we have our own client, and with the power of Go&rsquo;s interface embedding as seen above with CloudFormationAPI, we have to only stub
the functions which we are actually using, instead of every function of the given interface. This looks like this:</p>

<pre><code class="language-go">	cfClient := new(CFClient)
	cfClient.Client = &amp;fakeCloudFormationClient{err: nil}
</code></pre>

<p>Where cfClient is a struct like this:</p>

<pre><code class="language-go">// CFClient abstraction for cloudFormation client.
type CFClient struct {
	Client cloudformationiface.CloudFormationAPI
}
</code></pre>

<p>And a stubbed call can than be written as follows:</p>

<pre><code class="language-go">func (fc *fakeCreateCFClient) WaitUntilStackCreateComplete(input *cloudformation.DescribeStacksInput) error {
	return nil
}
</code></pre>

<p>This can range from a very trivial example, like the one above, to intricate ones as well, like this gem:</p>

<pre><code class="language-go">func (fc *fakePushCFClient) ListStackResources(input *cloudformation.ListStackResourcesInput) (*cloudformation.ListStackResourcesOutput, error) {
	if &quot;NoASG&quot; == *input.StackName {
		return &amp;cloudformation.ListStackResourcesOutput{
			StackResourceSummaries: []*cloudformation.StackResourceSummary{
				{
					ResourceType:       aws.String(&quot;NoASG&quot;),
					PhysicalResourceId: aws.String(&quot;arn::whatever&quot;),
				},
			},
		}, fc.err
	}
	return &amp;cloudformation.ListStackResourcesOutput{
		StackResourceSummaries: []*cloudformation.StackResourceSummary{
			{
				ResourceType:       aws.String(&quot;AWS::AutoScaling::AutoScalingGroup&quot;),
				PhysicalResourceId: aws.String(&quot;arn::whatever&quot;),
			},
		},
	}, fc.err
}
</code></pre>

<p>This ListStackResources stub lets us test two scenarios based on the stackname. If the test stackname is &lsquo;NoASG&rsquo; it will return a result
which equals to a result containing no AutoScaling Group. Otherwise, it will return the correct ResourceType for an ASG.</p>

<p>It is a common practice to line up several scenario based stubbed responses in order to test the robustness of your code.</p>

<p>Unfortunately, this also means that your tests will be a bit cluttered with stubs and mock structs and whatnots. For that, I&rsquo;m partially
using a package available struct file in which I&rsquo;m defining most of the mock structs at least. And from there on, the tests will only contain
specific stubs for that particular file. This can be further fine grained by having defaults and than only override in case you need something
else.</p>

<h1 id="testing-fatals">Testing fatals</h1>

<p>Now, the other point which is not really AWS related, but still comes to mind when dealing with Furnace, is testing error scenarios.</p>

<p>Because Furnace is a CLI application it uses Fatals to signal if something is wrong and it doesn&rsquo;t want to continue or recover because, frankly
it can&rsquo;t. If AWS throws an error, that&rsquo;s it. You can retry, but in 90% of the cases, it&rsquo;s usually something that you messed up.</p>

<p>So, how do we test for a fatal or an <code>os.Exit</code>? There are a number of points on that if you do a quick search. You may end up on this talk:
<a href="https://talks.golang.org/2014/testing.slide#23">GoTalk 2014 Testing Slide #23</a>. Which does an interesting thing. It calls the test binary in a
separate process and tests the exit code.</p>

<p>Others, and me as well, will say that you have to have your own logger implemented and use a different logger / os.Exit in your test environment.</p>

<p>Others others will tell you to not to have tests around os.Exit and fatal things, rather return an error and only the main should pop a world
ending event. I leave it up to you which you want to use. Either is fine.</p>

<p>In Furnace, I&rsquo;m using a global logger in my error handling util like this:</p>

<pre><code class="language-go">// HandleFatal handler fatal errors in Furnace.
func HandleFatal(s string, err error) {
	LogFatalf(s, err)
}
</code></pre>

<p>And <code>LogFatalf</code> is an exported variable <code>var LogFatalf = log.Fatalf</code>. Than in a test, I just override this variable with a local anonymous
function:</p>

<pre><code class="language-go">func TestCreateExecuteEmptyStack(t *testing.T) {
	failed := false
	utils.LogFatalf = func(s string, a ...interface{}) {
		failed = true
	}
	config.WAITFREQUENCY = 0
	client := new(CFClient)
	stackname := &quot;EmptyStack&quot;
	client.Client = &amp;fakeCreateCFClient{err: nil, stackname: stackname}
	opts := &amp;commander.CommandHelper{}
	createExecute(opts, client)
	if !failed {
		t.Error(&quot;expected outcome to fail during create&quot;)
	}
}
</code></pre>

<p>It can get even more granular by testing for the error message to make sure that it actually fails at the point we think we are
testing:</p>

<pre><code class="language-go">func TestCreateStackReturnsWithError(t *testing.T) {
	failed := false
	expectedMessage := &quot;failed to create stack&quot;
	var message string
	utils.LogFatalf = func(s string, a ...interface{}) {
		failed = true
		if err, ok := a[0].(error); ok {
			message = err.Error()
		}
	}
	config.WAITFREQUENCY = 0
	client := new(CFClient)
	stackname := &quot;NotEmptyStack&quot;
	client.Client = &amp;fakeCreateCFClient{err: errors.New(expectedMessage), stackname: stackname}
	config := []byte(&quot;{}&quot;)
	create(stackname, config, client)
	if !failed {
		t.Error(&quot;expected outcome to fail&quot;)
	}
	if message != expectedMessage {
		t.Errorf(&quot;message did not equal expected message of '%s', was:%s&quot;, expectedMessage, message)
	}
}
</code></pre>

<h1 id="conclusion">Conclusion</h1>

<p>This is it. That&rsquo;s all it took to write Furnace. I hope you enjoyed reading it as much as I enjoyed writing all these thoughts down.</p>

<p>I hope somebody might learn from my journey and also improve upon it.</p>

<p>Any comments are much appreciated and welcomed. Also, PRs and Issues can be submitted on the GitHub page of <a href="https://github.com/Skarlso/go-furnace">Furnace</a>.</p>

<p>Thank you for reading!
Gergely.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">22 Mar 2017, 12:03</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://skarlso.github.io/2017/03/22/building-furnace-part-3/" class="post-title">Furnace - The building of an AWS CLI Tool for CloudFormation and CodeDeploy - Part 3</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">hannibal</strong>
                            
                            
                                under 
                                
                                <a class="post-category post-category-Golang" href="https://skarlso.github.io//categories/golang">Golang</a><a class="post-category post-category-AWS" href="https://skarlso.github.io//categories/aws">AWS</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h1 id="intro">Intro</h1>

<p>Hi folks.</p>

<p>Previously on this blog: <a href="http://skarlso.github.io/2017/03/16/building-furnace-part-1/">Part 1</a>. <a href="https://skarlso.github.io/2017/03/19/building-furnace-part-2/">Part 2</a>. <a href="https://skarlso.github.io/2017/04/16/building-furnace-part-4/">Part 4</a>.</p>

<p>In this part, I&rsquo;m going to talk about the experimental plugin system of Furnace.</p>

<h1 id="go-experimental-plugins">Go Experimental Plugins</h1>

<p>Since Go 1.8 was released, an exciting and new feature was introduced called a Plug-in system. This system works with dynamic
libraries built with a special switch to <code>go build</code>. These libraries, <code>.so</code> or <code>.dylib</code> (later), are than loaded and once that
succeeds, specific functions can be called from them (symbol resolution).</p>

<p>We will see how this works. For package information, visit the plugin packages Go doc page
<a href="https://tip.golang.org/pkg/plugin/">here</a>.</p>

<h1 id="furnace-plugins">Furnace Plugins</h1>

<p>So, what does furnace use plugins for? Furnace uses plugins to execute arbitery code in, currently, four given locations / events.</p>

<p>These are: <code>pre_create, post_create, pre_delete, post_delete</code>. These events are called, as their name suggests, before and after
the creation and deletion of the CloudFormation stack. It allows the user to execute some code without having to rebuild the whole
project. It does that by defining a single entry point for the custom code called <code>RunPlugin</code>. Any number of functions can be
implemented, but the plugin MUST provide this single, exported function. Otherwise it will fail and ignore that plugin.</p>

<h2 id="using-plugins">Using Plugins</h2>

<p>It&rsquo;s really easy to implement, and use these plugins. I&rsquo;m not going into the detail of how to load them, because that is done by
Furnace, but only how to write and use them.</p>

<p>To use a plugin, create a go file called: <code>0001_mailer.go</code>. The <code>0001</code> before it will define WHEN it&rsquo;s executed.
Having multiple plugins is completely okay. Execution of order however, depends on the names of the files.</p>

<p>Now, in 0001_mailer.post_create we would have something like this:</p>

<pre><code class="language-go">package main

import &quot;log&quot;

// RunPlugin runs the plugin.
func RunPlugin() {
	log.Println(&quot;My Awesome Pre Create Plugin.&quot;)
}
</code></pre>

<p>Next step is the build this file to be a plugin library. Note: Right now, this only works on Linux!</p>

<p>To build this file run the following:</p>

<pre><code>go build -buildmode=plugin -o 0001_mailer.pre_create 0001_mailer.go
</code></pre>

<p>The important part here is the extension of the file specified with <code>-o</code>. It&rsquo;s important because that&rsquo;s how Furnace identifies
what plugins it has to run.</p>

<p>Finally, copy this file to <code>~/.config/go-furnace/plugins</code> and you are all set.</p>

<h2 id="slack-notification-plugin">Slack notification Plugin</h2>

<p>To demonstrate how a plugin could be used is if you need some kind of notification once a Stack is completed. For example, you
might want to send a message to a Slack room. To do this, your plugin would look something like this:</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;os&quot;

	&quot;github.com/nlopes/slack&quot;
)

func RunPlugin() {
	stackname := os.Getenv(&quot;FURNACE_STACKNAME&quot;)
	api := slack.New(&quot;YOUR_TOKEN_HERE&quot;)
	params := slack.PostMessageParameters{}
	channelID, timestamp, err := api.PostMessage(&quot;#general&quot;, fmt.Sprintf(&quot;Stack with name '%s' is Done.&quot;, stackname), params)
	if err != nil {
		fmt.Printf(&quot;%s\n&quot;, err)
		return
	}
	fmt.Printf(&quot;Message successfully sent to channel %s at %s&quot;, channelID, timestamp)
}
</code></pre>

<p>Currently, Furnace has no ability to share information of the stack with an outside plugin. Thus &lsquo;Done&rsquo; could be anything from
Rollback to Failed to CreateComplete.</p>

<h1 id="closing-words">Closing Words</h1>

<p>That&rsquo;s it for plugins. Thanks very much for reading!
Gergely.</p>

                    </div>
                </section>
                
            </div>
            
<div class="pagination">
  <nav role="pagination" class="post-list-pagination">
      
    <span class="post-list-pagination-item post-list-pagination-item-current">Page 1 of 13</span>
    
      <a href="https://skarlso.github.io/page/2/" class="post-list-pagination-item pure-button post-list-pagination-item-next">
        Older&nbsp;<i class="fa fa-angle-double-right"></i>
      </a>
    
  </nav>
</div>


            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
            <li>Powered by <a class="hugo" href="https://gohugo.io/" target="_blank">hugo</a></li>
        </ul>
    </div>
</div>
<script src="https://skarlso.github.io//js/all.min.js"></script>

        </div>
    </div>
</div>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-69463020-2', 'auto');
ga('send', 'pageview');

</script>

</body>
</html>
