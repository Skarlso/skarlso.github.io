<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Extensive tutorial on go-plugin. | Ramblings of a cloud engineer</title>
<meta name="keywords" content="">
<meta name="description" content="go-plugin tutorial">
<meta name="author" content="hannibal">
<link rel="canonical" href="https://skarlso.github.io/2018/10/29/go-plugin-tutorial/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://skarlso.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://skarlso.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://skarlso.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://skarlso.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://skarlso.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://skarlso.github.io/2018/10/29/go-plugin-tutorial/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Extensive tutorial on go-plugin.">
<meta property="og:description" content="go-plugin tutorial">
<meta property="og:type" content="article">
<meta property="og:url" content="https://skarlso.github.io/2018/10/29/go-plugin-tutorial/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-10-29T07:01:00+01:00">
<meta property="article:modified_time" content="2018-10-29T07:01:00+01:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Extensive tutorial on go-plugin.">
<meta name="twitter:description" content="go-plugin tutorial">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://skarlso.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Extensive tutorial on go-plugin.",
      "item": "https://skarlso.github.io/2018/10/29/go-plugin-tutorial/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Extensive tutorial on go-plugin.",
  "name": "Extensive tutorial on go-plugin.",
  "description": "go-plugin tutorial",
  "keywords": [
    
  ],
  "articleBody": "Intro If you don’t know what go-plugin is, don’t worry, here is a small introduction on the subject matter:\nBack in the old days when Go didn’t have the plugin package, HashiCorp was desperately looking for a way to use plugins.\nIn the old days, Lua plus Go wasn’t really a thing yet, and to be honest, nobody wants to write Lua ( joking!).\nAnd thus Mitchell had this brilliant idea of using RPC over the local network to serve a local interface as something that could easily be implemented with any other language that supported RPC. This sounds convoluted but has many benefits! For example, your code will never crash because of a plugin and the ability to use any language to implement a plugin. Not just Go.\nIt has been a battle-hardened solution for years now and is being actively used by Terraform, Vault, Consule, and especially Packer. All using go-plugin in order to provide a much needed flexibility. Writing a plugin is easy. Or so they say.\nIt can get complicated quickly, for example, if you are trying to use GRPC. You can lose sight of what exactly you’ll need to implement, where and why; or utilizing various languages or using go-plugins in your own project and extending your CLI with pluggable components.\nThese are all nothing to sneeze at. Suddenly you’ll find yourself with hundreds of lines of code pasted from various examples and yet nothing works. Or worse, it DOES work but you have no idea how. Then you find yourself needing to extend it with a new capability, or you find an elusive bug and can’t trace its origins.\nFear not. I’ll try to demystify things and draw a clear picture about how it works and how the pieces fit together.\nLet’s start at the beginning.\nBasic plugin Let’s start by writing a simple Go GRPC plugin. In fact, we can go through the basic example in the go-plugin’s repository which can be quite confusing when first starting out. We’ll go step-by-step, and the switch to GRPC will be much easier!\nBasic concepts Server In the case of plugins, the Server is the one serving the plugin’s implementation. This means the server will have to provide the implementation to an interface.\nClient The Client calls the server in order to execute the desired behaviour. The underlying logic will connect to the server running on localhost on a random higher port, call the wanted function’s implementation and wait for a response. Once the response is received provide that back to the calling Client.\nImplementation The main function Logger The plugins defined here use stdout in a special way. If you aren’t writing a Go based plugin, you will have to do that yourself by outputting something like this:\n1|1|tcp|127.0.0.1:1234|grpc We’ll come back to this later. Suffice to say the framework will pick this up and will connect to the plugin based on the output. In order to get some output back, we must define a special logger:\n// Create an hclog.Logger logger := hclog.New(\u0026hclog.LoggerOptions{ Name: \"plugin\", Output: os.Stdout, Level: hclog.Debug, }) NewClient // We're a host! Start by launching the plugin process. client := plugin.NewClient(\u0026plugin.ClientConfig{ HandshakeConfig: handshakeConfig, Plugins: pluginMap, Cmd: exec.Command(\"./plugin/greeter\"), Logger: logger, }) defer client.Kill() What is happening here? Let’s see one by one:\nHandshakeConfig: handshakeConfig,: This part is the handshake configuration of the plugin. It has a nice comment as well.\n// handshakeConfigs are used to just do a basic handshake between // a plugin and host. If the handshake fails, a user friendly error is shown. // This prevents users from executing bad plugins or executing a plugin // directory. It is a UX feature, not a security feature. var handshakeConfig = plugin.HandshakeConfig{ ProtocolVersion: 1, MagicCookieKey: \"BASIC_PLUGIN\", MagicCookieValue: \"hello\", } The ProtocolVersion here is used in order to maintain compatibility with your current plugin versions. It’s basically like an API version. If you increase this, you will have two options. Don’t accept lower protocol versions nor switch to the version number and use a different client implementation for a lower version than for a higher version. This way you will maintain backwards compatibility.\nThe MagicCookieKey and MagicCookieValue are used for a basic handshake which the comment is talking about. You have to set this ONCE for your application. Never change it again, for if you do, your plugins will no longer work. For uniqueness sake, I suggest using UUID.\nCmd is one of the most important parts about a plugin. Basically how plugins work is that they boil down to a compiled binary which is executed and starts an RPC server. This is where you will have to define the binary which will be executed and does all this. Since this is all happening locally, (please keep in mind that Go-plugins only support localhost, and for a good reason), these binaries will most likely sit next to your application’s binary or in a pre-configured global location. Something like: ~/.config/my-app/plugins. This is individual for each plugin of course. The plugins can be autoloaded via a discovery function given a path and a glob.\nAnd last but not least is the Plugins map. This map is used in order to identify a plugin called Dispense. This map is globally available and must stay consistent in order for all the plugins to work:\n// pluginMap is the map of plugins we can dispense. var pluginMap = map[string]plugin.Pluglin\t\"greeter\": \u0026example.GreeterPlugin{}, } You can see that the key is the name of the plugin and the value is the plugin.\nWe then proceed to create an RPC client:\n// Connect via RPC rpcClient, err := client.Client() if err != nil { log.Fatal(err) } Nothing fancy about this one…\nNow comes the interesting part:\n// Request the plugin raw, err := rpcClient.Dispense(\"greeter\") if err != nil { log.Fatal(err) } What’s happening here? Dispense will look in the above created map and search for the plugin. If it cannot find it, it will throw an error at us. If it does find it, it will cast this plugin to an RPC or a GRPC type plugin. Then proceed to create an RPC or a GRPC client out of it.\nThere is no call yet. This is just creating a client and parsing it to a respective representation.\nNow comes the magic:\n// We should have a Greeter now! This feels like a normal interface // implementation but is in fact over an RPC connection. greeter := raw.(example.Greeter) fmt.Println(greeter.Greet()) Here we are type asserting our raw GRPC client into our own plugin type. This is so we can call the respective function on the plugin! Once that’s done we will have a {client,struct,implementation} that can be called like a simple function.\nThe implementation right now comes from greeter_impl.go, but that will change once protoc makes an appearance.\nBehind the scenes, go-plugin will do a bunch of hat tricks with multiplexing TCP connections as well as a remote procedure call to our plugin. Our plugin then will run the function, generate some kind of output, and will then send that back for the waiting client.\nThe client will then proceed to parse the message into a given response type and will then return it back to the client’s callee.\nThis concludes main.go for now.\nThe Interface Now let’s investigate the Interface. The interface is used to provide calling details. This interface will be what defines our plugins’ capabilities. How does our Greeter look like?\n// Greeter is the interface that we're exposing as a plugin. type Greeter interface { Greet() string } This is pretty simple. It defines a function which will return a string typed value.\nNow, we will need a couple of things for this to work. Firstly we need something which defines the RPC workings. go-plugin is working with net/http inside. It also uses something called Yamux for connection multiplexing, but we needn’t worry about this detail.\nImplementing the RPC details looks like this:\n// Here is an implementation that talks over RPC type GreeterRPC struct { client *rpc.Client } func (g *GreeterRPC) Greet() string { var resp string err := g.client.Call(\"Plugin.Greet\", new(interface{}), \u0026resp) if err != nil { // You usually want your interfaces to return errors. If they don't, // there isn't much other choice here. panic(err) } return resp } Here the GreeterRPC struct is an RPC specific implementation that will handle communication over RPC. This is Client in this setup.\nIn case of gRPC, this would look something like this:\n// GRPCClient is an implementation of KV that talks over RPC. type GreeterGRPC struct{ client proto.GreeterClient } func (m *GreeterGRPC) Greet() (string, error) { s, err := m.client.Greet(context.Background(), \u0026proto.Empty{}) return s, err } What is happening here? What’s Proto and what is GreeterClient? GRPC uses Google’s protoc library to serialize and unserialize data. proto.GreeterClient is generated Go code by protoc. This code is a skeleton for which implementation detail will be replaced on run time. Well, the actual result will be used and not replaced as such.\nBack to our previous example. The RPC client calls a specific Plugin function called Greet for which the implementation will be provided by a Server that will be streamed back over the RPC protocol.\nThe server is pretty easy to follow:\n// Here is the RPC server that GreeterRPC talks to, conforming to // the requirements of net/rpc type GreeterRPCServer struct { // This is the real implementation Impl Greeter } Impl is the concrete implementation that will be called in the Server’s implementation of the Greet plugin. Now we must define Greet on the RPCServer in order for it to be able to call the remote code. This looks like this:\nfunc (s *GreeterRPCServer) Greet(args interface{}, resp *string) error { *resp = s.Impl.Greet() return nil } This is all still boilerplate for the RPC works. Now comes plugin. For this, the comment is actually quite good too:\n// This is the implementation of plugin.Plugin so we can serve/consume this // // This has two methods: Server must return an RPC server for this plugin // type. We construct a GreeterRPCServer for this. // // Client must return an implementation of our interface that communicates // over an RPC client. We return GreeterRPC for this. // // Ignore MuxBroker. That is used to create more multiplexed streams on our // plugin connection and is a more advanced use case. type GreeterPlugin struct { // Impl Injection Impl Greeter } func (p *GreeterPlugin) Server(*plugin.MuxBroker) (interface{}, error) { return \u0026GreeterRPCServer{Impl: p.Impl}, nil } func (GreeterPlugin) Client(b *plugin.MuxBroker, c *rpc.Client) (interface{}, error) { return \u0026GreeterRPC{client: c}, nil } What does this mean? So, remember: GreeterRPCServer is the one calling the actual implementation while Client is receiving the result of that call. The GreeterPlugin has the Greeter interface embedded just like the RPCServer. We will use the GreeterPlugin as a struct in the plugin map. This is the plugin that we will actually use.\nThis is all still common stuff. These things will need to be visible for both. The plugin’s implementation will use the interface to see what it needs to implement. The Client will use it see what to call and what API is available. Like, Greet.\nHow does the implementation look like?\nThe Implementation In a completely separate package, but which still has access to the interface definition, this plugin could be something like this:\n// Here is a real implementation of Greeter type GreeterHello struct { logger hclog.Logger } func (g *GreeterHello) Greet() string { g.logger.Debug(\"message from GreeterHello.Greet\") return \"Hello!\" } We create a struct and then add the function to it which is defined by the plugin’s interface. This interface, since it’s required by both parties, could well sit in a common package outside of both programs. Something like a SDK. Both code could import it and use it as a common dependency. This way we have separated the interface from the plugin and the calling client.\nThe main function could look something like this:\nlogger := hclog.New(\u0026hclog.LoggerOptions{ Level: hclog.Trace, Output: os.Stderr, JSONFormat: true, }) greeter := \u0026GreeterHello{ logger: logger, } // pluginMap is the map of plugins we can dispense. var pluginMap = map[string]plugin.Plugin{ \"greeter\": \u0026example.GreeterPlugin{Impl: greeter}, } logger.Debug(\"message from plugin\", \"foo\", \"bar\") plugin.Serve(\u0026plugin.ServeConfig{ HandshakeConfig: handshakeConfig, Plugins: pluginMap, }) Notice two things that we need. One is the handshakeConfig. You can either define it here, with the same cookie details as you defined in the client code, or you can extract the handshake information into the SDK. This is up to you.\nThen the next interesting thing is the plugin.Serve method. This is where the magic happens. The plugins open up a RPC communication socket and over a hijacked stdout, broadcasts its availability to the calling Client in this format:\nCORE-PROTOCOL-VERSION | APP-PROTOCOL-VERSION | NETWORK-TYPE | NETWORK-ADDR | PROTOCOL For Go plugins, you don’t have to concern yourself with this. go-plugin takes care of all this for you. For non-Go versions, we must take this into account. And before calling serve, we need to output this information to stdout.\nFor example, a Python plugin must deal with this himself. Like this:\n# Output information print(\"1|1|tcp|127.0.0.1:1234|grpc\") sys.stdout.flush() For GRPC plugins, it’s also mandatory to implement a HealthChecker.\nHow would all this look like with GRPC?\nIt gets slightly more complicated but not too much. We need to use protoc to create a protocol description for our implementation, and then we will call that. Let’s look at this now by converting the basic greeter example into GRPC.\nGRPC Basic plugin The example that’s under GRPC is quite elaborate and perhaps you don’t need the Python part. I will focus on the basic RPC example into a GRPC example. That should not be a problem.\nThe API First and foremost, you will need to define an API to implement with protoc. For our basic example, the protoc file could look like this:\nsyntax = \"proto3\"; package proto; message GreetResponse { string message = 1; } message Empty {} service GreeterService { rpc Greet(Empty) returns (GreetResponse); } The syntax is quite simple and readable. What this defines is a message, which is a response, that will contain a message with the type string. The service defines a service which has a method called Greet. The service definition is basically an interface for which we will be providing the concrete implementation through the plugin.\nTo read more about protoc, visit this page: Google Protocol Buffer.\nGenerate the code Now, with the protoc definition in hand, we need to generate the stubs that the local client implementation can call. That client call will then, through the remote procedure call, call the right function on the server which will have the concrete implementation at the ready. Run it and return the result in the specified format. Because the stub needs to be available by both parties, (the client AND the server), this needs to live in a shared location.\nWhy? Because the client is calling the stub and the server is implementing the stub. Both need it in order to know what to call/implement.\nTo generate the code, run this command:\nprotoc -I proto/ proto/greeter.proto --go_out=plugins=grpc:proto I encourage you to read the generated code. Much will make little sense at first. It will have a bunch of structs and defined things that the GRPC package will use in order to server the function. The interesting bits and pieces are:\nfunc (m *GreetResponse) GetMessage() string { if m != nil { return m.Message } return \"\" } Which will get use the message inside the response.\ntype GreeterServiceClient interface { Greet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GreetResponse, error) } This is our ServiceClient interface which defines the Greet function’s topology.\nAnd lastly, this guy:\nfunc RegisterGreeterServiceServer(s *grpc.Server, srv GreeterServiceServer) { s.RegisterService(\u0026_GreeterService_serviceDesc, srv) } Which we will need in order to register our implementation for the server. We can ignore the rest.\nThe interface Much like the RPC, we need to define an interface for the client and server to use. This must be in a shared place as both the server and the client need to know about it. You could put this into an SDK and your peers could just get the SDK and implement some function for define and done. The interface definition in the GRPC land could look something like this:\n// Greeter is the interface that we're exposing as a plugin. type Greeter interface { Greet() string } // This is the implementation of plugin.GRPCPlugin so we can serve/consume this. type GreeterGRPCPlugin struct { // GRPCPlugin must still implement the Plugin interface plugin.Plugin // Concrete implementation, written in Go. This is only used for plugins // that are written in Go. Impl Greeter } func (p *GreeterGRPCPlugin) GRPCServer(broker *plugin.GRPCBroker, s *grpc.Server) error { proto.RegisterGreeterServer(s, \u0026GRPCServer{Impl: p.Impl}) return nil } func (p *GreeterGRPCPlugin) GRPCClient(ctx context.Context, broker *plugin.GRPCBroker, c *grpc.ClientConn) (interface{}, error) { return \u0026GRPCClient{client: proto.NewGreeterClient(c)}, nil } With this we have the Plugin’s implementation for hashicorp what needed to be done. The plugin will call the underlying implementation and serve/consume the plugin. We can now write the GRPC part of it.\nPlease note that proto is a shared library too where the protocol stubs reside. That needs to be somewhere on the path or in a separate SDK of some sort, but it must be visible.\nWriting the GRPC Client Firstly we define the grpc client struct:\n// GRPCClient is an implementation of Greeter that talks over RPC. type GRPCClient struct{ client proto.GreeterClient } Then we define how the client will call the remote function:\nfunc (m *GRPCClient) Greet() string { ret, _ := m.client.Greet(context.Background(), \u0026proto.Empty{}) return ret.Message } This will take the client in the GRPCClient and will call the method on it. Once that’s done we will return to the result Message property which will be Hello!. proto.Empty is an empty struct; we use this if there is no parameter for a defined method or no return value. We can’t just leave it blank. protoc needs to be told explicitly that there is no parameter or return value.\nWriting the GRPC Server The server implementation will also be similar. We call Impl here which will have our concrete plugin implementation.\n// Here is the gRPC server that GRPCClient talks to. type GRPCServer struct { // This is the real implementation Impl Greeter } func (m *GRPCServer) Greet( ctx context.Context, req *proto.Empty) *proto.GreeterResponse { v := m.Impl.Greet() return \u0026proto.GreeterResponse{Message: v} } And we will use the protoc defined message response. v will have the response from Greet which will be Hello! provided by the concrete plugin’s implementation. We then transform that into a protoc type by setting the Message property on the GreeterResponse struct provided by the automatically generated protoc stub code.\nEasy, right?\nWriting the plugin itself The whole thing looks much like the RPC implementation with just a few small modifications and changes. This can sit completely outside of everything, or can even be provided by a third party implementor.\n// Here is a real implementation of KV that writes to a local file with // the key name and the contents are the value of the key. type Greeter struct{} func (Greeter) Greet() error { return \"Hello!\" } func main() { plugin.Serve(\u0026plugin.ServeConfig{ HandshakeConfig: shared.Handshake, Plugins: map[string]plugin.Plugin{ \"greeter\": \u0026shared.GreeterGRPCPlugin{Impl: \u0026Greeter{}}, }, // A non-nil value here enables gRPC serving for this plugin... GRPCServer: plugin.DefaultGRPCServer, }) } Calling it all in the main Once all that is done, the main function looks the same as RPC’s main but with some small modifications.\n// We're a host. Start by launching the plugin process. client := plugin.NewClient(\u0026plugin.ClientConfig{ HandshakeConfig: shared.Handshake, Plugins: shared.PluginMap, Cmd: exec.Command(\"./plugin/greeter\"), AllowedProtocols: []plugin.Protocol{plugin.ProtocolGRPC}, }) The NewClient now defines AllowedProtocols to be ProtocolGRPC. The rest is the same as before calling Dispense and value hinting the plugin to the correct type then calling Greet().\nConclusion This is it. We made it! Now our plugin works over GRPC with a defined API by protoc. The plugin’s implementation can live where ever we want it to, but it needs some shared data. These are:\nThe generated code by protoc The defined plugin interface The GRPC Server and Client These need to be visible by both the Client and the Server. The Server here is the plugin. If you are planning on making people be able to extend your application with go-plugin, you should make these available as a separate SDK. So people won’t have to include your whole project just to implement an interface and use protoc. In fact, you could also extract the protoc definition into a separate repository so that your SDK can also pull it in.\nYou will have three repositories:\nYour application; The SDK providing the interface and the GRPC Server and Client implementation; The protoc definition file and generated skeleton ( for Go based plugins). Other languages will have to generate their own protoc code, and includ it into the plugin; like the Python implementation example located here: Go-plugin Python Example. Also, read this documentation carefully: non-go go-plugin. This document will also clarify what 1|1|tcp|127.0.0.1:1234|grpc means and will dissipate the confusion around how plugins work.\nLastly, if you would like to have an in-depth explanation about how go-plugin came to be, watch this video by Mitchell:\ngo-plugin explanation video.\nI must warn you though- it’s an hour long. But worth the watch!\nThat’s it. I hope this has helped to clear the confusion around how to use go-plugin.\nHappy plugging!\nGergely.\n",
  "wordCount" : "3575",
  "inLanguage": "en",
  "datePublished": "2018-10-29T07:01:00+01:00",
  "dateModified": "2018-10-29T07:01:00+01:00",
  "author":{
    "@type": "Person",
    "name": "hannibal"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://skarlso.github.io/2018/10/29/go-plugin-tutorial/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ramblings of a cloud engineer",
    "logo": {
      "@type": "ImageObject",
      "url": "https://skarlso.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://skarlso.github.io/" accesskey="h" title="Ramblings of a cloud engineer (Alt + H)">Ramblings of a cloud engineer</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://skarlso.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/search/" title="Search">
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://skarlso.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://skarlso.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Extensive tutorial on go-plugin.
    </h1>
    <div class="post-description">
      go-plugin tutorial
    </div>
    <div class="post-meta"><span title='2018-10-29 07:01:00 +0100 +0100'>October 29, 2018</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;hannibal

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#intro" aria-label="Intro">Intro</a></li>
                <li>
                    <a href="#basic-plugin" aria-label="Basic plugin">Basic plugin</a><ul>
                        
                <li>
                    <a href="#basic-concepts" aria-label="Basic concepts">Basic concepts</a><ul>
                        
                <li>
                    <a href="#server" aria-label="Server">Server</a></li>
                <li>
                    <a href="#client" aria-label="Client">Client</a></li></ul>
                </li>
                <li>
                    <a href="#implementation" aria-label="Implementation">Implementation</a><ul>
                        
                <li>
                    <a href="#the-main-function" aria-label="The main function">The main function</a><ul>
                        
                <li>
                    <a href="#logger" aria-label="Logger">Logger</a></li>
                <li>
                    <a href="#newclient" aria-label="NewClient">NewClient</a></li></ul>
                </li>
                <li>
                    <a href="#the-interface" aria-label="The Interface">The Interface</a></li>
                <li>
                    <a href="#the-implementation" aria-label="The Implementation">The Implementation</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#grpc-basic-plugin" aria-label="GRPC Basic plugin">GRPC Basic plugin</a><ul>
                        
                <li>
                    <a href="#the-api" aria-label="The API">The API</a></li>
                <li>
                    <a href="#generate-the-code" aria-label="Generate the code">Generate the code</a></li>
                <li>
                    <a href="#the-interface-1" aria-label="The interface">The interface</a></li>
                <li>
                    <a href="#writing-the-grpc-client" aria-label="Writing the GRPC Client">Writing the GRPC Client</a></li>
                <li>
                    <a href="#writing-the-grpc-server" aria-label="Writing the GRPC Server">Writing the GRPC Server</a></li>
                <li>
                    <a href="#writing-the-plugin-itself" aria-label="Writing the plugin itself">Writing the plugin itself</a></li>
                <li>
                    <a href="#calling-it-all-in-the-main" aria-label="Calling it all in the main">Calling it all in the main</a></li></ul>
                </li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="intro">Intro<a hidden class="anchor" aria-hidden="true" href="#intro">#</a></h1>
<p>If you don&rsquo;t know what go-plugin is, don&rsquo;t worry, here is a small introduction on the subject matter:</p>
<p>Back in the old days when Go didn&rsquo;t have the <code>plugin</code> package, HashiCorp was desperately looking for a way to use plugins.</p>
<p>In the old days, Lua plus Go wasn&rsquo;t really a thing yet, and to be honest, nobody wants to write Lua ( joking!).</p>
<p>And thus Mitchell had this brilliant idea of using RPC over the local network to serve a local interface as something that could easily be implemented with any other language that supported RPC. This sounds convoluted but has many benefits! For example, your code will never crash because of a plugin and the ability to use any language to implement a plugin. Not just Go.</p>
<p>It has been a battle-hardened solution for years now and is being actively used by Terraform, Vault, Consule, and especially Packer. All using go-plugin in order to provide a much needed flexibility. Writing a plugin is easy. Or so they say.</p>
<p>It can get complicated quickly, for example, if you are trying to use GRPC. You can lose sight of what exactly you&rsquo;ll need to implement, where and why; or utilizing various languages or using go-plugins in your own project and extending your CLI with pluggable components.</p>
<p>These are all nothing to sneeze at. Suddenly you&rsquo;ll find yourself with hundreds of lines of code pasted from various examples and yet nothing works. Or worse, it DOES work but you have no idea how. Then you find yourself needing to extend it with a new capability, or you find an elusive bug and can&rsquo;t trace its origins.</p>
<p>Fear not. I&rsquo;ll try to demystify things and draw a clear picture about how it works and how the pieces fit together.</p>
<p>Let&rsquo;s start at the beginning.</p>
<h1 id="basic-plugin">Basic plugin<a hidden class="anchor" aria-hidden="true" href="#basic-plugin">#</a></h1>
<p>Let&rsquo;s start by writing a simple Go GRPC plugin. In fact, we can go through the basic example in the go-plugin’s repository which can be quite confusing when first starting out. We&rsquo;ll go step-by-step, and the switch to GRPC will be much easier!</p>
<h2 id="basic-concepts">Basic concepts<a hidden class="anchor" aria-hidden="true" href="#basic-concepts">#</a></h2>
<h3 id="server">Server<a hidden class="anchor" aria-hidden="true" href="#server">#</a></h3>
<p>In the case of plugins, the Server is the one serving the plugin&rsquo;s implementation. This means the server will have to provide the implementation to an interface.</p>
<h3 id="client">Client<a hidden class="anchor" aria-hidden="true" href="#client">#</a></h3>
<p>The Client calls the server in order to execute the desired behaviour. The underlying logic will connect to the server running on localhost on a random higher port, call the wanted function’s implementation and wait for a response. Once the response is received provide that back to the calling Client.</p>
<h2 id="implementation">Implementation<a hidden class="anchor" aria-hidden="true" href="#implementation">#</a></h2>
<h3 id="the-main-function">The main function<a hidden class="anchor" aria-hidden="true" href="#the-main-function">#</a></h3>
<h4 id="logger">Logger<a hidden class="anchor" aria-hidden="true" href="#logger">#</a></h4>
<p>The plugins defined here use stdout in a special way. If you aren&rsquo;t writing a Go based plugin, you will have to do that yourself by outputting something like this:</p>
<pre tabindex="0"><code>1|1|tcp|127.0.0.1:1234|grpc
</code></pre><p>We&rsquo;ll come back to this later. Suffice to say the framework will pick this up and will connect to the plugin based on the output. In order to get some output back, we must define a special logger:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#75715e">// Create an hclog.Logger
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">logger</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">hclog</span>.<span style="color:#a6e22e">New</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">hclog</span>.<span style="color:#a6e22e">LoggerOptions</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Name</span>:   <span style="color:#e6db74">&#34;plugin&#34;</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Output</span>: <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdout</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Level</span>:  <span style="color:#a6e22e">hclog</span>.<span style="color:#a6e22e">Debug</span>,
</span></span><span style="display:flex;"><span>	})
</span></span></code></pre></div><h4 id="newclient">NewClient<a hidden class="anchor" aria-hidden="true" href="#newclient">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#75715e">// We&#39;re a host! Start by launching the plugin process.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">client</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">NewClient</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">ClientConfig</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">HandshakeConfig</span>: <span style="color:#a6e22e">handshakeConfig</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Plugins</span>:         <span style="color:#a6e22e">pluginMap</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Cmd</span>:             <span style="color:#a6e22e">exec</span>.<span style="color:#a6e22e">Command</span>(<span style="color:#e6db74">&#34;./plugin/greeter&#34;</span>),
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Logger</span>:          <span style="color:#a6e22e">logger</span>,
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">Kill</span>()
</span></span></code></pre></div><p>What is happening here? Let&rsquo;s see one by one:</p>
<p><code>HandshakeConfig: handshakeConfig,</code>: This part is the handshake configuration of the plugin. It has a nice comment as well.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// handshakeConfigs are used to just do a basic handshake between
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// a plugin and host. If the handshake fails, a user friendly error is shown.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// This prevents users from executing bad plugins or executing a plugin
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// directory. It is a UX feature, not a security feature.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">handshakeConfig</span> = <span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">HandshakeConfig</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ProtocolVersion</span>:  <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">MagicCookieKey</span>:   <span style="color:#e6db74">&#34;BASIC_PLUGIN&#34;</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">MagicCookieValue</span>: <span style="color:#e6db74">&#34;hello&#34;</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>ProtocolVersion</code> here is used in order to maintain compatibility with your current plugin versions. It&rsquo;s basically like an API version. If you increase this, you will have two options. Don&rsquo;t accept lower protocol versions nor switch to the version number and use a different client implementation for a lower version than for a higher version. This way you will maintain backwards compatibility.</p>
<p>The <code>MagicCookieKey</code> and <code>MagicCookieValue</code> are used for a basic handshake which the comment is talking about. You have to set this <strong>ONCE</strong> for your application. Never change it again, for if you do, your plugins will no longer work. For uniqueness sake, I suggest using UUID.</p>
<p><code>Cmd</code> is one of the most important parts about a plugin. Basically how plugins work is that they boil down to a compiled binary which is executed and starts an RPC server. This is where you will have to define the binary which will be executed and does all this. Since this is all happening locally, (please keep in mind that Go-plugins only support localhost, and for a good reason), these binaries will most likely sit next to your application&rsquo;s binary or in a pre-configured global location. Something like:  <code>~/.config/my-app/plugins</code>. This is individual for each plugin of course. The plugins can be autoloaded via a discovery function given a path and a glob.</p>
<p>And last but not least is the <code>Plugins</code> map. This map is used in order to identify a plugin called <code>Dispense</code>. This map is globally available and must stay consistent in order for all the plugins to work:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// pluginMap is the map of plugins we can dispense.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">pluginMap</span> = <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">Pluglin</span>	<span style="color:#e6db74">&#34;greeter&#34;</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">example</span>.<span style="color:#a6e22e">GreeterPlugin</span>{},
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You can see that the key is the name of the plugin and the value is the plugin.</p>
<p>We then proceed to create an RPC client:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#75715e">// Connect via RPC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rpcClient</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">Client</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>Nothing fancy about this one&hellip;</p>
<p>Now comes the interesting part:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#75715e">// Request the plugin
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">raw</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rpcClient</span>.<span style="color:#a6e22e">Dispense</span>(<span style="color:#e6db74">&#34;greeter&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>What&rsquo;s happening here? Dispense will look in the above created map and search for the plugin. If it cannot find it, it will throw an error at us. If it does find it, it will cast this plugin to an RPC or a GRPC type plugin. Then proceed to create an RPC or a GRPC client out of it.</p>
<p>There is no call yet. This is just creating a client and parsing it to a respective representation.</p>
<p>Now comes the magic:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#75715e">// We should have a Greeter now! This feels like a normal interface
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// implementation but is in fact over an RPC connection.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">greeter</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">raw</span>.(<span style="color:#a6e22e">example</span>.<span style="color:#a6e22e">Greeter</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">greeter</span>.<span style="color:#a6e22e">Greet</span>())
</span></span></code></pre></div><p>Here we are type asserting our raw GRPC client into our own plugin type. This is so we can call the respective function on the plugin! Once that&rsquo;s done we will have a {client,struct,implementation} that can be called like a simple function.</p>
<p>The implementation right now comes from greeter_impl.go, but that will change once protoc makes an appearance.</p>
<p>Behind the scenes, go-plugin will do a bunch of hat tricks with multiplexing TCP connections as well as a remote procedure call to our plugin. Our plugin then will run the function, generate some kind of output, and will then send that back for the waiting client.</p>
<p>The client will then proceed to parse the message into a given response type and will then return it back to the client’s callee.</p>
<p>This concludes main.go for now.</p>
<h3 id="the-interface">The Interface<a hidden class="anchor" aria-hidden="true" href="#the-interface">#</a></h3>
<p>Now let’s investigate the Interface. The interface is used to provide calling details. This interface will be what defines our plugins’ capabilities. How does our <code>Greeter</code> look like?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Greeter is the interface that we&#39;re exposing as a plugin.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Greeter</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Greet</span>() <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is pretty simple. It defines a function which will return a string typed value.</p>
<p>Now, we will need a couple of things for this to work. Firstly we need something which defines the RPC workings. go-plugin is working with <code>net/http</code> inside. It also uses something called Yamux for connection multiplexing, but we needn’t worry about this detail.</p>
<p>Implementing the RPC details looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Here is an implementation that talks over RPC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">GreeterRPC</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">client</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">rpc</span>.<span style="color:#a6e22e">Client</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GreeterRPC</span>) <span style="color:#a6e22e">Greet</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">resp</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">Call</span>(<span style="color:#e6db74">&#34;Plugin.Greet&#34;</span>, new(<span style="color:#66d9ef">interface</span>{}), <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">resp</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// You usually want your interfaces to return errors. If they don&#39;t,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// there isn&#39;t much other choice here.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		panic(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">resp</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here the GreeterRPC struct is an RPC specific implementation that will handle communication over RPC. This is Client in this setup.</p>
<p>In case of gRPC, this would look something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// GRPCClient is an implementation of KV that talks over RPC.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">GreeterGRPC</span> <span style="color:#66d9ef">struct</span>{ <span style="color:#a6e22e">client</span> <span style="color:#a6e22e">proto</span>.<span style="color:#a6e22e">GreeterClient</span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GreeterGRPC</span>) <span style="color:#a6e22e">Greet</span>() (<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">Greet</span>(<span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>(), <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">proto</span>.<span style="color:#a6e22e">Empty</span>{})
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>What is happening here? What&rsquo;s Proto and what is GreeterClient? GRPC uses Google&rsquo;s protoc library to serialize and unserialize data. <code>proto.GreeterClient</code> is generated Go code by protoc. This code is a skeleton for which implementation detail will be replaced on run time. Well, the actual result will be used and not replaced as such.</p>
<p>Back to our previous example. The RPC client calls a specific Plugin function called Greet for which the implementation will be provided by a Server that will be streamed back over the RPC protocol.</p>
<p>The server is pretty easy to follow:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Here is the RPC server that GreeterRPC talks to, conforming to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// the requirements of net/rpc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">GreeterRPCServer</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// This is the real implementation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Impl</span> <span style="color:#a6e22e">Greeter</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Impl is the concrete implementation that will be called in the Server&rsquo;s implementation of the Greet plugin. Now we must define Greet on the RPCServer in order for it to be able to call the remote code. This looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GreeterRPCServer</span>) <span style="color:#a6e22e">Greet</span>(<span style="color:#a6e22e">args</span> <span style="color:#66d9ef">interface</span>{}, <span style="color:#a6e22e">resp</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span><span style="color:#a6e22e">resp</span> = <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Impl</span>.<span style="color:#a6e22e">Greet</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is all still boilerplate for the RPC works. Now comes plugin. For this, the comment is actually quite good too:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// This is the implementation of plugin.Plugin so we can serve/consume this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// This has two methods: Server must return an RPC server for this plugin
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// type. We construct a GreeterRPCServer for this.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Client must return an implementation of our interface that communicates
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// over an RPC client. We return GreeterRPC for this.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Ignore MuxBroker. That is used to create more multiplexed streams on our
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// plugin connection and is a more advanced use case.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">GreeterPlugin</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Impl Injection
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Impl</span> <span style="color:#a6e22e">Greeter</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GreeterPlugin</span>) <span style="color:#a6e22e">Server</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">MuxBroker</span>) (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">GreeterRPCServer</span>{<span style="color:#a6e22e">Impl</span>: <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Impl</span>}, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">GreeterPlugin</span>) <span style="color:#a6e22e">Client</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">MuxBroker</span>, <span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">rpc</span>.<span style="color:#a6e22e">Client</span>) (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">GreeterRPC</span>{<span style="color:#a6e22e">client</span>: <span style="color:#a6e22e">c</span>}, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>What does this mean? So, remember: <code>GreeterRPCServer</code> is the one calling the actual implementation while Client is receiving the result of that call. The <code>GreeterPlugin</code> has the <code>Greeter</code> interface embedded just like the <code>RPCServer</code>. We will use the <code>GreeterPlugin</code> as a struct in the plugin map. This is the plugin that we will actually use.</p>
<p>This is all still common stuff. These things will need to be visible for both. The plugin&rsquo;s implementation will use the interface to see what it needs to implement. The Client will use it see what to call and what API is available. Like, <code>Greet</code>.</p>
<p>How does the implementation look like?</p>
<h3 id="the-implementation">The Implementation<a hidden class="anchor" aria-hidden="true" href="#the-implementation">#</a></h3>
<p>In a completely separate package, but which still has access to the interface definition, this plugin could be something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Here is a real implementation of Greeter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">GreeterHello</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">logger</span> <span style="color:#a6e22e">hclog</span>.<span style="color:#a6e22e">Logger</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GreeterHello</span>) <span style="color:#a6e22e">Greet</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">logger</span>.<span style="color:#a6e22e">Debug</span>(<span style="color:#e6db74">&#34;message from GreeterHello.Greet&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Hello!&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We create a struct and then add the function to it which is defined by the plugin&rsquo;s interface. This interface, since it&rsquo;s required by both parties, could well sit in a common package outside of both programs. Something like a SDK. Both code could import it and use it as a common dependency. This way we have separated the interface from the plugin <strong>and</strong> the calling client.</p>
<p>The <code>main</code> function could look something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">logger</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">hclog</span>.<span style="color:#a6e22e">New</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">hclog</span>.<span style="color:#a6e22e">LoggerOptions</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Level</span>:      <span style="color:#a6e22e">hclog</span>.<span style="color:#a6e22e">Trace</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Output</span>:     <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stderr</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">JSONFormat</span>: <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">greeter</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">GreeterHello</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">logger</span>: <span style="color:#a6e22e">logger</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// pluginMap is the map of plugins we can dispense.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">pluginMap</span> = <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">Plugin</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;greeter&#34;</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">example</span>.<span style="color:#a6e22e">GreeterPlugin</span>{<span style="color:#a6e22e">Impl</span>: <span style="color:#a6e22e">greeter</span>},
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">logger</span>.<span style="color:#a6e22e">Debug</span>(<span style="color:#e6db74">&#34;message from plugin&#34;</span>, <span style="color:#e6db74">&#34;foo&#34;</span>, <span style="color:#e6db74">&#34;bar&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">Serve</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">ServeConfig</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">HandshakeConfig</span>: <span style="color:#a6e22e">handshakeConfig</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Plugins</span>:         <span style="color:#a6e22e">pluginMap</span>,
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><p>Notice two things that we need. One is the <code>handshakeConfig</code>. You can either define it here, with the same cookie details as you defined in the client code, or you can extract the handshake information into the SDK. This is up to you.</p>
<p>Then the next interesting thing is the <code>plugin.Serve</code> method. This is where the magic happens. The plugins open up a RPC communication socket and over a hijacked <code>stdout</code>, broadcasts its availability to the calling Client in this format:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>CORE-PROTOCOL-VERSION | APP-PROTOCOL-VERSION | NETWORK-TYPE | NETWORK-ADDR | PROTOCOL
</span></span></code></pre></div><p>For Go plugins, you don&rsquo;t have to concern yourself with this. <code>go-plugin</code> takes care of all this for you. For non-Go versions, we must take this into account. And before calling serve, we need to output this information to <code>stdout</code>.</p>
<p>For example, a Python plugin must deal with this himself. Like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Output information</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;1|1|tcp|127.0.0.1:1234|grpc&#34;</span>)
</span></span><span style="display:flex;"><span>sys<span style="color:#f92672">.</span>stdout<span style="color:#f92672">.</span>flush()
</span></span></code></pre></div><p>For GRPC plugins, it&rsquo;s also mandatory to implement a HealthChecker.</p>
<p>How would all this look like with GRPC?</p>
<p>It gets slightly more complicated but not too much. We need to use <code>protoc</code> to create a protocol description for our implementation, and then we will call that. Let&rsquo;s look at this now by converting the basic greeter example into GRPC.</p>
<h1 id="grpc-basic-plugin">GRPC Basic plugin<a hidden class="anchor" aria-hidden="true" href="#grpc-basic-plugin">#</a></h1>
<p>The example that&rsquo;s under GRPC is quite elaborate and perhaps you don&rsquo;t need the Python part. I will focus on the basic RPC example into a GRPC example. That should not be a problem.</p>
<h2 id="the-api">The API<a hidden class="anchor" aria-hidden="true" href="#the-api">#</a></h2>
<p>First and foremost, you will need to define an API to implement with <code>protoc</code>. For our basic example, the protoc file could look like this:</p>
<pre tabindex="0"><code class="language-proto3" data-lang="proto3">syntax = &#34;proto3&#34;;
package proto;

message GreetResponse {
    string message = 1;
}

message Empty {}

service GreeterService {
    rpc Greet(Empty) returns (GreetResponse);
}
</code></pre><p>The syntax is quite simple and readable. What this defines is a message, which is a response, that will contain a <code>message</code> with the type <code>string</code>. The <code>service</code> defines a service which has a method called <code>Greet</code>. The service definition is basically an interface for which we will be providing the concrete implementation through the plugin.</p>
<p>To read more about protoc, visit this page: <a href="https://developers.google.com/protocol-buffers/">Google Protocol Buffer</a>.</p>
<h2 id="generate-the-code">Generate the code<a hidden class="anchor" aria-hidden="true" href="#generate-the-code">#</a></h2>
<p>Now, with the protoc definition in hand, we need to generate the stubs that the local client implementation can call. That client call will then, through the remote procedure call, call the right function on the server which will have the concrete implementation at the ready. Run it and return the result in the specified format. Because the stub needs to be available by both parties, (the client AND the server), this needs to live in a shared location.</p>
<p>Why? Because the client is calling the stub and the server is implementing the stub. Both need it in order to know what to call/implement.</p>
<p>To generate the code, run this command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>protoc -I proto/ proto/greeter.proto --go_out<span style="color:#f92672">=</span>plugins<span style="color:#f92672">=</span>grpc:proto
</span></span></code></pre></div><p>I encourage you to read the generated code. Much will make little sense at first. It will have a bunch of structs and defined things that the GRPC package will use in order to server the function. The interesting bits and pieces are:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GreetResponse</span>) <span style="color:#a6e22e">GetMessage</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">m</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Message</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Which will get use the message inside the response.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">GreeterServiceClient</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Greet</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">in</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Empty</span>, <span style="color:#a6e22e">opts</span> <span style="color:#f92672">...</span><span style="color:#a6e22e">grpc</span>.<span style="color:#a6e22e">CallOption</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">GreetResponse</span>, <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is our ServiceClient interface which defines the Greet function’s topology.</p>
<p>And lastly, this guy:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">RegisterGreeterServiceServer</span>(<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">grpc</span>.<span style="color:#a6e22e">Server</span>, <span style="color:#a6e22e">srv</span> <span style="color:#a6e22e">GreeterServiceServer</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">RegisterService</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">_GreeterService_serviceDesc</span>, <span style="color:#a6e22e">srv</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Which we will need in order to register our implementation for the server. We can ignore the rest.</p>
<h2 id="the-interface-1">The interface<a hidden class="anchor" aria-hidden="true" href="#the-interface-1">#</a></h2>
<p>Much like the RPC, we need to define an interface for the client and server to use. This must be in a shared place as both the server and the client need to know about it. You could put this into an SDK and your peers could just get the SDK and implement some function for define and done. The interface definition in the GRPC land could look something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Greeter is the interface that we&#39;re exposing as a plugin.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Greeter</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Greet</span>() <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// This is the implementation of plugin.GRPCPlugin so we can serve/consume this.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">GreeterGRPCPlugin</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// GRPCPlugin must still implement the Plugin interface
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">Plugin</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Concrete implementation, written in Go. This is only used for plugins
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// that are written in Go.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Impl</span> <span style="color:#a6e22e">Greeter</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GreeterGRPCPlugin</span>) <span style="color:#a6e22e">GRPCServer</span>(<span style="color:#a6e22e">broker</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">GRPCBroker</span>, <span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">grpc</span>.<span style="color:#a6e22e">Server</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">proto</span>.<span style="color:#a6e22e">RegisterGreeterServer</span>(<span style="color:#a6e22e">s</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">GRPCServer</span>{<span style="color:#a6e22e">Impl</span>: <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Impl</span>})
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GreeterGRPCPlugin</span>) <span style="color:#a6e22e">GRPCClient</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">broker</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">GRPCBroker</span>, <span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">grpc</span>.<span style="color:#a6e22e">ClientConn</span>) (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">GRPCClient</span>{<span style="color:#a6e22e">client</span>: <span style="color:#a6e22e">proto</span>.<span style="color:#a6e22e">NewGreeterClient</span>(<span style="color:#a6e22e">c</span>)}, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>With this we have the Plugin&rsquo;s implementation for hashicorp what needed to be done. The plugin will call the underlying implementation and serve/consume the plugin. We can now write the GRPC part of it.</p>
<p>Please note that <code>proto</code> is a shared library too where the protocol stubs reside. That needs to be somewhere on the path or in a separate SDK of some sort, but it must be visible.</p>
<h2 id="writing-the-grpc-client">Writing the GRPC Client<a hidden class="anchor" aria-hidden="true" href="#writing-the-grpc-client">#</a></h2>
<p>Firstly we define the grpc client struct:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// GRPCClient is an implementation of Greeter that talks over RPC.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">GRPCClient</span> <span style="color:#66d9ef">struct</span>{ <span style="color:#a6e22e">client</span> <span style="color:#a6e22e">proto</span>.<span style="color:#a6e22e">GreeterClient</span> }
</span></span></code></pre></div><p>Then we define how the client will call the remote function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GRPCClient</span>) <span style="color:#a6e22e">Greet</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ret</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">Greet</span>(<span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>(), <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">proto</span>.<span style="color:#a6e22e">Empty</span>{})
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ret</span>.<span style="color:#a6e22e">Message</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This will take the <code>client</code> in the <code>GRPCClient</code> and will call the method on it. Once that&rsquo;s done we will return to the result <code>Message</code> property which will be <code>Hello!</code>. <code>proto.Empty</code> is an empty struct; we use this if there is no parameter for a defined method or no return value. We can&rsquo;t just leave it blank. <code>protoc</code> needs to be told explicitly that there is no parameter or return value.</p>
<h2 id="writing-the-grpc-server">Writing the GRPC Server<a hidden class="anchor" aria-hidden="true" href="#writing-the-grpc-server">#</a></h2>
<p>The server implementation will also be similar. We call <code>Impl</code> here which will have our concrete plugin implementation.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Here is the gRPC server that GRPCClient talks to.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">GRPCServer</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// This is the real implementation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Impl</span> <span style="color:#a6e22e">Greeter</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GRPCServer</span>) <span style="color:#a6e22e">Greet</span>(
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">req</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">proto</span>.<span style="color:#a6e22e">Empty</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">proto</span>.<span style="color:#a6e22e">GreeterResponse</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Impl</span>.<span style="color:#a6e22e">Greet</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">proto</span>.<span style="color:#a6e22e">GreeterResponse</span>{<span style="color:#a6e22e">Message</span>: <span style="color:#a6e22e">v</span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And we will use the <code>protoc</code> defined message response. <code>v</code> will have the response from <code>Greet</code> which will be <code>Hello!</code> provided by the concrete plugin&rsquo;s implementation. We then transform that into a protoc type by setting the <code>Message</code> property on the <code>GreeterResponse</code> struct provided by the automatically generated protoc stub code.</p>
<p>Easy, right?</p>
<h2 id="writing-the-plugin-itself">Writing the plugin itself<a hidden class="anchor" aria-hidden="true" href="#writing-the-plugin-itself">#</a></h2>
<p>The whole thing looks much like the RPC implementation with just a few small modifications and changes. This can sit completely outside of everything, or can even be provided by a third party implementor.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Here is a real implementation of KV that writes to a local file with
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// the key name and the contents are the value of the key.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Greeter</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">Greeter</span>) <span style="color:#a6e22e">Greet</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Hello!&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">Serve</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">ServeConfig</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">HandshakeConfig</span>: <span style="color:#a6e22e">shared</span>.<span style="color:#a6e22e">Handshake</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Plugins</span>: <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">Plugin</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#e6db74">&#34;greeter&#34;</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">shared</span>.<span style="color:#a6e22e">GreeterGRPCPlugin</span>{<span style="color:#a6e22e">Impl</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Greeter</span>{}},
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// A non-nil value here enables gRPC serving for this plugin...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">GRPCServer</span>: <span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">DefaultGRPCServer</span>,
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="calling-it-all-in-the-main">Calling it all in the main<a hidden class="anchor" aria-hidden="true" href="#calling-it-all-in-the-main">#</a></h2>
<p>Once all that is done, the <code>main</code> function looks the same as RPC&rsquo;s main but with some small modifications.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#75715e">// We&#39;re a host. Start by launching the plugin process.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">client</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">NewClient</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">ClientConfig</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">HandshakeConfig</span>: <span style="color:#a6e22e">shared</span>.<span style="color:#a6e22e">Handshake</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Plugins</span>:         <span style="color:#a6e22e">shared</span>.<span style="color:#a6e22e">PluginMap</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Cmd</span>:             <span style="color:#a6e22e">exec</span>.<span style="color:#a6e22e">Command</span>(<span style="color:#e6db74">&#34;./plugin/greeter&#34;</span>),
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">AllowedProtocols</span>: []<span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">Protocol</span>{<span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">ProtocolGRPC</span>},
</span></span><span style="display:flex;"><span>	})
</span></span></code></pre></div><p>The <code>NewClient</code> now defines <code>AllowedProtocols</code> to be <code>ProtocolGRPC</code>. The rest is the same as before calling <code>Dispense</code> and value hinting the plugin to the correct type then calling <code>Greet()</code>.</p>
<h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>This is it. We made it! Now our plugin works over GRPC with a defined API by protoc. The plugin&rsquo;s implementation can live where ever we want it to, but it needs some shared data. These are:</p>
<ul>
<li>The generated code by <code>protoc</code></li>
<li>The defined plugin interface</li>
<li>The GRPC Server and Client</li>
</ul>
<p>These need to be visible by both the Client and the Server. The Server here is the plugin. If you are planning on making people be able to extend your application with go-plugin, you should make these available as a separate SDK. So people won&rsquo;t have to include your whole project just to implement an interface and use protoc. In fact, you could also extract the <code>protoc</code> definition into a separate repository so that your SDK can also pull it in.</p>
<p>You will have three repositories:</p>
<ul>
<li>Your application;</li>
<li>The SDK providing the interface and the GRPC Server and Client implementation;</li>
<li>The protoc definition file and generated skeleton ( for Go based plugins).</li>
</ul>
<p>Other languages will have to generate their own protoc code, and includ it into the plugin; like the Python implementation example located here: <a href="https://github.com/hashicorp/go-plugin/tree/master/examples/grpc/plugin-python">Go-plugin Python Example</a>. Also, read this documentation carefully: <a href="https://github.com/hashicorp/go-plugin/blob/master/docs/guide-plugin-write-non-go.md">non-go go-plugin</a>. This document will also clarify what <code>1|1|tcp|127.0.0.1:1234|grpc</code> means and will dissipate the confusion around how plugins work.</p>
<p>Lastly, if you would like to have an in-depth explanation about how go-plugin came to be, watch this video by Mitchell:</p>
<p><a href="https://www.youtube.com/watch?v=SRvm3zQQc1Q">go-plugin explanation video</a>.</p>
<p>I must warn you though- it&rsquo;s an hour long. But worth the watch!</p>
<p>That&rsquo;s it. I hope this has helped to clear the confusion around how to use go-plugin.</p>
<p>Happy plugging!</p>
<p>Gergely.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://skarlso.github.io/2019/02/17/go-ssh-with-host-key-verification/">
    <span class="title">« Prev</span>
    <br>
    <span>Go SSH with Host Key Verification</span>
  </a>
  <a class="next" href="https://skarlso.github.io/2018/09/17/furnace-plugin-update/">
    <span class="title">Next »</span>
    <br>
    <span>Furnace with a new Plugin System</span>
  </a>
</nav>

  </footer><div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hannibalDisqus" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://skarlso.github.io/">Ramblings of a cloud engineer</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
