<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>vagrant on Ramblings of a cloud engineer</title>
    <link>https://skarlso.github.io/tags/vagrant/</link>
    <description>Recent content in vagrant on Ramblings of a cloud engineer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-GB</language>
    <lastBuildDate>Wed, 22 Jul 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://skarlso.github.io/tags/vagrant/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Quick Tip for Debugging Headless Locally</title>
      <link>https://skarlso.github.io/2015/07/22/quick-tip-for-debugging-headless-locally/</link>
      <pubDate>Wed, 22 Jul 2015 00:00:00 +0000</pubDate>
      <guid>https://skarlso.github.io/2015/07/22/quick-tip-for-debugging-headless-locally/</guid>
      <description>&lt;p&gt;If you are installing something with Packer and you have Headless enabled(and you are lazy and don‚Äôt want to switch it off), it gets difficult, to see output.&lt;/p&gt;
&lt;p&gt;Especially on a windows install the Answer File / Unattended install can be like =&amp;gt; Waiting for SSH‚Ä¶ for about an hour or two! If you are doing this locally fret not. Just start VirtualBox, and watch the Preview section which will display the current state even if it‚Äôs a headless install!&lt;/p&gt;
&lt;p&gt;It‚Äôs a small windows, but your can click on &lt;strong&gt;Show&lt;/strong&gt; which will open the VM in a proper view.&lt;/p&gt;
&lt;p&gt;Enjoy,
Gergely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Selenium Testing with Packer and Vagrant</title>
      <link>https://skarlso.github.io/2015/07/16/selenium-testing-with-packer-and-vagrant/</link>
      <pubDate>Thu, 16 Jul 2015 00:00:00 +0000</pubDate>
      <guid>https://skarlso.github.io/2015/07/16/selenium-testing-with-packer-and-vagrant/</guid>
      <description>&lt;p&gt;So, recently, the tester team talked to me, that their build takes too long, and why is that? A quick look at their configuration and build scripts showed me, that they are actually using a vagrant box, which never gets destroyed or re-started at least. To remedy this problem, I came up with the following solution‚Ä¶&lt;/p&gt;
&lt;h1 id=&#34;same-old8230&#34;&gt;Same old‚Ä¶&lt;/h1&gt;
&lt;p&gt;Same as in my previous post, we are going to build a Windows Machine for this purpose. The only addition to my previous settings, will be some Java install, downloading selenium and installing Chrome, and Firefox.&lt;/p&gt;
&lt;h1 id=&#34;installation&#34;&gt;Installation&lt;/h1&gt;
&lt;h4 id=&#34;answer-file&#34;&gt;Answer File&lt;/h4&gt;
&lt;p&gt;Here is the configuration and setup of Windows before the provision phase.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;This is the part were I‚Äôm installing Java. The script for the jdk_inst.ps1 is in my previous post, but I‚Äôll paste it here for ease of read.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;This installs both x86 and 64 bit version of Java.&lt;/p&gt;
&lt;h1 id=&#34;provision&#34;&gt;Provision&lt;/h1&gt;
&lt;p&gt;I decided to put these into the provision phase to get log messages written out properly. Because in the unattended file, you can‚Äôt see any progress.&lt;/p&gt;
&lt;h4 id=&#34;chrome-and-firefox&#34;&gt;Chrome And Firefox&lt;/h4&gt;
&lt;p&gt;Installing these two proved a little bit more difficult. Chrome didn‚Äôt really like me to download their installer without accepting something first, like Java. Luckily, after a LOT of digging, I found a chrome installer which lets you install silently. Here is the script to install the two.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;They both install silently. Pretty neat.&lt;/p&gt;
&lt;h4 id=&#34;selenium&#34;&gt;Selenium&lt;/h4&gt;
&lt;p&gt;This only has to be downloaded, so this is pretty simple. Vagrant will handle the startup of course when it does a vagrant up.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Straightforward.&lt;/p&gt;
&lt;h4 id=&#34;the-packer-json-file&#34;&gt;The Packer Json File&lt;/h4&gt;
&lt;p&gt;So putting this all together, here is the Packer JSON file for this:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;additional-software&#34;&gt;Additional Software&lt;/h4&gt;
&lt;p&gt;This is not done here. Obviously, in order to test your stuff, you first need to install your software on this box. Ideally, everything you need should be in the code you clone to this box, and should be contained mostly. And your application deployment should take core of that. But, if you require something like a DB, postgres, oracle, whatnot, than this is the place where you would install all that.&lt;/p&gt;
&lt;h1 id=&#34;vagrant-and-using-the-packer-box&#34;&gt;Vagrant and Using the Packer Box&lt;/h1&gt;
&lt;p&gt;Now, this has been interesting so far, but how do you actually go about using this image? That‚Äôs the real question now, isn‚Äôt it? Having a box, just sitting on a shared folder, doesn‚Äôt do you too much good. So let‚Äôs create a Jenkins job, which utilizes this box in a job which runs a bunch of tests for some application.&lt;/p&gt;
&lt;h4 id=&#34;vagrantfile&#34;&gt;Vagrantfile&lt;/h4&gt;
&lt;p&gt;Your vagrant file, could either be generated automatically, under source control ( which is preferred ) or sitting somewhere entirely elsewhere. In any case, it would look something like this.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Easy, no? Here is the script to start selenium.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Straight forward. We also are forwarding the port on which Selenium is running in order for the test to see it.&lt;/p&gt;
&lt;h4 id=&#34;the-jenkins-job&#34;&gt;The Jenkins Job&lt;/h4&gt;
&lt;p&gt;The job can be anything. This is actually too large to cover here. It could be a gradle job, a maven job, an ant, a nant ‚Äì or whatever is running the test -, job; it‚Äôs up to you.&lt;/p&gt;
&lt;p&gt;Just make sure that before the test runs, do a &lt;strong&gt;vagrant up&lt;/strong&gt; and after the test finishes, in an ALWAYS TO BE EXECUTED HOOK -like gradle‚Äôs finalizedBy , call a &lt;strong&gt;vagrant destroy&lt;/strong&gt;. This way, your test will always run on a clean instance that has the necessary stuff on it.&lt;/p&gt;
&lt;h1 id=&#34;closing-words&#34;&gt;Closing words&lt;/h1&gt;
&lt;p&gt;So, there you have it. It‚Äôs relatively simple. Tying this all into your infrastructure might prove difficult though depending on how rigid your deployment is. But it will always help you make your tests a bit more robust.&lt;/p&gt;
&lt;p&gt;Also, you could run the whole deployment and test phase on a vagrant box, from the start, which is tied to jenkins as a slave and gets started when the job starts and destroyed when the job ends. That way you wouldn‚Äôt have to create a, box in a box running on a box, kind of effect.&lt;/p&gt;
&lt;p&gt;Thanks for reading,&lt;/p&gt;
&lt;p&gt;Gergely.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>The Packer, The Windows, and the Vagrant box</title>
      <link>https://skarlso.github.io/2015/06/27/the-packer-the-windows-and-the-vagrant-box/</link>
      <pubDate>Sat, 27 Jun 2015 00:00:00 +0000</pubDate>
      <guid>https://skarlso.github.io/2015/06/27/the-packer-the-windows-and-the-vagrant-box/</guid>
      <description>&lt;p&gt;Hello folks.&lt;/p&gt;
&lt;p&gt;Today, I would like to write about something close to my heart recently. I‚Äôve been fiddling with Packer, Windows and Vagrant these days. Trying to get a Windows box up in running is a pain in the arse though, so I thought I share my pain with you nice folks out there. Let‚Äôs begin.&lt;/p&gt;
&lt;h1 id=&#34;setup&#34;&gt;Setup&lt;/h1&gt;
&lt;p&gt;First things first. You need &lt;!-- raw HTML omitted --&gt;Packer&lt;!-- raw HTML omitted --&gt;, and &lt;!-- raw HTML omitted --&gt;Vagrant&lt;!-- raw HTML omitted --&gt; obviously. I‚Äôll leave the install up to you. Next, you should clone this git repo =&amp;gt; &lt;!-- raw HTML omitted --&gt;Packer Windows Plugin&lt;!-- raw HTML omitted --&gt;. This plugin contains all the files necessary to get, install, and provision Windows boxes. Luckily, some very nice and clever folks, figured out a lot of things about how to install stuff on Windows. And given that people at Microsoft realised that sys admins would like to install stuff remotely, there are a bunch of forums and places where you can search for how to install software without user interaction. And this is the keyword you should look for =&amp;gt; &lt;strong&gt;unattended Windows install&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This will lead you further into the bowls of Windows technology and silent / quiet installs all over the place.&lt;/p&gt;
&lt;h1 id=&#34;packer-and-answer-files&#34;&gt;Packer and Answer Files&lt;/h1&gt;
&lt;p&gt;When it comes to installing software on Windows, you have quite a few obstacles to overtake. One of the biggest obstacle you are facing, are restarts. Windows has a special place in hell for that. Every time you install something important which requires system libraries or other kind of configuration which ‚Äúwill only take effect after you restart Windows‚Äù you have to do a restart. Now, a little background on how Packer interacts with Windows. At the moment, it uses OpenSSH to talk to the box which has to be the last which comes up. If it looses connection to openssh because, I don‚Äôt know, it restarted itself, you loose communication to the box, and the setup process stops in mid tracks.&lt;/p&gt;
&lt;p&gt;If you read about that in an earlier attempt to overtake this, you saw that you could use time-outs. You could kill ssh process which presumably makes packer do an attempt to start a new connection. If you are like me, you experienced that Packer does indeed NOT re-try. Because the previous task couldn‚Äôt finish, the restart killed the ssh service which could tell Packer that the previous task, an install for example, has finished. Hence, Packer will stay there and wait for that task to complete; which will never happen at this point.&lt;/p&gt;
&lt;p&gt;What can we do? Enter the world of &lt;!-- raw HTML omitted --&gt;Answer Files&lt;!-- raw HTML omitted --&gt;. Basically, it‚Äôs an xml file which sets up Windows. When Packer is running this file, the last service which should be installed, must be openSSH. And after that, in the provisioning phase, you should only install software which does not require restarts.&lt;/p&gt;
&lt;p&gt;Let‚Äôs look at an example.&lt;/p&gt;
&lt;h1 id=&#34;example-1-windows-updates&#34;&gt;Example #1: Windows Updates&lt;/h1&gt;
&lt;p&gt;This is another layer of purgatory for Windows. It‚Äôs updates. The updates take massive amount of times, if you are doing them from scratch, and also require several restart before it‚Äôs actually done. You¬†**could¬†**speed up the process a little bit, if you have a private network share where all of the Windows updates are sitting. At least that way you don‚Äôt have to download them every time you are creating a box. But you can‚Äôt avert the install process itself.&lt;/p&gt;
&lt;p&gt;Let‚Äôs look at a setup for packer. Packer works with JSON files for it‚Äôs configuration. An example for a Windows 7 box would look something like this:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;If it feels daunting, don‚Äôt worry. You‚Äôll get used to it fairly quickly. Let‚Äôs go over section by section on what this does.&lt;/p&gt;
&lt;h4 id=&#34;builders&#34;&gt;Builders&lt;/h4&gt;
&lt;p&gt;Packer uses builders for, well, building stuff. These two builders are virtualbox and vmware. I‚Äôm only interested in virtualbox. This builder downloads win7 and sets up some virtual box details like, disk size, vagrant user, memory, and so and so forth. The interesting part is the floppy part. Here, we can add in some files for setup. We will use this part later on.&lt;/p&gt;
&lt;h4 id=&#34;provisioners&#34;&gt;Provisioners&lt;/h4&gt;
&lt;p&gt;Now here is an interesting tid-bit. There are a bunch of provisioners available as plugin for packer.¬†Installing them is fairly easy. Packer needs binary plugins. Just copy them into ~/.packer.d/plugins or directly into the packer home directly. I‚Äôd advice against that. Have them in your own packer.d, that‚Äôs much cleaner. For binary plugin releases in the Windows side, look here =&amp;gt;¬†&lt;!-- raw HTML omitted --&gt;&lt;a href=&#34;https://github.com/packer-community/packer-windows-plugins/releases&#34;&gt;https://github.com/packer-community/packer-windows-plugins/releases&lt;/a&gt;&lt;!-- raw HTML omitted --&gt;. If you would like to build them yourself from source, download the source and use go gcc to build it. You will have to &lt;strong&gt;go get&lt;/strong&gt; a few packages though. Also you will have to have &lt;strong&gt;$GOPATH&lt;/strong&gt;¬†(pointing to your own workspace) and &lt;strong&gt;$GOROOT&lt;/strong&gt; (pointing to your working go)¬†setup. But this is not a Go guide. After that just do **go build main.go¬†**and you have your plugin.&lt;/p&gt;
&lt;p&gt;Provisioners are like vagrant provision they will execute post setup stuff on your box. Like installing utils, 7zip, choco, nuget, and so and so forth. There are a few interesting Windows provisioners, like restart-windows, powershell, and Windows shell. Which is like shell, but without the need of pre-setup if you are trying to use it on Windows. The basic shell on Windows is a little clanky and can hang from time-to-time so I recommend using PowerShell or WindowsShell provisioner if you are dealing with Windows post-setup Setup.&lt;/p&gt;
&lt;h4 id=&#34;post-processor&#34;&gt;Post-Processor&lt;/h4&gt;
&lt;p&gt;This will create the Vagrant box after everything is done.&lt;/p&gt;
&lt;h4 id=&#34;running-the-update&#34;&gt;Running the Update&lt;/h4&gt;
&lt;p&gt;For use, two things are interesting from here at this moment. These guys =&amp;gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;These two contain most of the logic which is part of the update process. You should see it in your checked out source. There is some very interesting logic in there which describes how the update happens. Basically it‚Äôs a loop which re-checks if there are updates available or if a re-start is needed. Packer handles re-starts well at this point in the install because it simply waits for SSH to come only. The rest is handled by Windows.&lt;/p&gt;
&lt;p&gt;These scripts are called in the Answer File which the Windows Setup uses for configuration purposes. Take a look at this section:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;This is were the floppy part comes on handy. This part uses the scripts bound by floppy and which will be available from a:.&lt;/p&gt;
&lt;p&gt;This will install all the updates available. It will take a while. A very very long while‚Ä¶ But let‚Äôs go a step further.&lt;/p&gt;
&lt;h1 id=&#34;example-2-installing-dotnet-45&#34;&gt;Example #2: Installing DotNet 4.5&lt;/h1&gt;
&lt;p&gt;Let‚Äôs assume you want to create a box with visual studio 2013, office, and have choco on it, and a couple of more things for which you need lots of restarts. You could try installing with /norestart switch, which also works; however¬†if you definitely need it to restart I suggest installing stuff with the Answer File. For this, let‚Äôs create a PowerShell script which downloads and installs dotnet 451 which is needed for visual studio ultimate 2013.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;So this downloads it right from the source. As mentioned earlier, you could have this on a nice shared drive so downloading from the internet is not necessary. The installer is in fact a bit friendly. It has a switch called /q /norestart. The /q is called silent install and the /norestart speaks for itself. If you leave it out, you can use /forcerestart or you could have the following two lines after this finishes:¬†&lt;em&gt;LogWrite ‚ÄúResarting Computer.‚Äù¬†Restart-Computer -Force&lt;/em&gt;. This will force a restart. You need the -Force because otherwise it won‚Äôt let it restart while there are active sessions logged on the computer.&lt;/p&gt;
&lt;p&gt;Now, let‚Äôs add this to the answer file:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;See, how easy this is? And now we make use of the floppy part of the windows-7.json by adding this line: &lt;strong&gt;‚Äú./scripts/install-dotnet-451.ps1‚Äù&lt;/strong&gt;. Don‚Äôt forget to append the ‚Äú,‚Äù at the end of the previous line. This is an array.&lt;/p&gt;
&lt;p&gt;We are ready to go. Just run &lt;strong&gt;packer build -only=virtualbox-iso windows-7.json&lt;/strong&gt; and you should be done!&lt;/p&gt;
&lt;h1 id=&#34;example-3-installing-visual-studio-ultimate&#34;&gt;Example #3: Installing Visual Studio Ultimate&lt;/h1&gt;
&lt;p&gt;Installing visual studio is almost trivial as well. With the addition that visual studio requires an admin.xml for silent install which has a bunch of settings. When you have the admin.xml just bind it into the floppy drive as well and call the visual studio install powershell script like this:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Again, this will take a while‚Ä¶‚Ä¶‚Ä¶‚Ä¶.&lt;/p&gt;
&lt;h1 id=&#34;post-setup-provisioning&#34;&gt;Post Setup Provisioning&lt;/h1&gt;
&lt;p&gt;When all this is done, you can still add some provisioning steps to add some utils with PowerShell or WindowsShell provisioner. I would advice against using simple shell. Bare in mind one other thing. If you have a batch file, and you are calling another batch file in that batch file, like choco install 7zip, it will happen that the install process will hang on installing 7zip. Because in Windows land the called script will not return the exec handler to the caller unless specifically asking for it with &lt;strong&gt;call&lt;/strong&gt;. Which means your bat file will look something like this:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;And so on, and so forth.&lt;/p&gt;
&lt;h1 id=&#34;wrap-up&#34;&gt;Wrap-Up&lt;/h1&gt;
&lt;p&gt;So, what have we learned? We have learned that installing software which requires re-start is better left to Windows itself with an answer file. Batch files will not return the handler. SSH &lt;strong&gt;MUST&lt;/strong&gt; be the last thing you start up in the answer file. Use PowerShell provisioner or WindowsShell provisioner on Windows.&lt;/p&gt;
&lt;p&gt;Hope this helped.&lt;/p&gt;
&lt;p&gt;Happy installing, and as always,&lt;/p&gt;
&lt;p&gt;Thanks for reading.&lt;/p&gt;
&lt;p&gt;Gergely.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker &#43; Java &#43; Vagrant&#43; GO.CD</title>
      <link>https://skarlso.github.io/2015/06/06/docker-ruby-lotus-go-cd/</link>
      <pubDate>Sat, 06 Jun 2015 00:00:00 +0000</pubDate>
      <guid>https://skarlso.github.io/2015/06/06/docker-ruby-lotus-go-cd/</guid>
      <description>&lt;p&gt;Hello folks.&lt;/p&gt;
&lt;p&gt;Today, I would like to write about something interesting and close to me at the moment. I‚Äôm going to setup Go.cd with Docker, and I‚Äôm going to get a Ruby Lotus app running. Let‚Äôs get started.&lt;/p&gt;
&lt;h1 id=&#34;fluff&#34;&gt;Fluff&lt;/h1&gt;
&lt;p&gt;Now, obviously, you don‚Äôt really need Go.Cd or Docker to setup a Java Gradle application, since it‚Äôs dead easy. But I‚Äôm going to do it just for the heck of it.&lt;/p&gt;
&lt;h1 id=&#34;setup&#34;&gt;Setup&lt;/h1&gt;
&lt;p&gt;Okay, lets start with Vagrant. Docker‚Äôs strength is coming from Linux‚Äôs process isolation capabilities it‚Äôs not yet properly working on OSX or Windows. You have a couple of options if you‚Äôd like to try never the less, like boot2docker, or a Tiny Linux kernel, but at that point, I think it‚Äôs easier to use a VM.&lt;/p&gt;
&lt;h4 id=&#34;vagrant&#34;&gt;Vagrant&lt;/h4&gt;
&lt;p&gt;So, let‚Äôs start with my small Vagrantfile.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Very simple. I‚Äôm setting up a trusty64(because docker requires 3.10 &amp;lt;= x)¬†box and then doing a simple shell provision. Also, I gave it a bit juice, since go-server requires a raw power. Here is the shell script:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;The debconf at the end accepts java8‚Äôs terms and conditions. And the last line installs docker in my box. This runs for a little while‚Ä¶&lt;/p&gt;
&lt;p&gt;The routing on the end routes every traffic from 172.17.*.* to my vagrant box, which in turn I‚Äôll be able to use from my mac local, like 127.0.0.1:8153/go/home.&lt;/p&gt;
&lt;p&gt;After a vagrant up, my box is ready to be used.&lt;/p&gt;
&lt;h4 id=&#34;docker&#34;&gt;Docker&lt;/h4&gt;
&lt;p&gt;When that‚Äôs finished, we can move on to the next part, which is writing a little Dockerfile for our image. Go.cd will require java and a couple of other things, so let‚Äôs automate the installation of that so we don‚Äôt have to do it¬†by hand.&lt;/p&gt;
&lt;p&gt;Here is a Dockerfile I came up with:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;So, our docker images have to be setup with Java as well for go.cd which I‚Äôm taking care of here, and a little bit extra, to add vim, and unzip, which is required for dpkg later.&lt;/p&gt;
&lt;p&gt;At this point run: &lt;strong&gt;docker build -t ubuntu:go .&lt;/strong&gt; -&amp;gt; This will use the dockerfile and create the ubuntu:go image. Note the¬†**.¬†**at the end.&lt;/p&gt;
&lt;h4 id=&#34;gocd&#34;&gt;Go.cd&lt;/h4&gt;
&lt;p&gt;Now, I‚Äôm creating two containers. One, go-server, will be the go server, and the other, go-agent, will be the go agent.&lt;/p&gt;
&lt;p&gt;First, go-server:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Pretty straight forward, no? We forward 8153 to vagrant (which forwards it to my mac), so after we start go-server service we should be able to visit: http://127.0.0.1:8153/go/home.&lt;/p&gt;
&lt;p&gt;Lo‚Äô, and behold, go server. Let‚Äôs add an agent too.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;No need to forward anything here. And as you can see, my agent was added successfully.&lt;/p&gt;
&lt;p&gt;All nice, and dandy. The agent is there, and I enabled it, so it‚Äôs ready to work. Let‚Äôs give it something to do, shall we?&lt;/p&gt;
&lt;h1 id=&#34;the-app&#34;&gt;The App&lt;/h1&gt;
&lt;p&gt;I‚Äôm going to use my gradle project which is on github. This one =&amp;gt;¬†https://github.com/Skarlso/DataMung.git.&lt;/p&gt;
&lt;p&gt;Very basic setup. Just check it out and then build &amp;amp; run tests. Easy, right?&lt;/p&gt;
&lt;p&gt;First step in this process, define the pipeline. I‚Äôm going to keep it simple. Name the pipeline DataMunger. Group is Linux. Now, in go.cd you have to define something called, an &lt;strong&gt;environment&lt;/strong&gt;. Environment can be anything you want, I‚Äôm going to go with Linux. You have to assign &lt;strong&gt;agents&lt;/strong&gt; to this environment who fulfil it and the pipeline which will use that environment. More on that you can read in the go.cd documentation. This is how you would handle a pipeline which uses linux, and a windows environment at the same time.&lt;/p&gt;
&lt;p&gt;In step one you have to define something called the &lt;strong&gt;Material&lt;/strong&gt;. That will be the source on which the agent will work. This can be multiple, in different folders within the confines of the pipeline, or singular.&lt;/p&gt;
&lt;p&gt;I defined my git project and tested the connection OK. Next up is the first¬†**Stage¬†**and the initial¬†**Job¬†**to perform. This, for me, will be a compile or an assemble, and later on a test run.&lt;/p&gt;
&lt;p&gt;Now, Go is awesome in parallelising jobs. If my project would be large enough, I could have multiple jobs¬†here. But for now,¬†I‚Äôll use stages because they run subsequently. So, first stage, compile. Next stage, testing and archiving the results.&lt;/p&gt;
&lt;p&gt;I added the next stage and defined the artefact. Go supports test-reports. If you define the path to a test artefact than go will parse it and create a nice report out of it.&lt;/p&gt;
&lt;p&gt;Now, let‚Äôs run it. It will probably fail on something. üòâ&lt;/p&gt;
&lt;p&gt;Well, I‚Äôll be‚Ä¶ It worked on the first run.&lt;/p&gt;
&lt;p&gt;And here are the test results.&lt;/p&gt;
&lt;h1 id=&#34;wrap-up&#34;&gt;Wrap-up&lt;/h1&gt;
&lt;p&gt;Well, that‚Äôs it folks. Gradle project, with vagrant, docker, and go.cd. I hope you all enjoyed reading about it as much as I did doing it.&lt;/p&gt;
&lt;p&gt;Any questions, please feel free to ask it in the comment section below.&lt;/p&gt;
&lt;p&gt;Cheers,
Have a nice weekend,
Gergely.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
