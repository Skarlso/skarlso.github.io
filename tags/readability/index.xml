<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Readability on Ramblings of a build engineer</title>
    <link>https://skarlso.github.io/tags/readability/</link>
    <description>Recent content in Readability on Ramblings of a build engineer</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 13 Jun 2012 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://skarlso.github.io/tags/readability/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Making your code understandable</title>
      <link>https://skarlso.github.io/2012/06/13/making-your-code-understandable/</link>
      <pubDate>Wed, 13 Jun 2012 00:00:00 +0000</pubDate>
      
      <guid>https://skarlso.github.io/2012/06/13/making-your-code-understandable/</guid>
      <description>&lt;p&gt;Hi!&lt;/p&gt;

&lt;p&gt;I&amp;#8217;ve seen this many times over and over again. Many people have wrote books about it already. Like Uncle Bob&amp;#8217;s Clean Code. Like Pragmatic Programmer by Andrew Hunt and David Thomas. What makes your code understandable to others.&lt;/p&gt;

&lt;p&gt;Is it &lt;strong&gt;Comments&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;No. It&amp;#8217;s not comments. If your code could be read properly you wouldn&amp;#8217;t need comments to explain what it does. Like Uncle Bob said. A good code doesn&amp;#8217;t contain surprises. It does exactly what you would think it should do on the next line. It doesn&amp;#8217;t have curves and misinformation. It doesn&amp;#8217;t have plots and turns of events like a good crime book. No. Good code is a like a boring soap opera with predictable plot and boring plain characters who don&amp;#8217;t change there behavior based on circumstances.&lt;/p&gt;

&lt;p&gt;Good code is easy to read. It flows like the river, falls like a waterfall, cooks like bacon and crosses the road like a professional chicken. If I read line A the next line should be B. If it is a Z or a :@L$&amp;#8230; I wont be happy.&lt;/p&gt;

&lt;p&gt;So then what makes it understandable?&lt;/p&gt;

&lt;p&gt;On simple word: &lt;strong&gt;Readability&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;What makes it readable?&lt;/p&gt;

&lt;p&gt;Small chunks of functions that have descriptive names as few parameters as possible and do only ONE thing at a time. Of course this is not all there is&amp;#8230; However it&amp;#8217;s the best thing to begin with. A function called &amp;#8220;doStuff&amp;#8221; that has a complexity of 300 has three fors, two switches and a dozen ifs isn&amp;#8217;t really helping. Now if you look at doStuff and try to give a name based on the job of the function and come up with &amp;#8220;propageXWithFiveUnlessYEqualsTheSumOfZPlusW&amp;#8221; you will know it does more then one thing.&lt;/p&gt;

&lt;p&gt;If you see a really complex function in your production code or hobby code ask yourself: &amp;#8220;Should this really be like 300 lines long and with a complexity of 200??&amp;#8221; And as you speak this out loud you will know the answer already. Break it up. Have like a dozen smaller functions that will be better I promise you. Take out parts. Write unit tests to it that help with re-factoring. Break it down into as small chunks as possible. It will be worth it. It will increase understand-ability, readability and maintainability.&lt;/p&gt;

&lt;p&gt;Hope that helped.&lt;/p&gt;

&lt;p&gt;Thank you for reading and as always,&lt;/p&gt;

&lt;p&gt;Have a nice Day,&lt;/p&gt;

&lt;p&gt;Gergely.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>