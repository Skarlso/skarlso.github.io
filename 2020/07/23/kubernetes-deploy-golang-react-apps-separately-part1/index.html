<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>How to deploy a Go (Golang) backend with a React frontend separately on Kubernetes - Part One | Ramblings of a cloud engineer</title>
<meta name="keywords" content="">
<meta name="description" content="Intro
Welcome. This is a longer post about how to deploy a Go backend with a React frontend
on Kubernetes as separate entities. Instead of the usual compiled together single binary Go
application, we are going to separate the two. Why? Because usually a React frontend is just a &ldquo;static&rdquo;
SPA app with very little requirements in terms of resources, while the Go backend does most of the
leg work, requiring a lot more resources.">
<meta name="author" content="hannibal">
<link rel="canonical" href="https://skarlso.github.io/2020/07/23/kubernetes-deploy-golang-react-apps-separately-part1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://skarlso.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://skarlso.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://skarlso.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://skarlso.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://skarlso.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://skarlso.github.io/2020/07/23/kubernetes-deploy-golang-react-apps-separately-part1/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="How to deploy a Go (Golang) backend with a React frontend separately on Kubernetes - Part One">
<meta property="og:description" content="Intro
Welcome. This is a longer post about how to deploy a Go backend with a React frontend
on Kubernetes as separate entities. Instead of the usual compiled together single binary Go
application, we are going to separate the two. Why? Because usually a React frontend is just a &ldquo;static&rdquo;
SPA app with very little requirements in terms of resources, while the Go backend does most of the
leg work, requiring a lot more resources.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://skarlso.github.io/2020/07/23/kubernetes-deploy-golang-react-apps-separately-part1/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-07-23T21:01:00+01:00">
<meta property="article:modified_time" content="2020-07-23T21:01:00+01:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="How to deploy a Go (Golang) backend with a React frontend separately on Kubernetes - Part One">
<meta name="twitter:description" content="Intro
Welcome. This is a longer post about how to deploy a Go backend with a React frontend
on Kubernetes as separate entities. Instead of the usual compiled together single binary Go
application, we are going to separate the two. Why? Because usually a React frontend is just a &ldquo;static&rdquo;
SPA app with very little requirements in terms of resources, while the Go backend does most of the
leg work, requiring a lot more resources.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://skarlso.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "How to deploy a Go (Golang) backend with a React frontend separately on Kubernetes - Part One",
      "item": "https://skarlso.github.io/2020/07/23/kubernetes-deploy-golang-react-apps-separately-part1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "How to deploy a Go (Golang) backend with a React frontend separately on Kubernetes - Part One",
  "name": "How to deploy a Go (Golang) backend with a React frontend separately on Kubernetes - Part One",
  "description": "Intro Welcome. This is a longer post about how to deploy a Go backend with a React frontend on Kubernetes as separate entities. Instead of the usual compiled together single binary Go application, we are going to separate the two. Why? Because usually a React frontend is just a \u0026ldquo;static\u0026rdquo; SPA app with very little requirements in terms of resources, while the Go backend does most of the leg work, requiring a lot more resources.\n",
  "keywords": [
    
  ],
  "articleBody": "Intro Welcome. This is a longer post about how to deploy a Go backend with a React frontend on Kubernetes as separate entities. Instead of the usual compiled together single binary Go application, we are going to separate the two. Why? Because usually a React frontend is just a “static” SPA app with very little requirements in terms of resources, while the Go backend does most of the leg work, requiring a lot more resources.\nPart two of this will contain scaling, utilization configuration, health probes, readiness probes, and how to make sure our application can run multiple instances without stepping on each other’s toes.\nNote: This isn’t going to be a Kubernetes guide. Some knowledge is assumed.\nSummary This post details a complex setup of an infrastructure with a second part coming on scaling and how to make your application scalable in the first place by doing idempotent transactions or dealing with locking and several instances of the same application not stepping on each other’s foot.\nThis, part one, details how to deploy traditional REST + Frontend based application in Go + React, but not bundled together as a single binary, instead having the backend separate from the frontend. They key in doing so is explained at the Ingress section when talking about routing specific URIs to the backend and frontend services.\nIf you are familiar with Kubernetes and infrastructure setup, feel free to skip ahead to that section. Otherwise, enjoy the drawings or the writing or both.\nTechnology The SPA app will be handled by Serve while the Go backend will use Echo. The database will be Postgres.\nWe are going to apply some best practices using Network Policies to cordon off traffic that we don’t want to go outside.\nWe will set up HTTPS using cert-manager and let’s encrypt. We’ll be using nginx as ingress provider.\nCode All, or most of the code, including the application can be found here:\nStaple. The application is a simple reading list manager with user handling, email sending and lots of database access.\nLet’s get to it then!\nKubernetes Provider Let’s start with the obvious one. Where do you would like to create your Kubernetes cluster?\nThere are four major providers now-a-days. AWS EKS, GCP GKE, Azure AKS and DigitalOcean DKE. Personally, I prefer DO because, it’s a lot cheaper than the others. The downside is that DO only provides ReadWriteOnce persistent volumes. This gets to be a problem when we are trying to update and the new Pod can’t mount the volume because it’s already taken by the existing one. This can be solved by a good ol NFS instance. But that’s another story.\nAWS’ was late to the party and their solution is quite fragile and the API is terrible. GCP is best in terms of technicalities, api, handling, and updates. Azure is surprisingly good, however, the documentation is most of the times out of date or even plain incorrect at some places.\nSetup Basics To setup your Kubernetes instance, follow DigitalOcean’s Kubernetes Getting Started guide. It’s really simple. When you have access to the cluster via kubectl I highly recommend using this tool: k9s.\nIt’s a flexible and quite handy tool for quick observations, logs, shells to pods, edits and generally following what’s happening to your cluster.\nNow that we are all set with our own little cluster, it’s time to have some people move in. First, we are going to install cert-manager.\nNote: I’m not going to use Helm because I think it’s unnecessary in this setting. We aren’t going to install these things in a highly configurable way and updating with helm is a pain in the butt. For example, for cert-manager the update with helm takes several steps, whilst updating with a plain yaml file is just applying the next version of the yaml file.\nI’m not going to explain how to install cert-manager or nginx. I’ll link to their respective guides because frankly, they are simple to follow and work out of the box.\nTo install nginx, simply apply the yaml file located here: DigitalOcean Nginx.\nTo install cert-manager follow this guide: cert-manager. Follow the regular manifest install part, then ignore the Helm part and proceed with verification and then install your issuer. I used a simple ACME/http01 issuer from here: acme/http01\nNote: That acme configuration contains the staging url. This is to test that things are working. Once you are sure that everything is wired up correctly, switch that url to this one: https://acme-v02.api.letsencrypt.org/directory -\u003e prod url. For example:\napiVersion: cert-manager.io/v1alpha2 kind: ClusterIssuer metadata: name: letsencrypt-prod spec: acme: # The ACME server URL server: https://acme-v02.api.letsencrypt.org/directory # Email address used for ACME registration email: your@email.com # Name of a secret used to store the ACME account private key privateKeySecretRef: name: letsencrypt-prod # Enable the HTTP-01 challenge provider solvers: - http01: ingress: class: nginx Note: I’m using a ClusterIssuer because I have multiple domains and multiple namespaces.\nThat’s it. Cert-manager and nginx should be up and running. Later on, we will create our own ingress rules.\nDomain Next, you’ll need a domain to bind too. There are a gazillion domain providers out there like no-ip, GoDaddy, HostGator, Shopify and so on. Choose one which is available to you or has the best prices.\nThere are some good guides on how to choose a domain and where to create it. For example: 5 things to watch out for when buying a domain.\nThe application Alright, let’s put together the application.\nStructure Every piece of our infrastructure will be laid out in yaml files. I believe in infrastructure as code. If you run a command you will most likely forget about it, unless it’s logged and / or is replayable.\nThis is the structure I’m using:\n. ├── LICENSE ├── README.md ├── certificate_request │ └── certificate_request.yml ├── configmaps │ └── staple_initdb_script.yaml ├── database │ ├── staple_db_deployment.yaml │ ├── staple_db_network_policy.yaml │ ├── staple_db_pvc.yaml │ └── staple_db_service.yaml ├── namespace │ └── staple_namespace.yaml ├── primer.sql ├── rbac ├── secrets │ ├── staple_db_password.yaml │ └── staple_mg_creds.yaml ├── staple-backend │ ├── staple_deployment.yaml │ └── staple_service.yaml └── staple-frontend ├── staple_deployment.yaml └── staple_service.yaml One other possible combination is, if you have multiple applications:\n. ├── README.md ├── applications │ ├── confluence │ │ ├── db │ │ │ ├── db_deployment.yaml │ │ │ └── db_service.yaml │ │ ├── deployment │ │ │ └── deployment.yaml │ │ ├── pvc │ │ │ └── confluence_app_pvc.yaml │ │ └── service │ │ └── service.yaml │ ├── gitea │ │ ├── config │ │ │ ├── app.ini │ │ │ └── gitea_config_map.yaml │ │ ├── db │ │ │ ├── gitea_db_deployment.yaml │ │ │ ├── gitea_db_network_policy.yaml │ │ │ ├── gitea_db_pvc.yaml │ │ │ └── gitea_db_service.yaml │ │ ├── deployment │ │ │ └── gitea_deployment.yaml │ │ ├── pvc │ │ │ └── gitea_app_pvc.yaml │ │ └── service │ │ └── gitea_service.yaml ├── cronjobs │ ├── cronjob1 │ │ ├── Dockerfile │ │ ├── README.md │ │ ├── go.mod │ │ ├── go.sum │ │ ├── cron.yaml │ │ └── main.go ├── ingress │ ├── example1 │ │ ├── example1_ingress_resource.yaml │ │ └── gitea_ssh_configmap.yaml │ ├── example2 │ │ └── example2_ingress_resource.yaml │ ├── lets-encrypt-issuer.yaml │ └── nginx │ ├── nginx-ingress-controller-deployment.yaml │ └── nginx-ingress-controller-service.yaml └── namespaces ├── example1_namespace.yaml ├── example2_namespace.yaml Namespace Before we begin, we’ll create a namespace for our application to properly partition all our entities.\nTo create a namespace we’ll use this yaml example_namespace.yaml:\napiVersion: v1 kind: Namespace metadata: name: example Apply this with kubectl -f apply example_namespace.yaml.\nThe Database Deploying a Postgres database on Kubernetes is actually really easy. You need five things to have a basic, but relatively secure installation.\nSecret The secret contains our password and our database user. In postgres, if you define a user using POSTGRES_USER postgres will create the user and a database with the user’s name. This could come from Vault too, but the Kubernetes secret is usually enough since it should be a closed environment anyways. But for important information I would definitely use an admission policy and some vault secret goodness. (Maybe another post?)\nOur secret looks like this: database_secret.yaml\napiVersion: v1 kind: Secret metadata: name: staple-db-password namespace: staple data: POSTGRES_PASSWORD: cGFzc3dvcmQxMjM= # This creates a user and a db with the same name. POSTGRES_USER: c3RhcGxl To generate the base64 code for a password and a user, use:\necho -n \"password123\" | base64 echo -n \"username\" | base64 …and paste the result in the respective fields. Once done, apply with kubectl -f apply database_secret.yaml.\nDeployment The deployment which configures our database. Looks something like this (database_deployment.yaml):\napiVersion: apps/v1 kind: Deployment metadata: namespace: staple name: staple-db spec: replicas: 1 selector: matchLabels: app: staple-db template: metadata: name: staple-db labels: app: staple-db spec: containers: - name: postgres image: postgres:11 env: - name: POSTGRES_USER value: staple - name: POSTGRES_PASSWORD valueFrom: secretKeyRef: name: staple-db-password key: POSTGRES_PASSWORD volumeMounts: - mountPath: /var/lib/postgresql/data subPath: data # important so it gets mounted correctly name: staple-db-data - mountPath: /docker-entrypoint-initdb.d/staple_initdb.sql subPath: staple_initdb.sql name: bootstrap-script volumes: - name: staple-db-data persistentVolumeClaim: claimName: do-storage-staple-db - name: bootstrap-script configMap: name: staple-initdb-script Note the two volume mounts.\nThe first one makes sure that our data isn’t lost when the database pod itself restarts. It creates a mount to a persistent volume which is defined a few lines below by persistentVolumeClaim. subPath is important in this case otherwise you’ll end up with a lost\u0026found folder.\nThe second mount is a postgres specific initialization file. Postgres will run that sql file when it starts up. I’m using it to create my application’s schema.\ncreate database staples; create table users (email varchar(255), password text, confirm_code text, max_staples int); create table staples (name varchar(255), id serial, content text, created_at timestamp, archived bool, user_email varchar(255)); And it comes from a configmap which looks like this:\napiVersion: v1 kind: ConfigMap metadata: name: staple-initdb-script namespace: staple labels: app: staple data: staple_initdb.sql: create table users (email varchar(255), password text, confirm_code text, max_staples int); create table staples (name varchar(255), id serial, content text, created_at timestamp, archived bool, user_email varchar(255)); Network Policy Network policies are important if you value your privacy. They restrict a PODs communication to a certain namespace OR even to between applications only. By default I like to deny all traffic and then slowly open the valve until everything works.\nKudos if you know who this is. (mind my terrible drawing capabilities)\nWe’ll use a basic network policy which will restrict the DB to talk to anything BUT the backend. Nothing else will be able to talk to this Pod.\napiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: staple-db-network-policy namespace: staple spec: podSelector: matchLabels: app: staple-db policyTypes: - Ingress - Egress ingress: - from: - podSelector: matchLabels: app: staple ports: - protocol: TCP port: 5432 egress: - to: - podSelector: matchLabels: app: staple ports: - protocol: TCP port: 5432 The important bit here is the podSelector part. The label will be the label used by the application deployment. This will restrict the Pod’s incoming and outgoing traffic to that of the application Pod including denying internet traffic.\nPVC The persistent volume claim definition is straight forward:\napiVersion: v1 kind: PersistentVolumeClaim metadata: namespace: staple name: do-storage-staple-db spec: accessModes: - ReadWriteOnce resources: requests: storage: 10Gi storageClassName: do-block-storage 10 gigs should be enough anything.\nService The service will expose the database deployment to our cluster.\nOur service is fairly basic:\nkind: Service apiVersion: v1 metadata: namespace: staple name: staple-db-service spec: ports: - port: 5432 selector: app: staple-db clusterIP: None That’s done with the database. Next up is the backend.\nThe backend The backend itself is written in a way that it doesn’t require a persistent storage so we can skip that part. It only needs three pieces. A secret, a deployment definition and the service exposing the deployment.\nSecret First, we create a secret which contains Mailgun credentials.\napiVersion: v1 kind: Secret metadata: name: staple-mg-creds namespace: staple data: MG_DOMAIN: cGFzc3dvcmQxMjM= MG_API_KEY: cGFzc3dvcmQxMjM= Database connection The connection settings are handled through the same secret which is used to spin up the DB itself. We have to only mount that here too and we are good.\nDeployment Which brings us to the deployment. This is a bit more involved.\napiVersion: apps/v1 kind: Deployment metadata: namespace: staple name: staple-app labels: app: staple spec: replicas: 1 selector: matchLabels: app: staple template: metadata: labels: app: staple app.kubernetes.io/name: staple app.kubernetes.io/instance: staple spec: containers: - name: staple image: skarlso/staple:v0.1.0 imagePullPolicy: IfNotPresent resources: requests: memory: \"500Mi\" cpu: \"250m\" limits: memory: \"1000Mi\" cpu: \"500m\" env: - name: POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace - name: DB_PASSWORD valueFrom: secretKeyRef: name: staple-db-password key: POSTGRES_PASSWORD - name: MG_DOMAIN valueFrom: secretKeyRef: name: staple-mg-creds key: MG_DOMAIN - name: MG_API_KEY valueFrom: secretKeyRef: name: staple-mg-creds key: MG_API_KEY args: - --staple-db-hostname=staple-db-service.cronohub.svc.cluster.local:5432 - --staple-db-username=staple - --staple-db-database=staple - --staple-db-password=$(DB_PASSWORD) - --mg-domain=$(MG_DOMAIN) - --mg-api-key=$(MG_API_KEY) ports: - name: staple-port containerPort: 9998 There are a few important points here and I won’t explain them all, like the resource restrictions, which you should be familiar with by now. I’m using a mix of 12factor app’s environment configuration and command line arguments for the application configuration. The app itself is not using os.Environ but the args.\nThe args point to the cluster local dns of the database, some db settings, and the mailgun credentials.\nIt also exposes the container port 9998 which is Echo’s default port.\nNow all we need is the service.\nService Without much fanfare:\nkind: Service apiVersion: v1 metadata: namespace: staple name: staple-service labels: app: staple app.kubernetes.io/name: staple app.kubernetes.io/instance: staple spec: selector: app: staple app.kubernetes.io/name: staple app.kubernetes.io/instance: staple ports: - name: service-port port: 9998 targetPort: staple-port And with this, the backend is done.\nThe frontend The frontend, similarly to the backend, does not require a persistent volume. We can skip that one too.\nIn fact it only needs two things, a deployment and a service, and that’s all. It uses serve to host the static files. Honestly, that could also be a Go application serving the static content or anything that can serve static files.\nDeployment apiVersion: apps/v1 kind: Deployment metadata: namespace: staple name: staple-frontend labels: app: staple-frontend spec: replicas: 1 selector: matchLabels: app: staple-frontend template: metadata: labels: app: staple-frontend app.kubernetes.io/name: staple-frontend app.kubernetes.io/instance: staple-frontend spec: containers: - name: staple-frontend image: skarlso/staple-frontend:v0.0.9 imagePullPolicy: IfNotPresent resources: requests: memory: \"500Mi\" cpu: \"250m\" limits: memory: \"1000Mi\" cpu: \"500m\" env: - name: POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace - name: REACT_APP_STAPLE_DEV_HOST value: \"\" ports: - name: staple-front containerPort: 5000 Service And the service:\nkind: Service apiVersion: v1 metadata: namespace: staple name: staple-front-service labels: app: staple-frontend app.kubernetes.io/name: staple-frontend app.kubernetes.io/instance: staple-frontend spec: selector: app: staple-frontend app.kubernetes.io/name: staple-frontend app.kubernetes.io/instance: staple-frontend ports: - name: staple-front port: 5000 targetPort: staple-front And with that the backend and frontend are wired together and ready to receive traffic.\nAll pods should be up and running without problems at this point. If you have any trouble deploying things, please don’t hesitate to leave a question in the comments.\nIngress Fantastic. Now, our application is running. We just need to expose it and route traffic to it. The backend has the api route /rest/api/v1/. The frontend has the route syntax /login, /register and a bunch of others. The key here is that all of them are under the same domain name but based on the URI we need to direct one request to the backend the other to the frontend.\nThis is done via nginx’s routing logic using regex. In an nginx config this would be the location part. It’s imperative that the order of the routing is from more specific towards more general Because we need to catch the specific URIs first.\nIngress Resource To do this, we will create something called an Ingress Resource. Note that this is Nginx’s ingress resource and not Kubernetes’. There is a difference.\nI suggest reading up on that link about the ingress resource because it reads quite well and will explain how it works and fits into the Kubernetes environment.\nGot it? Good. We’ll create one for staple.app domain:\napiVersion: extensions/v1beta1 kind: Ingress metadata: namespace: staple name: staple-app-ingress annotations: kubernetes.io/ingress.class: \"nginx\" cert-manager.io/cluster-issuer: \"letsencrypt-prod\" cert-manager.io/acme-challenge-type: http01 nginx.ingress.kubernetes.io/rewrite-target: /$1 # this is important spec: tls: - hosts: - staple.app secretName: staple-app-tls rules: - host: staple.app http: paths: - backend: serviceName: staple-service servicePort: ss-port # 9998 path: /(rest/api/1.*) - host: staple.app http: paths: - backend: serviceName: staple-front-service servicePort: sfs-port # 5000 path: /(.*) Let’s take a look at what’s going on here. The first thing to catch the eye are the annotations. These are configuration settings for nginx, cert-manager and Kubernetes. We have the cluster issuer’s name. The challenge type, which we decided should be http01, and the most important part, the rewrite-target setting. This will use the first capture group as a base after the host.\nWith this rewrite rule in place, the paths values need to provide a capture group. The first in line will see everything that goes to the urls like: staple.app/rest/api/1/token, staple.app/rest/api/1/staples, staple.app/rest/api/1/user, etc. The first part of the url is the host staple.app, second part is /(rest/api/1/.*) for which the result is that group number one ($1) will be rest/api/1/token. Nginx now sees that we have a backend route for that and will send this URI along to the service. Our service picks it up and will match that URI to the router configuration.\nIf there is a request like, staple.app/login, which is our frontend’s job to pick up, the first rule will not catch it because the regex isn’t matching, so it falls through to the second one, which is the frontend service that is using a “catch all” regex. Like ip tables, we go from specific to more general.\nEnding words And that’s it. If everything works correctly, then the certificate service wired up the https certs and we should be able ping the rest endpoint under https://staple.app/rest/api/1/token and log in to the app in the browser using https://staple.app.\nStay tuned for the second part where we’ll scale the thing up!\nThanks for reading! Gergely.\n",
  "wordCount" : "2974",
  "inLanguage": "en",
  "datePublished": "2020-07-23T21:01:00+01:00",
  "dateModified": "2020-07-23T21:01:00+01:00",
  "author":{
    "@type": "Person",
    "name": "hannibal"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://skarlso.github.io/2020/07/23/kubernetes-deploy-golang-react-apps-separately-part1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ramblings of a cloud engineer",
    "logo": {
      "@type": "ImageObject",
      "url": "https://skarlso.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://skarlso.github.io/" accesskey="h" title="Ramblings of a cloud engineer (Alt + H)">Ramblings of a cloud engineer</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://skarlso.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/search/" title="Search">
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://skarlso.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://skarlso.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      How to deploy a Go (Golang) backend with a React frontend separately on Kubernetes - Part One
    </h1>
    <div class="post-meta"><span title='2020-07-23 21:01:00 +0100 +0100'>July 23, 2020</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;hannibal

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#intro" aria-label="Intro">Intro</a><ul>
                        
                <li>
                    <a href="#summary" aria-label="Summary">Summary</a></li>
                <li>
                    <a href="#technology" aria-label="Technology">Technology</a></li>
                <li>
                    <a href="#code" aria-label="Code">Code</a></li>
                <li>
                    <a href="#kubernetes-provider" aria-label="Kubernetes Provider">Kubernetes Provider</a></li>
                <li>
                    <a href="#setup-basics" aria-label="Setup Basics">Setup Basics</a></li>
                <li>
                    <a href="#domain" aria-label="Domain">Domain</a></li></ul>
                </li>
                <li>
                    <a href="#the-application" aria-label="The application">The application</a><ul>
                        
                <li>
                    <a href="#structure" aria-label="Structure">Structure</a></li>
                <li>
                    <a href="#namespace" aria-label="Namespace">Namespace</a></li>
                <li>
                    <a href="#the-database" aria-label="The Database">The Database</a><ul>
                        
                <li>
                    <a href="#secret" aria-label="Secret">Secret</a></li>
                <li>
                    <a href="#deployment" aria-label="Deployment">Deployment</a></li>
                <li>
                    <a href="#network-policy" aria-label="Network Policy">Network Policy</a></li>
                <li>
                    <a href="#pvc" aria-label="PVC">PVC</a></li>
                <li>
                    <a href="#service" aria-label="Service">Service</a></li></ul>
                </li>
                <li>
                    <a href="#the-backend" aria-label="The backend">The backend</a><ul>
                        
                <li>
                    <a href="#secret-1" aria-label="Secret">Secret</a></li>
                <li>
                    <a href="#database-connection" aria-label="Database connection">Database connection</a></li>
                <li>
                    <a href="#deployment-1" aria-label="Deployment">Deployment</a></li>
                <li>
                    <a href="#service-1" aria-label="Service">Service</a></li></ul>
                </li>
                <li>
                    <a href="#the-frontend" aria-label="The frontend">The frontend</a><ul>
                        
                <li>
                    <a href="#deployment-2" aria-label="Deployment">Deployment</a></li>
                <li>
                    <a href="#service-2" aria-label="Service">Service</a></li></ul>
                </li>
                <li>
                    <a href="#ingress" aria-label="Ingress">Ingress</a><ul>
                        
                <li>
                    <a href="#ingress-resource" aria-label="Ingress Resource">Ingress Resource</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#ending-words" aria-label="Ending words">Ending words</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="intro">Intro<a hidden class="anchor" aria-hidden="true" href="#intro">#</a></h1>
<p>Welcome. This is a longer post about how to deploy a Go backend with a React frontend
on Kubernetes as separate entities. Instead of the usual compiled together single binary Go
application, we are going to separate the two. Why? Because usually a React frontend is just a &ldquo;static&rdquo;
SPA app with very little requirements in terms of resources, while the Go backend does most of the
leg work, requiring a lot more resources.</p>
<p>Part two of this will contain scaling, utilization configuration, health probes, readiness probes,
and how to make sure our application can run multiple instances without stepping on each other&rsquo;s toes.</p>
<p><em>Note</em>: This isn&rsquo;t going to be a Kubernetes guide. Some knowledge is assumed.</p>
<h2 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h2>
<p><img alt="Give me the short version" loading="lazy" src="/img/kube/short-version.png"></p>
<p>This post details a complex setup of an infrastructure with a second part coming on scaling and how to make
your application scalable in the first place by doing idempotent transactions or dealing with locking and
several instances of the same application not stepping on each other&rsquo;s foot.</p>
<p>This, part one, details how to deploy traditional REST + Frontend based application in Go + React, but not bundled
together as a single binary, instead having the backend separate from the frontend. They key in doing so is explained
at the <a href="/2020/07/23/kubernetes-deploy-golang-react-apps-separately-part1/#ingress">Ingress</a> section when talking about routing specific URIs to the backend and frontend services.</p>
<p>If you are familiar with Kubernetes and infrastructure setup, feel free to skip ahead to that section. Otherwise, enjoy
the drawings or the writing or both.</p>
<h2 id="technology">Technology<a hidden class="anchor" aria-hidden="true" href="#technology">#</a></h2>
<p>The SPA app will be handled by <a href="https://www.npmjs.com/package/serve">Serve</a> while the Go backend
will use <a href="https://echo.labstack.com/">Echo</a>. The database will be Postgres.</p>
<p>We are going to apply some best practices using Network Policies to cordon off traffic that we don&rsquo;t
want to go outside.</p>
<p>We will set up HTTPS using cert-manager and let&rsquo;s encrypt. We&rsquo;ll be using nginx as ingress
provider.</p>
<h2 id="code">Code<a hidden class="anchor" aria-hidden="true" href="#code">#</a></h2>
<p><img alt="Let me show you the code" loading="lazy" src="/img/kube/architect.png"></p>
<p>All, or most of the code, including the application can be found here:</p>
<p><a href="https://github.com/staple-org">Staple</a>. The application is a simple reading list manager with
user handling, email sending and lots of database access.</p>
<p>Let&rsquo;s get to it then!</p>
<h2 id="kubernetes-provider">Kubernetes Provider<a hidden class="anchor" aria-hidden="true" href="#kubernetes-provider">#</a></h2>
<p><img alt="Difficult Choice" loading="lazy" src="/img/kube/audition.png"></p>
<p>Let&rsquo;s start with the obvious one. Where do you would like to create your Kubernetes cluster?</p>
<p>There are four major providers now-a-days. AWS <a href="https://aws.amazon.com/eks/">EKS</a>, GCP <a href="https://cloud.google.com/kubernetes-engine">GKE</a>,
Azure <a href="https://azure.microsoft.com/en-us/services/kubernetes-service/">AKS</a> and DigitalOcean <a href="https://www.digitalocean.com/products/kubernetes/">DKE</a>.
Personally, I prefer DO because, it&rsquo;s a lot cheaper than the others. The downside is that DO only
provides ReadWriteOnce persistent volumes. This gets to be a problem when we are trying to update
and the new Pod can&rsquo;t mount the volume because it&rsquo;s already taken by the existing one. This can be
solved by a good ol NFS instance. But that&rsquo;s another story.</p>
<p>AWS&rsquo; was late to the party and their solution is quite fragile and the API is terrible. GCP is best in terms
of technicalities, api, handling, and updates. Azure is surprisingly good, however, the documentation is
most of the times out of date or even plain incorrect at some places.</p>
<h2 id="setup-basics">Setup Basics<a hidden class="anchor" aria-hidden="true" href="#setup-basics">#</a></h2>
<p><img alt="Owl" loading="lazy" src="/img/kube/owl.jpg"></p>
<p>To setup your Kubernetes instance, follow DigitalOcean&rsquo;s Kubernetes Getting Started guide. It&rsquo;s really simple.
When you have access to the cluster via kubectl I highly recommend using this tool: <a href="https://github.com/derailed/k9s">k9s</a>.</p>
<p>It&rsquo;s a flexible and quite handy tool for quick observations, logs, shells to pods, edits and generally following what&rsquo;s
happening to your cluster.</p>
<p>Now that we are all set with our own little cluster, it&rsquo;s time to have some people move in. First, we are going to
install cert-manager.</p>
<p><em>Note</em>: I&rsquo;m not going to use Helm because I think it&rsquo;s unnecessary in this setting. We aren&rsquo;t going to install
these things in a highly configurable way and updating with helm is a pain in the butt. For example, for cert-manager
the update with helm takes several steps, whilst updating with a plain yaml file is just applying the next version
of the yaml file.</p>
<p>I&rsquo;m not going to explain how to install cert-manager or nginx. I&rsquo;ll link to their respective guides because frankly, they
are simple to follow and work out of the box.</p>
<p>To install nginx, simply apply the yaml file located here: <a href="https://kubernetes.github.io/ingress-nginx/deploy/#digital-ocean">DigitalOcean Nginx</a>.</p>
<p>To install cert-manager follow this guide: <a href="https://cert-manager.io/docs/installation/kubernetes/">cert-manager</a>.
Follow the regular manifest install part, then ignore the Helm part and proceed with verification and then install
your issuer. I used a simple ACME/http01 issuer from here: <a href="https://cert-manager.io/docs/configuration/acme/http01/">acme/http01</a></p>
<p><em>Note</em>: That acme configuration contains the <strong>staging</strong> url. This is to test that things are working. Once you are
sure that everything is wired up correctly, switch that url to this one:
<code>https://acme-v02.api.letsencrypt.org/directory</code> -&gt; prod url. For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">cert-manager.io/v1alpha2</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">ClusterIssuer</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">letsencrypt-prod</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">acme</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># The ACME server URL</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">server</span>: <span style="color:#ae81ff">https://acme-v02.api.letsencrypt.org/directory</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Email address used for ACME registration</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">email</span>: <span style="color:#ae81ff">your@email.com</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Name of a secret used to store the ACME account private key</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">privateKeySecretRef</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">name</span>: <span style="color:#ae81ff">letsencrypt-prod</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Enable the HTTP-01 challenge provider</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">solvers</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">http01</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">ingress</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">class</span>: <span style="color:#ae81ff">nginx</span>
</span></span></code></pre></div><p><em>Note</em>: I&rsquo;m using a ClusterIssuer because I have multiple domains and multiple namespaces.</p>
<p>That&rsquo;s it. Cert-manager and nginx should be up and running. Later on, we will create our own
ingress rules.</p>
<h2 id="domain">Domain<a hidden class="anchor" aria-hidden="true" href="#domain">#</a></h2>
<p>Next, you&rsquo;ll need a domain to bind too. There are a gazillion domain providers out there like
no-ip, GoDaddy, HostGator, Shopify and so on. Choose one which is available to you or has the best
prices.</p>
<p>There are some good guides on how to choose a domain and where to create it.
For example: <a href="https://domains.google/learning-center/5-things-to-watch-out-for-when-buying-a-domain/">5 things to watch out for when buying a domain</a>.</p>
<h1 id="the-application">The application<a hidden class="anchor" aria-hidden="true" href="#the-application">#</a></h1>
<p>Alright, let&rsquo;s put together the application.</p>
<p><img alt="Assemble" loading="lazy" src="/img/kube/assemble.png"></p>
<h2 id="structure">Structure<a hidden class="anchor" aria-hidden="true" href="#structure">#</a></h2>
<p>Every piece of our infrastructure will be laid out in yaml files. I believe in infrastructure as code.
If you run a command you will most likely forget about it, unless it&rsquo;s logged and / or is replayable.</p>
<p>This is the structure I&rsquo;m using:</p>
<pre tabindex="0"><code>.
├── LICENSE
├── README.md
├── certificate_request
│   └── certificate_request.yml
├── configmaps
│   └── staple_initdb_script.yaml
├── database
│   ├── staple_db_deployment.yaml
│   ├── staple_db_network_policy.yaml
│   ├── staple_db_pvc.yaml
│   └── staple_db_service.yaml
├── namespace
│   └── staple_namespace.yaml
├── primer.sql
├── rbac
├── secrets
│   ├── staple_db_password.yaml
│   └── staple_mg_creds.yaml
├── staple-backend
│   ├── staple_deployment.yaml
│   └── staple_service.yaml
└── staple-frontend
    ├── staple_deployment.yaml
    └── staple_service.yaml
</code></pre><p>One other possible combination is, if you have multiple applications:</p>
<pre tabindex="0"><code>.
├── README.md
├── applications
│   ├── confluence
│   │   ├── db
│   │   │   ├── db_deployment.yaml
│   │   │   └── db_service.yaml
│   │   ├── deployment
│   │   │   └── deployment.yaml
│   │   ├── pvc
│   │   │   └── confluence_app_pvc.yaml
│   │   └── service
│   │       └── service.yaml
│   ├── gitea
│   │   ├── config
│   │   │   ├── app.ini
│   │   │   └── gitea_config_map.yaml
│   │   ├── db
│   │   │   ├── gitea_db_deployment.yaml
│   │   │   ├── gitea_db_network_policy.yaml
│   │   │   ├── gitea_db_pvc.yaml
│   │   │   └── gitea_db_service.yaml
│   │   ├── deployment
│   │   │   └── gitea_deployment.yaml
│   │   ├── pvc
│   │   │   └── gitea_app_pvc.yaml
│   │   └── service
│   │       └── gitea_service.yaml
├── cronjobs
│   ├── cronjob1
│   │   ├── Dockerfile
│   │   ├── README.md
│   │   ├── go.mod
│   │   ├── go.sum
│   │   ├── cron.yaml
│   │   └── main.go
├── ingress
│   ├── example1
│   │   ├── example1_ingress_resource.yaml
│   │   └── gitea_ssh_configmap.yaml
│   ├── example2
│   │   └── example2_ingress_resource.yaml
│   ├── lets-encrypt-issuer.yaml
│   └── nginx
│       ├── nginx-ingress-controller-deployment.yaml
│       └── nginx-ingress-controller-service.yaml
└── namespaces
    ├── example1_namespace.yaml
    ├── example2_namespace.yaml
</code></pre><h2 id="namespace">Namespace<a hidden class="anchor" aria-hidden="true" href="#namespace">#</a></h2>
<p>Before we begin, we&rsquo;ll create a namespace for our application to properly partition all our entities.</p>
<p>To create a namespace we&rsquo;ll use this yaml <code>example_namespace.yaml</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Namespace</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">example</span>
</span></span></code></pre></div><p>Apply this with <code>kubectl -f apply example_namespace.yaml</code>.</p>
<h2 id="the-database">The Database<a hidden class="anchor" aria-hidden="true" href="#the-database">#</a></h2>
<p>Deploying a Postgres database on Kubernetes is actually really easy. You need five things to have a basic, but
relatively secure installation.</p>
<h3 id="secret">Secret<a hidden class="anchor" aria-hidden="true" href="#secret">#</a></h3>
<p>The secret contains our password and our database user. In postgres, if you define a user using <code>POSTGRES_USER</code>
postgres will create the user and a database with the user&rsquo;s name. This could come from Vault too, but
the Kubernetes secret is usually enough since it should be a closed environment anyways. But for important information
I would definitely use an admission policy and some vault secret goodness. (Maybe another post?)</p>
<p>Our secret looks like this:
database_secret.yaml</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Secret</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-db-password</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">data</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">POSTGRES_PASSWORD</span>: <span style="color:#ae81ff">cGFzc3dvcmQxMjM=</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># This creates a user and a db with the same name.</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">POSTGRES_USER</span>: <span style="color:#ae81ff">c3RhcGxl</span>
</span></span></code></pre></div><p>To generate the base64 code for a password and a user, use:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>echo -n <span style="color:#e6db74">&#34;password123&#34;</span> | base64
</span></span><span style="display:flex;"><span>echo -n <span style="color:#e6db74">&#34;username&#34;</span> | base64
</span></span></code></pre></div><p>&hellip;and paste the result in the respective fields. Once done, apply with <code>kubectl -f apply database_secret.yaml</code>.</p>
<h3 id="deployment">Deployment<a hidden class="anchor" aria-hidden="true" href="#deployment">#</a></h3>
<p>The deployment which configures our database. Looks something like this (database_deployment.yaml):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">apps/v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Deployment</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-db</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">matchLabels</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple-db</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">template</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-db</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple-db</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">postgres</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">image</span>: <span style="color:#ae81ff">postgres:11</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">env</span>:
</span></span><span style="display:flex;"><span>          - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">POSTGRES_USER</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">value</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>          - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">POSTGRES_PASSWORD</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">valueFrom</span>:
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">secretKeyRef</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-db-password</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">key</span>: <span style="color:#ae81ff">POSTGRES_PASSWORD</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">volumeMounts</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/var/lib/postgresql/data</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">subPath</span>: <span style="color:#ae81ff">data</span> <span style="color:#75715e"># important so it gets mounted correctly</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-db-data</span>
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/docker-entrypoint-initdb.d/staple_initdb.sql</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">subPath</span>: <span style="color:#ae81ff">staple_initdb.sql</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">bootstrap-script</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">volumes</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-db-data</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">persistentVolumeClaim</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">claimName</span>: <span style="color:#ae81ff">do-storage-staple-db</span>
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">bootstrap-script</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">configMap</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-initdb-script</span>
</span></span></code></pre></div><p>Note the two volume mounts.</p>
<p>The first one makes sure that our data isn&rsquo;t lost when the database pod itself restarts. It creates a mount
to a persistent volume which is defined a few lines below by <code>persistentVolumeClaim</code>. <code>subPath</code> is important
in this case otherwise you&rsquo;ll end up with a lost&amp;found folder.</p>
<p>The second mount is a postgres specific initialization file. Postgres will run that sql file when it
starts up. I&rsquo;m using it to create my application&rsquo;s schema.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">database</span> staples;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> users (email varchar(<span style="color:#ae81ff">255</span>), password text, confirm_code text, max_staples int);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> staples (name varchar(<span style="color:#ae81ff">255</span>), id serial, content text, created_at <span style="color:#66d9ef">timestamp</span>, archived bool, user_email varchar(<span style="color:#ae81ff">255</span>));
</span></span></code></pre></div><p>And it comes from a configmap which looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">ConfigMap</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-initdb-script</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">data</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">staple_initdb.sql</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">create table users (email varchar(255), password text, confirm_code text, max_staples int);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">create table staples (name varchar(255), id serial, content text, created_at timestamp, archived bool, user_email varchar(255));</span>
</span></span></code></pre></div><h3 id="network-policy">Network Policy<a hidden class="anchor" aria-hidden="true" href="#network-policy">#</a></h3>
<p>Network policies are important if you value your privacy. They restrict a PODs communication to a certain namespace
OR even to between applications only. By default I like to deny all traffic and then slowly open the valve until everything works.</p>
<p><img alt="Szaffi" loading="lazy" src="/img/kube/szaffi.png">
Kudos if you know who this is. (mind my terrible drawing capabilities)</p>
<p>We&rsquo;ll use a basic network policy which will restrict the DB to talk to anything BUT the backend. Nothing else
will be able to talk to this Pod.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">networking.k8s.io/v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">NetworkPolicy</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-db-network-policy</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">podSelector</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">matchLabels</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple-db</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">policyTypes</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#ae81ff">Ingress</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#ae81ff">Egress</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ingress</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">from</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">podSelector</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">matchLabels</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">protocol</span>: <span style="color:#ae81ff">TCP</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">port</span>: <span style="color:#ae81ff">5432</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">egress</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">to</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">podSelector</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">matchLabels</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">protocol</span>: <span style="color:#ae81ff">TCP</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">port</span>: <span style="color:#ae81ff">5432</span>
</span></span></code></pre></div><p>The important bit here is the <code>podSelector</code> part. The label will be the label used by the application deployment.
This will restrict the Pod&rsquo;s incoming and outgoing traffic to that of the application Pod including denying internet
traffic.</p>
<h3 id="pvc">PVC<a hidden class="anchor" aria-hidden="true" href="#pvc">#</a></h3>
<p>The persistent volume claim definition is straight forward:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">PersistentVolumeClaim</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">do-storage-staple-db</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">accessModes</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#ae81ff">ReadWriteOnce</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">resources</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">requests</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">storage</span>: <span style="color:#ae81ff">10Gi</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">storageClassName</span>: <span style="color:#ae81ff">do-block-storage</span>
</span></span></code></pre></div><p>10 gigs should be enough anything.</p>
<p><img alt="Gates" loading="lazy" src="/img/kube/gates.png"></p>
<h3 id="service">Service<a hidden class="anchor" aria-hidden="true" href="#service">#</a></h3>
<p>The service will expose the database deployment to our cluster.</p>
<p>Our service is fairly basic:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-db-service</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">port</span>: <span style="color:#ae81ff">5432</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple-db</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">clusterIP</span>: <span style="color:#ae81ff">None</span>
</span></span></code></pre></div><p>That&rsquo;s done with the database. Next up is the backend.</p>
<h2 id="the-backend">The backend<a hidden class="anchor" aria-hidden="true" href="#the-backend">#</a></h2>
<p>The backend itself is written in a way that it doesn&rsquo;t require a persistent storage so
we can skip that part. It only needs three pieces. A secret, a deployment definition and the
service exposing the deployment.</p>
<h3 id="secret-1">Secret<a hidden class="anchor" aria-hidden="true" href="#secret-1">#</a></h3>
<p>First, we create a secret which contains Mailgun credentials.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Secret</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-mg-creds</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">data</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">MG_DOMAIN</span>: <span style="color:#ae81ff">cGFzc3dvcmQxMjM=</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">MG_API_KEY</span>: <span style="color:#ae81ff">cGFzc3dvcmQxMjM=</span>
</span></span></code></pre></div><h3 id="database-connection">Database connection<a hidden class="anchor" aria-hidden="true" href="#database-connection">#</a></h3>
<p>The connection settings are handled through the same secret which is used to spin up the DB itself.
We have to only mount that here too and we are good.</p>
<h3 id="deployment-1">Deployment<a hidden class="anchor" aria-hidden="true" href="#deployment-1">#</a></h3>
<p>Which brings us to the deployment. This is a bit more involved.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">apps/v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Deployment</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-app</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">matchLabels</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">template</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">app.kubernetes.io/instance</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">image</span>: <span style="color:#ae81ff">skarlso/staple:v0.1.0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">imagePullPolicy</span>: <span style="color:#ae81ff">IfNotPresent</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">resources</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">requests</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">memory</span>: <span style="color:#e6db74">&#34;500Mi&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">cpu</span>: <span style="color:#e6db74">&#34;250m&#34;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">limits</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">memory</span>: <span style="color:#e6db74">&#34;1000Mi&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">cpu</span>: <span style="color:#e6db74">&#34;500m&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">env</span>:
</span></span><span style="display:flex;"><span>          - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">POD_NAMESPACE</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">valueFrom</span>:
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">fieldRef</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">fieldPath</span>: <span style="color:#ae81ff">metadata.namespace</span>
</span></span><span style="display:flex;"><span>          - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">DB_PASSWORD</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">valueFrom</span>:
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">secretKeyRef</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-db-password</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">key</span>: <span style="color:#ae81ff">POSTGRES_PASSWORD</span>
</span></span><span style="display:flex;"><span>          - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">MG_DOMAIN</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">valueFrom</span>:
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">secretKeyRef</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-mg-creds</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">key</span>: <span style="color:#ae81ff">MG_DOMAIN</span>
</span></span><span style="display:flex;"><span>          - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">MG_API_KEY</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">valueFrom</span>:
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">secretKeyRef</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-mg-creds</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">key</span>: <span style="color:#ae81ff">MG_API_KEY</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">args</span>:
</span></span><span style="display:flex;"><span>          - --<span style="color:#ae81ff">staple-db-hostname=staple-db-service.cronohub.svc.cluster.local:5432</span>
</span></span><span style="display:flex;"><span>          - --<span style="color:#ae81ff">staple-db-username=staple</span>
</span></span><span style="display:flex;"><span>          - --<span style="color:#ae81ff">staple-db-database=staple</span>
</span></span><span style="display:flex;"><span>          - --<span style="color:#ae81ff">staple-db-password=$(DB_PASSWORD)</span>
</span></span><span style="display:flex;"><span>          - --<span style="color:#ae81ff">mg-domain=$(MG_DOMAIN)</span>
</span></span><span style="display:flex;"><span>          - --<span style="color:#ae81ff">mg-api-key=$(MG_API_KEY)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-port</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">9998</span>
</span></span></code></pre></div><p>There are a few important points here and I won&rsquo;t explain them all, like the resource restrictions,
which you should be familiar with by now. I&rsquo;m using a mix of 12factor app&rsquo;s environment configuration
and command line arguments for the application configuration. The app itself is not using os.Environ
but the args.</p>
<p>The args point to the cluster local dns of the database, some db settings, and the mailgun credentials.</p>
<p>It also exposes the container port 9998 which is Echo&rsquo;s default port.</p>
<p>Now all we need is the service.</p>
<h3 id="service-1">Service<a hidden class="anchor" aria-hidden="true" href="#service-1">#</a></h3>
<p>Without much fanfare:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-service</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app.kubernetes.io/instance</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app.kubernetes.io/instance</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">service-port</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">port</span>: <span style="color:#ae81ff">9998</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">targetPort</span>: <span style="color:#ae81ff">staple-port</span>
</span></span></code></pre></div><p>And with this, the backend is done.</p>
<h2 id="the-frontend">The frontend<a hidden class="anchor" aria-hidden="true" href="#the-frontend">#</a></h2>
<p>The frontend, similarly to the backend, does not require a persistent volume. We can skip that one too.</p>
<p>In fact it only needs two things, a deployment and a service, and that&rsquo;s all. It uses serve to host the
static files. Honestly, that could also be a Go application serving the static content or anything
that can serve static files.</p>
<h3 id="deployment-2">Deployment<a hidden class="anchor" aria-hidden="true" href="#deployment-2">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">apps/v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Deployment</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-frontend</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple-frontend</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">matchLabels</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple-frontend</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">template</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple-frontend</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">staple-frontend</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">app.kubernetes.io/instance</span>: <span style="color:#ae81ff">staple-frontend</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-frontend</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">image</span>: <span style="color:#ae81ff">skarlso/staple-frontend:v0.0.9</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">imagePullPolicy</span>: <span style="color:#ae81ff">IfNotPresent</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">resources</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">requests</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">memory</span>: <span style="color:#e6db74">&#34;500Mi&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">cpu</span>: <span style="color:#e6db74">&#34;250m&#34;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">limits</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">memory</span>: <span style="color:#e6db74">&#34;1000Mi&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">cpu</span>: <span style="color:#e6db74">&#34;500m&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">env</span>:
</span></span><span style="display:flex;"><span>          - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">POD_NAMESPACE</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">valueFrom</span>:
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">fieldRef</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">fieldPath</span>: <span style="color:#ae81ff">metadata.namespace</span>
</span></span><span style="display:flex;"><span>          - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">REACT_APP_STAPLE_DEV_HOST</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">value</span>: <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-front</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">5000</span>
</span></span></code></pre></div><h3 id="service-2">Service<a hidden class="anchor" aria-hidden="true" href="#service-2">#</a></h3>
<p>And the service:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-front-service</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple-frontend</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">staple-frontend</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app.kubernetes.io/instance</span>: <span style="color:#ae81ff">staple-frontend</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple-frontend</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">staple-frontend</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app.kubernetes.io/instance</span>: <span style="color:#ae81ff">staple-frontend</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-front</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">port</span>: <span style="color:#ae81ff">5000</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">targetPort</span>: <span style="color:#ae81ff">staple-front</span>
</span></span></code></pre></div><p>And with that the backend and frontend are wired together and ready to receive traffic.</p>
<p>All pods should be up and running without problems at this point. If you have any trouble deploying
things, please don&rsquo;t hesitate to leave a question in the comments.</p>
<h2 id="ingress">Ingress<a hidden class="anchor" aria-hidden="true" href="#ingress">#</a></h2>
<p>Fantastic. Now, our application is running. We just need to expose it and route traffic to it.
The backend has the api route <code>/rest/api/v1/</code>. The frontend has the route syntax <code>/login</code>, <code>/register</code>
and a bunch of others. The key here is that all of them are under the same domain name but based on the URI
we need to direct one request to the backend the other to the frontend.</p>
<p>This is done via nginx&rsquo;s routing logic using regex. In an nginx config this would be the <code>location</code> part.
It&rsquo;s imperative that the order of the routing is from more specific towards more general Because we need to catch
the specific URIs first.</p>
<h3 id="ingress-resource">Ingress Resource<a hidden class="anchor" aria-hidden="true" href="#ingress-resource">#</a></h3>
<p>To do this, we will create something called an <a href="https://docs.nginx.com/nginx-ingress-controller/configuration/ingress-resources/">Ingress Resource</a>.
Note that this is Nginx&rsquo;s ingress resource and not Kubernetes&rsquo;. There is a difference.</p>
<p>I suggest reading up on that link about the ingress resource because it reads quite well and will explain how it
works and fits into the Kubernetes environment.</p>
<p>Got it? Good. We&rsquo;ll create one for <code>staple.app</code> domain:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">extensions/v1beta1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Ingress</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-app-ingress</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">annotations</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">kubernetes.io/ingress.class</span>: <span style="color:#e6db74">&#34;nginx&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">cert-manager.io/cluster-issuer</span>: <span style="color:#e6db74">&#34;letsencrypt-prod&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">cert-manager.io/acme-challenge-type</span>: <span style="color:#ae81ff">http01</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">nginx.ingress.kubernetes.io/rewrite-target</span>: <span style="color:#ae81ff">/$1</span> <span style="color:#75715e"># this is important</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">tls</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">hosts</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#ae81ff">staple.app</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">secretName</span>: <span style="color:#ae81ff">staple-app-tls</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">rules</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">host</span>: <span style="color:#ae81ff">staple.app</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">http</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">paths</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">backend</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">serviceName</span>: <span style="color:#ae81ff">staple-service</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">servicePort</span>: <span style="color:#ae81ff">ss-port</span> <span style="color:#75715e"># 9998</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/(rest/api/1.*)</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">host</span>: <span style="color:#ae81ff">staple.app</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">http</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">paths</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">backend</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">serviceName</span>: <span style="color:#ae81ff">staple-front-service</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">servicePort</span>: <span style="color:#ae81ff">sfs-port</span> <span style="color:#75715e"># 5000</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/(.*)</span>
</span></span></code></pre></div><p>Let&rsquo;s take a look at what&rsquo;s going on here. The first thing to catch the eye are the annotations.
These are configuration settings for nginx, cert-manager and Kubernetes.
We have the cluster issuer&rsquo;s name. The challenge type, which we decided should be http01,
and the most important part, the rewrite-target setting. This will use the first capture group
as a base after the host.</p>
<p>With this rewrite rule in place, the <code>paths</code> values need to provide a capture group. The first in line will see
everything that goes to the urls like: <code>staple.app/rest/api/1/token</code>, <code>staple.app/rest/api/1/staples</code>,
<code>staple.app/rest/api/1/user</code>, etc. The first part of the url is the host <code>staple.app</code>, second part is <code>/(rest/api/1/.*)</code>
for which the result is that group number one ($1) will be <code>rest/api/1/token</code>. Nginx now sees that we
have a backend route for that and will send this URI along to the service. Our service picks it up
and will match that URI to the router configuration.</p>
<p><img alt="Regex" loading="lazy" src="/img/kube/regex.png"></p>
<p>If there is a request like, <code>staple.app/login</code>, which is our frontend&rsquo;s job to pick up, the first rule
will not catch it because the regex isn&rsquo;t matching, so it falls through to the second one, which
is the frontend service that is using a &ldquo;catch all&rdquo; regex. Like ip tables, we go from
specific to more general.</p>
<h1 id="ending-words">Ending words<a hidden class="anchor" aria-hidden="true" href="#ending-words">#</a></h1>
<p>And that&rsquo;s it. If everything works correctly, then the certificate service wired up the https certs and
we should be able ping the rest endpoint under <code>https://staple.app/rest/api/1/token</code> and log in to the app
in the browser using <code>https://staple.app</code>.</p>
<p>Stay tuned for the second part where we&rsquo;ll scale the thing up!</p>
<p>Thanks for reading!
Gergely.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://skarlso.github.io/2021/02/01/readers-digest/">
    <span class="title">« Prev</span>
    <br>
    <span>Reader&#39;s Digest 2021-01</span>
  </a>
  <a class="next" href="https://skarlso.github.io/2020/05/11/good-code-reviews/">
    <span class="title">Next »</span>
    <br>
    <span>How to do a good code review</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://skarlso.github.io/">Ramblings of a cloud engineer</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
