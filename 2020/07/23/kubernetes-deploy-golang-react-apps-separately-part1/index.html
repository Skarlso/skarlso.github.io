<!DOCTYPE html>
<html lang="">
    <head>
    <meta charset="UTF-8" />

    <meta name="generator" content="Hugo 0.83.1" /><meta name="theme-color" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <meta name="format-detection" content="telephone=no, date=no, address=no, email=no" />
    
    <meta http-equiv="Cache-Control" content="no-transform" />
    
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <title>How to deploy a Go (Golang) backend with a React frontend separately on Kubernetes - Part One | Ramblings of a cloud engineer</title>

    <link rel="stylesheet" href="/css/meme.min.css" />

    
    
        <script src="/js/meme.min.js"></script>

    

    

    <meta name="author" content="hannibal" /><meta name="description" content="Intro Welcome. This is a longer post about how to deploy a Go backend with a React frontend on Kubernetes as separate entities. Instead of the usual compiled together single binary Go application, we are going to separate the two. Why? Because usually a React frontend is just a “static” SPA app with very little requirements in terms of resources, while the Go backend does most of the leg work, requiring a lot more resources." />

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="" />
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-title" content="Ramblings of a cloud engineer" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="application-name" content="Ramblings of a cloud engineer" />
    <meta name="msapplication-starturl" content="../../../../" />
    <meta name="msapplication-TileColor" content="" />
    <meta name="msapplication-TileImage" content="../../../../icons/mstile-150x150.png" />
    <link rel="manifest" href="/manifest.json" />

    
    

    
    <link rel="canonical" href="https://skarlso.github.io/2020/07/23/kubernetes-deploy-golang-react-apps-separately-part1/" />
    

    
    
        <link rel="preconnect" href="https://www.google-analytics.com" crossorigin />

        


    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-69463020-2"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-69463020-2');
    </script>




    
    

    
</head>

    <body>
        <div class="container">
            



            
                
                
                
            
            
    <main class="main single" id="main">
    <div class="main-inner">

        

        <article class="content post h-entry" data-align="default" data-type="post">

            <h1 class="post-title p-name">How to deploy a Go (Golang) backend with a React frontend separately on Kubernetes - Part One</h1>

            

            

            

            <div class="post-body e-content">
                <h1 id="intro">Intro</h1>
<p>Welcome. This is a longer post about how to deploy a Go backend with a React frontend
on Kubernetes as separate entities. Instead of the usual compiled together single binary Go
application, we are going to separate the two. Why? Because usually a React frontend is just a &ldquo;static&rdquo;
SPA app with very little requirements in terms of resources, while the Go backend does most of the
leg work, requiring a lot more resources.</p>
<p>Part two of this will contain scaling, utilization configuration, health probes, readiness probes,
and how to make sure our application can run multiple instances without stepping on each other&rsquo;s toes.</p>
<p><em>Note</em>: This isn&rsquo;t going to be a Kubernetes guide. Some knowledge is assumed.</p>
<h2 id="summary">Summary</h2>
<p><img src="/img/kube/short-version.png" alt="Give me the short version"></p>
<p>This post details a complex setup of an infrastructure with a second part coming on scaling and how to make
your application scalable in the first place by doing idempotent transactions or dealing with locking and
several instances of the same application not stepping on each other&rsquo;s foot.</p>
<p>This, part one, details how to deploy traditional REST + Frontend based application in Go + React, but not bundled
together as a single binary, instead having the backend separate from the frontend. They key in doing so is explained
at the <a href="#ingress">Ingress</a> section when talking about routing specific URIs to the backend and frontend services.</p>
<p>If you are familiar with Kubernetes and infrastructure setup, feel free to skip ahead to that section. Otherwise, enjoy
the drawings or the writing or both.</p>
<h2 id="technology">Technology</h2>
<p>The SPA app will be handled by <a href="https://www.npmjs.com/package/serve">Serve</a> while the Go backend
will use <a href="https://echo.labstack.com/">Echo</a>. The database will be Postgres.</p>
<p>We are going to apply some best practices using Network Policies to cordon off traffic that we don&rsquo;t
want to go outside.</p>
<p>We will set up HTTPS using cert-manager and let&rsquo;s encrypt. We&rsquo;ll be using nginx as ingress
provider.</p>
<h2 id="code">Code</h2>
<p><img src="/img/kube/architect.png" alt="Let me show you the code"></p>
<p>All, or most of the code, including the application can be found here:</p>
<p><a href="https://github.com/staple-org">Staple</a>. The application is a simple reading list manager with
user handling, email sending and lots of database access.</p>
<p>Let&rsquo;s get to it then!</p>
<h2 id="kubernetes-provider">Kubernetes Provider</h2>
<p><img src="/img/kube/audition.png" alt="Difficult Choice"></p>
<p>Let&rsquo;s start with the obvious one. Where do you would like to create your Kubernetes cluster?</p>
<p>There are four major providers now-a-days. AWS <a href="https://aws.amazon.com/eks/">EKS</a>, GCP <a href="https://cloud.google.com/kubernetes-engine">GKE</a>,
Azure <a href="https://azure.microsoft.com/en-us/services/kubernetes-service/">AKS</a> and DigitalOcean <a href="https://www.digitalocean.com/products/kubernetes/">DKE</a>.
Personally, I prefer DO because, it&rsquo;s a lot cheaper than the others. The downside is that DO only
provides ReadWriteOnce persistent volumes. This gets to be a problem when we are trying to update
and the new Pod can&rsquo;t mount the volume because it&rsquo;s already taken by the existing one. This can be
solved by a good ol NFS instance. But that&rsquo;s another story.</p>
<p>AWS' was late to the party and their solution is quite fragile and the API is terrible. GCP is best in terms
of technicalities, api, handling, and updates. Azure is surprisingly good, however, the documentation is
most of the times out of date or even plain incorrect at some places.</p>
<h2 id="setup-basics">Setup Basics</h2>
<p><img src="/img/kube/owl.jpg" alt="Owl"></p>
<p>To setup your Kubernetes instance, follow DigitalOcean&rsquo;s Kubernetes Getting Started guide. It&rsquo;s really simple.
When you have access to the cluster via kubectl I highly recommend using this tool: <a href="https://github.com/derailed/k9s">k9s</a>.</p>
<p>It&rsquo;s a flexible and quite handy tool for quick observations, logs, shells to pods, edits and generally following what&rsquo;s
happening to your cluster.</p>
<p>Now that we are all set with our own little cluster, it&rsquo;s time to have some people move in. First, we are going to
install cert-manager.</p>
<p><em>Note</em>: I&rsquo;m not going to use Helm because I think it&rsquo;s unnecessary in this setting. We aren&rsquo;t going to install
these things in a highly configurable way and updating with helm is a pain in the butt. For example, for cert-manager
the update with helm takes several steps, whilst updating with a plain yaml file is just applying the next version
of the yaml file.</p>
<p>I&rsquo;m not going to explain how to install cert-manager or nginx. I&rsquo;ll link to their respective guides because frankly, they
are simple to follow and work out of the box.</p>
<p>To install nginx, simply apply the yaml file located here: <a href="https://kubernetes.github.io/ingress-nginx/deploy/#digital-ocean">DigitalOcean Nginx</a>.</p>
<p>To install cert-manager follow this guide: <a href="https://cert-manager.io/docs/installation/kubernetes/">https://cert-manager.io/docs/installation/kubernetes/</a>.
Follow the regular manifest install part, then ignore the Helm part and proceed with verification and then install
your issuer. I used a simple ACME/http01 issuer from here: <a href="https://cert-manager.io/docs/configuration/acme/http01/">https://cert-manager.io/docs/configuration/acme/http01/</a></p>
<p><em>Note</em>: That acme configuration contains the <strong>staging</strong> url. This is to test that things are working. Once you are
sure that everything is wired up correctly, switch that url to this one:
<code>https://acme-v02.api.letsencrypt.org/directory</code> -&gt; prod url. For example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">cert-manager.io/v1alpha2</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">ClusterIssuer</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">letsencrypt-prod</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">acme</span>:
    <span style="color:#75715e"># The ACME server URL</span>
    <span style="color:#f92672">server</span>: <span style="color:#ae81ff">https://acme-v02.api.letsencrypt.org/directory</span>
    <span style="color:#75715e"># Email address used for ACME registration</span>
    <span style="color:#f92672">email</span>: <span style="color:#ae81ff">your@email.com</span>
    <span style="color:#75715e"># Name of a secret used to store the ACME account private key</span>
    <span style="color:#f92672">privateKeySecretRef</span>:
      <span style="color:#f92672">name</span>: <span style="color:#ae81ff">letsencrypt-prod</span>
    <span style="color:#75715e"># Enable the HTTP-01 challenge provider</span>
    <span style="color:#f92672">solvers</span>:
      - <span style="color:#f92672">http01</span>:
          <span style="color:#f92672">ingress</span>:
            <span style="color:#f92672">class</span>: <span style="color:#ae81ff">nginx</span>
</code></pre></div><p><em>Note</em>: I&rsquo;m using a ClusterIssuer because I have multiple domains and multiple namespaces.</p>
<p>That&rsquo;s it. Cert-manager and nginx should be up and running. Later on, we will create our own
ingress rules.</p>
<h2 id="domain">Domain</h2>
<p>Next, you&rsquo;ll need a domain to bind too. There are a gazillion domain providers out there like
no-ip, GoDaddy, HostGator, Shopify and so on. Choose one which is available to you or has the best
prices.</p>
<p>There are some good guides on how to choose a domain and where to create it.
For example: <a href="https://domains.google/learning-center/5-things-to-watch-out-for-when-buying-a-domain/">5 things to watch out for when buying a domain</a>.</p>
<h1 id="the-application">The application</h1>
<p>Alright, let&rsquo;s put together the application.</p>
<p><img src="/img/kube/assemble.png" alt="Assemble"></p>
<h2 id="structure">Structure</h2>
<p>Every piece of our infrastructure will be laid out in yaml files. I believe in infrastructure as code.
If you run a command you will most likely forget about it, unless it&rsquo;s logged and / or is replayable.</p>
<p>This is the structure I&rsquo;m using:</p>
<pre><code>.
├── LICENSE
├── README.md
├── certificate_request
│   └── certificate_request.yml
├── configmaps
│   └── staple_initdb_script.yaml
├── database
│   ├── staple_db_deployment.yaml
│   ├── staple_db_network_policy.yaml
│   ├── staple_db_pvc.yaml
│   └── staple_db_service.yaml
├── namespace
│   └── staple_namespace.yaml
├── primer.sql
├── rbac
├── secrets
│   ├── staple_db_password.yaml
│   └── staple_mg_creds.yaml
├── staple-backend
│   ├── staple_deployment.yaml
│   └── staple_service.yaml
└── staple-frontend
    ├── staple_deployment.yaml
    └── staple_service.yaml
</code></pre><p>One other possible combination is, if you have multiple applications:</p>
<pre><code>.
├── README.md
├── applications
│   ├── confluence
│   │   ├── db
│   │   │   ├── db_deployment.yaml
│   │   │   └── db_service.yaml
│   │   ├── deployment
│   │   │   └── deployment.yaml
│   │   ├── pvc
│   │   │   └── confluence_app_pvc.yaml
│   │   └── service
│   │       └── service.yaml
│   ├── gitea
│   │   ├── config
│   │   │   ├── app.ini
│   │   │   └── gitea_config_map.yaml
│   │   ├── db
│   │   │   ├── gitea_db_deployment.yaml
│   │   │   ├── gitea_db_network_policy.yaml
│   │   │   ├── gitea_db_pvc.yaml
│   │   │   └── gitea_db_service.yaml
│   │   ├── deployment
│   │   │   └── gitea_deployment.yaml
│   │   ├── pvc
│   │   │   └── gitea_app_pvc.yaml
│   │   └── service
│   │       └── gitea_service.yaml
├── cronjobs
│   ├── cronjob1
│   │   ├── Dockerfile
│   │   ├── README.md
│   │   ├── go.mod
│   │   ├── go.sum
│   │   ├── cron.yaml
│   │   └── main.go
├── ingress
│   ├── example1
│   │   ├── example1_ingress_resource.yaml
│   │   └── gitea_ssh_configmap.yaml
│   ├── example2
│   │   └── example2_ingress_resource.yaml
│   ├── lets-encrypt-issuer.yaml
│   └── nginx
│       ├── nginx-ingress-controller-deployment.yaml
│       └── nginx-ingress-controller-service.yaml
└── namespaces
    ├── example1_namespace.yaml
    ├── example2_namespace.yaml
</code></pre><h2 id="namespace">Namespace</h2>
<p>Before we begin, we&rsquo;ll create a namespace for our application to properly partition all our entities.</p>
<p>To create a namespace we&rsquo;ll use this yaml <code>example_namespace.yaml</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Namespace</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">example</span>
</code></pre></div><p>Apply this with <code>kubectl -f apply example_namespace.yaml</code>.</p>
<h2 id="the-database">The Database</h2>
<p>Deploying a Postgres database on Kubernetes is actually really easy. You need five things to have a basic, but
relatively secure installation.</p>
<h3 id="secret">Secret</h3>
<p>The secret contains our password and our database user. In postgres, if you define a user using <code>POSTGRES_USER</code>
postgres will create the user and a database with the user&rsquo;s name. This could come from Vault too, but
the Kubernetes secret is usually enough since it should be a closed environment anyways. But for important information
I would definitely use an admission policy and some vault secret goodness. (Maybe another post?)</p>
<p>Our secret looks like this:
database_secret.yaml</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Secret</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-db-password</span>
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
<span style="color:#f92672">data</span>:
  <span style="color:#f92672">POSTGRES_PASSWORD</span>: <span style="color:#ae81ff">cGFzc3dvcmQxMjM=</span>
  <span style="color:#75715e"># This creates a user and a db with the same name.</span>
  <span style="color:#f92672">POSTGRES_USER</span>: <span style="color:#ae81ff">c3RhcGxl</span>
</code></pre></div><p>To generate the base64 code for a password and a user, use:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">echo -n <span style="color:#e6db74">&#34;password123&#34;</span> | base64
echo -n <span style="color:#e6db74">&#34;username&#34;</span> | base64
</code></pre></div><p>&hellip;and paste the result in the respective fields. Once done, apply with <code>kubectl -f apply database_secret.yaml</code>.</p>
<h3 id="deployment">Deployment</h3>
<p>The deployment which configures our database. Looks something like this (database_deployment.yaml):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">apps/v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Deployment</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-db</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">1</span>
  <span style="color:#f92672">selector</span>:
    <span style="color:#f92672">matchLabels</span>:
      <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple-db</span>
  <span style="color:#f92672">template</span>:
    <span style="color:#f92672">metadata</span>:
      <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-db</span>
      <span style="color:#f92672">labels</span>:
        <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple-db</span>
    <span style="color:#f92672">spec</span>:
      <span style="color:#f92672">containers</span>:
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">postgres</span>
        <span style="color:#f92672">image</span>: <span style="color:#ae81ff">postgres:11</span>
        <span style="color:#f92672">env</span>:
          - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">POSTGRES_USER</span>
            <span style="color:#f92672">value</span>: <span style="color:#ae81ff">staple</span>
          - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">POSTGRES_PASSWORD</span>
            <span style="color:#f92672">valueFrom</span>:
              <span style="color:#f92672">secretKeyRef</span>:
                <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-db-password</span>
                <span style="color:#f92672">key</span>: <span style="color:#ae81ff">POSTGRES_PASSWORD</span>
        <span style="color:#f92672">volumeMounts</span>:
        - <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/var/lib/postgresql/data</span>
          <span style="color:#f92672">subPath</span>: <span style="color:#ae81ff">data</span> <span style="color:#75715e"># important so it gets mounted correctly</span>
          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-db-data</span>
        - <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/docker-entrypoint-initdb.d/staple_initdb.sql</span>
          <span style="color:#f92672">subPath</span>: <span style="color:#ae81ff">staple_initdb.sql</span>
          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">bootstrap-script</span>
      <span style="color:#f92672">volumes</span>:
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-db-data</span>
          <span style="color:#f92672">persistentVolumeClaim</span>:
            <span style="color:#f92672">claimName</span>: <span style="color:#ae81ff">do-storage-staple-db</span>
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">bootstrap-script</span>
          <span style="color:#f92672">configMap</span>:
            <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-initdb-script</span>
</code></pre></div><p>Note the two volume mounts.</p>
<p>The first one makes sure that our data isn&rsquo;t lost when the database pod itself restarts. It creates a mount
to a persistent volume which is defined a few lines below by <code>persistentVolumeClaim</code>. <code>subPath</code> is important
in this case otherwise you&rsquo;ll end up with a lost&amp;found folder.</p>
<p>The second mount is a postgres specific initialization file. Postgres will run that sql file when it
starts up. I&rsquo;m using it to create my application&rsquo;s schema.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">database</span> staples;
<span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> users (email varchar(<span style="color:#ae81ff">255</span>), password text, confirm_code text, max_staples int);
<span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> staples (name varchar(<span style="color:#ae81ff">255</span>), id serial, content text, created_at <span style="color:#66d9ef">timestamp</span>, archived bool, user_email varchar(<span style="color:#ae81ff">255</span>));
</code></pre></div><p>And it comes from a configmap which looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">ConfigMap</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-initdb-script</span>
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
  <span style="color:#f92672">labels</span>:
    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple</span>
<span style="color:#f92672">data</span>:
  <span style="color:#f92672">staple_initdb.sql</span>:
    <span style="color:#ae81ff">create table users (email varchar(255), password text, confirm_code text, max_staples int);</span>
    <span style="color:#ae81ff">create table staples (name varchar(255), id serial, content text, created_at timestamp, archived bool, user_email varchar(255));</span>
</code></pre></div><h3 id="network-policy">Network Policy</h3>
<p>Network policies are important if you value your privacy. They restrict a PODs communication to a certain namespace
OR even to between applications only. By default I like to deny all traffic and then slowly open the valve until everything works.</p>
<p><img src="/img/kube/szaffi.png" alt="Szaffi">
Kudos if you know who this is. (mind my terrible drawing capabilities)</p>
<p>We&rsquo;ll use a basic network policy which will restrict the DB to talk to anything BUT the backend. Nothing else
will be able to talk to this Pod.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">networking.k8s.io/v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">NetworkPolicy</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-db-network-policy</span>
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">podSelector</span>:
    <span style="color:#f92672">matchLabels</span>:
      <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple-db</span>
  <span style="color:#f92672">policyTypes</span>:
  - <span style="color:#ae81ff">Ingress</span>
  - <span style="color:#ae81ff">Egress</span>
  <span style="color:#f92672">ingress</span>:
  - <span style="color:#f92672">from</span>:
    - <span style="color:#f92672">podSelector</span>:
        <span style="color:#f92672">matchLabels</span>:
          <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple</span>
    <span style="color:#f92672">ports</span>:
    - <span style="color:#f92672">protocol</span>: <span style="color:#ae81ff">TCP</span>
      <span style="color:#f92672">port</span>: <span style="color:#ae81ff">5432</span>
  <span style="color:#f92672">egress</span>:
  - <span style="color:#f92672">to</span>:
    - <span style="color:#f92672">podSelector</span>:
        <span style="color:#f92672">matchLabels</span>:
          <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple</span>
    <span style="color:#f92672">ports</span>:
    - <span style="color:#f92672">protocol</span>: <span style="color:#ae81ff">TCP</span>
      <span style="color:#f92672">port</span>: <span style="color:#ae81ff">5432</span>
</code></pre></div><p>The important bit here is the <code>podSelector</code> part. The label will be the label used by the application deployment.
This will restrict the Pod&rsquo;s incoming and outgoing traffic to that of the application Pod including denying internet
traffic.</p>
<h3 id="pvc">PVC</h3>
<p>The persistent volume claim definition is straight forward:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">PersistentVolumeClaim</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">do-storage-staple-db</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">accessModes</span>:
  - <span style="color:#ae81ff">ReadWriteOnce</span>
  <span style="color:#f92672">resources</span>:
    <span style="color:#f92672">requests</span>:
      <span style="color:#f92672">storage</span>: <span style="color:#ae81ff">10Gi</span>
  <span style="color:#f92672">storageClassName</span>: <span style="color:#ae81ff">do-block-storage</span>
</code></pre></div><p>10 gigs should be enough anything.</p>
<p><img src="/img/kube/gates.png" alt="Gates"></p>
<h3 id="service">Service</h3>
<p>The service will expose the database deployment to our cluster.</p>
<p>Our service is fairly basic:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
<span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-db-service</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">ports</span>:
  - <span style="color:#f92672">port</span>: <span style="color:#ae81ff">5432</span>
  <span style="color:#f92672">selector</span>:
    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple-db</span>
  <span style="color:#f92672">clusterIP</span>: <span style="color:#ae81ff">None</span>
</code></pre></div><p>That&rsquo;s done with the database. Next up is the backend.</p>
<h2 id="the-backend">The backend</h2>
<p>The backend itself is written in a way that it doesn&rsquo;t require a persistent storage so
we can skip that part. It only needs three pieces. A secret, a deployment definition and the
service exposing the deployment.</p>
<h3 id="secret-1">Secret</h3>
<p>First, we create a secret which contains Mailgun credentials.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Secret</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-mg-creds</span>
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
<span style="color:#f92672">data</span>:
  <span style="color:#f92672">MG_DOMAIN</span>: <span style="color:#ae81ff">cGFzc3dvcmQxMjM=</span>
  <span style="color:#f92672">MG_API_KEY</span>: <span style="color:#ae81ff">cGFzc3dvcmQxMjM=</span>
</code></pre></div><h3 id="database-connection">Database connection</h3>
<p>The connection settings are handled through the same secret which is used to spin up the DB itself.
We have to only mount that here too and we are good.</p>
<h3 id="deployment-1">Deployment</h3>
<p>Which brings us to the deployment. This is a bit more involved.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">apps/v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Deployment</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-app</span>
  <span style="color:#f92672">labels</span>:
    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">1</span>
  <span style="color:#f92672">selector</span>:
    <span style="color:#f92672">matchLabels</span>:
      <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple</span>
  <span style="color:#f92672">template</span>:
    <span style="color:#f92672">metadata</span>:
      <span style="color:#f92672">labels</span>:
        <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple</span>
        <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">staple</span>
        <span style="color:#f92672">app.kubernetes.io/instance</span>: <span style="color:#ae81ff">staple</span>
    <span style="color:#f92672">spec</span>:
      <span style="color:#f92672">containers</span>:
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple</span>
        <span style="color:#f92672">image</span>: <span style="color:#ae81ff">skarlso/staple:v0.1.0</span>
        <span style="color:#f92672">imagePullPolicy</span>: <span style="color:#ae81ff">IfNotPresent</span>
        <span style="color:#f92672">resources</span>:
          <span style="color:#f92672">requests</span>:
            <span style="color:#f92672">memory</span>: <span style="color:#e6db74">&#34;500Mi&#34;</span>
            <span style="color:#f92672">cpu</span>: <span style="color:#e6db74">&#34;250m&#34;</span>
          <span style="color:#f92672">limits</span>:
            <span style="color:#f92672">memory</span>: <span style="color:#e6db74">&#34;1000Mi&#34;</span>
            <span style="color:#f92672">cpu</span>: <span style="color:#e6db74">&#34;500m&#34;</span>
        <span style="color:#f92672">env</span>:
          - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">POD_NAMESPACE</span>
            <span style="color:#f92672">valueFrom</span>:
              <span style="color:#f92672">fieldRef</span>:
                <span style="color:#f92672">fieldPath</span>: <span style="color:#ae81ff">metadata.namespace</span>
          - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">DB_PASSWORD</span>
            <span style="color:#f92672">valueFrom</span>:
              <span style="color:#f92672">secretKeyRef</span>:
                <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-db-password</span>
                <span style="color:#f92672">key</span>: <span style="color:#ae81ff">POSTGRES_PASSWORD</span>
          - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">MG_DOMAIN</span>
            <span style="color:#f92672">valueFrom</span>:
              <span style="color:#f92672">secretKeyRef</span>:
                <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-mg-creds</span>
                <span style="color:#f92672">key</span>: <span style="color:#ae81ff">MG_DOMAIN</span>
          - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">MG_API_KEY</span>
            <span style="color:#f92672">valueFrom</span>:
              <span style="color:#f92672">secretKeyRef</span>:
                <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-mg-creds</span>
                <span style="color:#f92672">key</span>: <span style="color:#ae81ff">MG_API_KEY</span>
        <span style="color:#f92672">args</span>:
          - --<span style="color:#ae81ff">staple-db-hostname=staple-db-service.cronohub.svc.cluster.local:5432</span>
          - --<span style="color:#ae81ff">staple-db-username=staple</span>
          - --<span style="color:#ae81ff">staple-db-database=staple</span>
          - --<span style="color:#ae81ff">staple-db-password=$(DB_PASSWORD)</span>
          - --<span style="color:#ae81ff">mg-domain=$(MG_DOMAIN)</span>
          - --<span style="color:#ae81ff">mg-api-key=$(MG_API_KEY)</span>
        <span style="color:#f92672">ports</span>:
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-port</span>
          <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">9998</span>
</code></pre></div><p>There are a few important points here and I won&rsquo;t explain them all, like the resource restrictions,
which you should be familiar with by now. I&rsquo;m using a mix of 12factor app&rsquo;s environment configuration
and command line arguments for the application configuration. The app itself is not using os.Environ
but the args.</p>
<p>The args point to the cluster local dns of the database, some db settings, and the mailgun credentials.</p>
<p>It also exposes the container port 9998 which is Echo&rsquo;s default port.</p>
<p>Now all we need is the service.</p>
<h3 id="service-1">Service</h3>
<p>Without much fanfare:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
<span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-service</span>
  <span style="color:#f92672">labels</span>:
    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple</span>
    <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">staple</span>
    <span style="color:#f92672">app.kubernetes.io/instance</span>: <span style="color:#ae81ff">staple</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">selector</span>:
    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple</span>
    <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">staple</span>
    <span style="color:#f92672">app.kubernetes.io/instance</span>: <span style="color:#ae81ff">staple</span>
  <span style="color:#f92672">ports</span>:
  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">service-port</span>
    <span style="color:#f92672">port</span>: <span style="color:#ae81ff">9998</span>
    <span style="color:#f92672">targetPort</span>: <span style="color:#ae81ff">staple-port</span>
</code></pre></div><p>And with this, the backend is done.</p>
<h2 id="the-frontend">The frontend</h2>
<p>The frontend, similarly to the backend, does not require a persistent volume. We can skip that one too.</p>
<p>In fact it only needs two things, a deployment and a service, and that&rsquo;s all. It uses serve to host the
static files. Honestly, that could also be a Go application serving the static content or anything
that can serve static files.</p>
<h3 id="deployment-2">Deployment</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">apps/v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Deployment</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-frontend</span>
  <span style="color:#f92672">labels</span>:
    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple-frontend</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">1</span>
  <span style="color:#f92672">selector</span>:
    <span style="color:#f92672">matchLabels</span>:
      <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple-frontend</span>
  <span style="color:#f92672">template</span>:
    <span style="color:#f92672">metadata</span>:
      <span style="color:#f92672">labels</span>:
        <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple-frontend</span>
        <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">staple-frontend</span>
        <span style="color:#f92672">app.kubernetes.io/instance</span>: <span style="color:#ae81ff">staple-frontend</span>
    <span style="color:#f92672">spec</span>:
      <span style="color:#f92672">containers</span>:
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-frontend</span>
        <span style="color:#f92672">image</span>: <span style="color:#ae81ff">skarlso/staple-frontend:v0.0.9</span>
        <span style="color:#f92672">imagePullPolicy</span>: <span style="color:#ae81ff">IfNotPresent</span>
        <span style="color:#f92672">resources</span>:
          <span style="color:#f92672">requests</span>:
            <span style="color:#f92672">memory</span>: <span style="color:#e6db74">&#34;500Mi&#34;</span>
            <span style="color:#f92672">cpu</span>: <span style="color:#e6db74">&#34;250m&#34;</span>
          <span style="color:#f92672">limits</span>:
            <span style="color:#f92672">memory</span>: <span style="color:#e6db74">&#34;1000Mi&#34;</span>
            <span style="color:#f92672">cpu</span>: <span style="color:#e6db74">&#34;500m&#34;</span>
        <span style="color:#f92672">env</span>:
          - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">POD_NAMESPACE</span>
            <span style="color:#f92672">valueFrom</span>:
              <span style="color:#f92672">fieldRef</span>:
                <span style="color:#f92672">fieldPath</span>: <span style="color:#ae81ff">metadata.namespace</span>
          - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">REACT_APP_STAPLE_DEV_HOST</span>
            <span style="color:#f92672">value</span>: <span style="color:#e6db74">&#34;&#34;</span>
        <span style="color:#f92672">ports</span>:
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-front</span>
          <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">5000</span>
</code></pre></div><h3 id="service-2">Service</h3>
<p>And the service:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
<span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-front-service</span>
  <span style="color:#f92672">labels</span>:
    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple-frontend</span>
    <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">staple-frontend</span>
    <span style="color:#f92672">app.kubernetes.io/instance</span>: <span style="color:#ae81ff">staple-frontend</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">selector</span>:
    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">staple-frontend</span>
    <span style="color:#f92672">app.kubernetes.io/name</span>: <span style="color:#ae81ff">staple-frontend</span>
    <span style="color:#f92672">app.kubernetes.io/instance</span>: <span style="color:#ae81ff">staple-frontend</span>
  <span style="color:#f92672">ports</span>:
  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-front</span>
    <span style="color:#f92672">port</span>: <span style="color:#ae81ff">5000</span>
    <span style="color:#f92672">targetPort</span>: <span style="color:#ae81ff">staple-front</span>
</code></pre></div><p>And with that the backend and frontend are wired together and ready to receive traffic.</p>
<p>All pods should be up and running without problems at this point. If you have any trouble deploying
things, please don&rsquo;t hesitate to leave a question in the comments.</p>
<h2 id="ingress">Ingress</h2>
<p>Fantastic. Now, our application is running. We just need to expose it and route traffic to it.
The backend has the api route <code>/rest/api/v1/</code>. The frontend has the route syntax <code>/login</code>, <code>/register</code>
and a bunch of others. The key here is that all of them are under the same domain name but based on the URI
we need to direct one request to the backend the other to the frontend.</p>
<p>This is done via nginx&rsquo;s routing logic using regex. In an nginx config this would be the <code>location</code> part.
It&rsquo;s imperative that the order of the routing is from more specific towards more general Because we need to catch
the specific URIs first.</p>
<h3 id="ingress-resource">Ingress Resource</h3>
<p>To do this, we will create something called an <a href="https://docs.nginx.com/nginx-ingress-controller/configuration/ingress-resources/">Ingress Resource</a>.
Note that this is Nginx&rsquo;s ingress resource and not Kubernetes'. There is a difference.</p>
<p>I suggest reading up on that link about the ingress resource because it reads quite well and will explain how it
works and fits into the Kubernetes environment.</p>
<p>Got it? Good. We&rsquo;ll create one for <code>staple.app</code> domain:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">extensions/v1beta1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Ingress</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">staple</span>
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">staple-app-ingress</span>
  <span style="color:#f92672">annotations</span>:
    <span style="color:#f92672">kubernetes.io/ingress.class</span>: <span style="color:#e6db74">&#34;nginx&#34;</span>
    <span style="color:#f92672">cert-manager.io/cluster-issuer</span>: <span style="color:#e6db74">&#34;letsencrypt-prod&#34;</span>
    <span style="color:#f92672">cert-manager.io/acme-challenge-type</span>: <span style="color:#ae81ff">http01</span>
    <span style="color:#f92672">nginx.ingress.kubernetes.io/rewrite-target</span>: <span style="color:#ae81ff">/$1</span> <span style="color:#75715e"># this is important</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">tls</span>:
  - <span style="color:#f92672">hosts</span>:
    - <span style="color:#ae81ff">staple.app</span>
    <span style="color:#f92672">secretName</span>: <span style="color:#ae81ff">staple-app-tls</span>
  <span style="color:#f92672">rules</span>:
  - <span style="color:#f92672">host</span>: <span style="color:#ae81ff">staple.app</span>
    <span style="color:#f92672">http</span>:
      <span style="color:#f92672">paths</span>:
      - <span style="color:#f92672">backend</span>:
          <span style="color:#f92672">serviceName</span>: <span style="color:#ae81ff">staple-service</span>
          <span style="color:#f92672">servicePort</span>: <span style="color:#ae81ff">ss-port</span> <span style="color:#75715e"># 9998</span>
        <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/(rest/api/1.*)</span>
  - <span style="color:#f92672">host</span>: <span style="color:#ae81ff">staple.app</span>
    <span style="color:#f92672">http</span>:
      <span style="color:#f92672">paths</span>:
      - <span style="color:#f92672">backend</span>:
          <span style="color:#f92672">serviceName</span>: <span style="color:#ae81ff">staple-front-service</span>
          <span style="color:#f92672">servicePort</span>: <span style="color:#ae81ff">sfs-port</span> <span style="color:#75715e"># 5000</span>
        <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/(.*)</span>
</code></pre></div><p>Let&rsquo;s take a look at what&rsquo;s going on here. The first thing to catch the eye are the annotations.
These are configuration settings for nginx, cert-manager and Kubernetes.
We have the cluster issuer&rsquo;s name. The challenge type, which we decided should be http01,
and the most important part, the rewrite-target setting. This will use the first capture group
as a base after the host.</p>
<p>With this rewrite rule in place, the <code>paths</code> values need to provide a capture group. The first in line will see
everything that goes to the urls like: <code>staple.app/rest/api/1/token</code>, <code>staple.app/rest/api/1/staples</code>,
<code>staple.app/rest/api/1/user</code>, etc. The first part of the url is the host <code>staple.app</code>, second part is <code>/(rest/api/1/.*)</code>
for which the result is that group number one ($1) will be <code>rest/api/1/token</code>. Nginx now sees that we
have a backend route for that and will send this URI along to the service. Our service picks it up
and will match that URI to the router configuration.</p>
<p><img src="/img/kube/regex.png" alt="Regex"></p>
<p>If there is a request like, <code>staple.app/login</code>, which is our frontend&rsquo;s job to pick up, the first rule
will not catch it because the regex isn&rsquo;t matching, so it falls through to the second one, which
is the frontend service that is using a &ldquo;catch all&rdquo; regex. Like ip tables, we go from
specific to more general.</p>
<h1 id="ending-words">Ending words</h1>
<p>And that&rsquo;s it. If everything works correctly, then the certificate service wired up the https certs and
we should be able ping the rest endpoint under <code>https://staple.app/rest/api/1/token</code> and log in to the app
in the browser using <code>https://staple.app</code>.</p>
<p>Stay tuned for the second part where we&rsquo;ll scale the thing up!</p>
<p>Thanks for reading!
Gergely.</p>

            </div>

            


        </article>

        

        


        


        


        


        


        


        


        


        
    

        
            <div class="load-comments">
                <div id="load-comments">Load Comments?</div>
            </div>
        

        
            <div id="disqus_thread"></div>
        

        

        

        
    



    </div>
</main>


            

            

        </div>
        

        






    

        
            <script>
    function loadComments() {
        if (typeof DISQUS === 'undefined') {
            var disqus_config = function() {
                this.page.url = 'https:\/\/skarlso.github.io\/2020\/07\/23\/kubernetes-deploy-golang-react-apps-separately-part1\/';
                this.page.identifier = '\/2020\/07\/23\/kubernetes-deploy-golang-react-apps-separately-part1\/';
                this.page.title = 'How to deploy a Go (Golang) backend with a React frontend separately on Kubernetes - Part One';
            };
            (function() {
                var d = document, s = d.createElement('script'); s.async = true;
                s.src = 'https://hannibalDisqus.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        } else {
            DISQUS.reset({
                reload: true,
                config: function() {
                    this.page.url = 'https:\/\/skarlso.github.io\/2020\/07\/23\/kubernetes-deploy-golang-react-apps-separately-part1\/';
                    this.page.identifier = '\/2020\/07\/23\/kubernetes-deploy-golang-react-apps-separately-part1\/';
                    this.page.title = 'How to deploy a Go (Golang) backend with a React frontend separately on Kubernetes - Part One';
                }
            });
        }
    }
</script>

        

        

        

        

    










    </body>
</html>
