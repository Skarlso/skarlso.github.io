<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Advent Of Code - Day 12 - Updated | Ramblings of a cloud engineer</title>
<meta name="keywords" content="">
<meta name="description" content="Advent Of Code - Day 12 - Updated A comment from one of my readers prompted me to revise my solution on this trying to do part 2. The suggestions was that instead of using a struct as seen, use int and keep track of the count for small caves that way. I started to do that but got into various problems along the way when I got frustrated with my code, deleted the whole thing and begun again.">
<meta name="author" content="hannibal">
<link rel="canonical" href="https://skarlso.github.io/2021/12/17/aoc-day12-updated/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://skarlso.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://skarlso.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://skarlso.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://skarlso.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://skarlso.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Advent Of Code - Day 12 - Updated" />
<meta property="og:description" content="Advent Of Code - Day 12 - Updated A comment from one of my readers prompted me to revise my solution on this trying to do part 2. The suggestions was that instead of using a struct as seen, use int and keep track of the count for small caves that way. I started to do that but got into various problems along the way when I got frustrated with my code, deleted the whole thing and begun again." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://skarlso.github.io/2021/12/17/aoc-day12-updated/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-17T01:01:00+01:00" />
<meta property="article:modified_time" content="2021-12-17T01:01:00+01:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Advent Of Code - Day 12 - Updated"/>
<meta name="twitter:description" content="Advent Of Code - Day 12 - Updated A comment from one of my readers prompted me to revise my solution on this trying to do part 2. The suggestions was that instead of using a struct as seen, use int and keep track of the count for small caves that way. I started to do that but got into various problems along the way when I got frustrated with my code, deleted the whole thing and begun again."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://skarlso.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Advent Of Code - Day 12 - Updated",
      "item": "https://skarlso.github.io/2021/12/17/aoc-day12-updated/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Advent Of Code - Day 12 - Updated",
  "name": "Advent Of Code - Day 12 - Updated",
  "description": "Advent Of Code - Day 12 - Updated A comment from one of my readers prompted me to revise my solution on this trying to do part 2. The suggestions was that instead of using a struct as seen, use int and keep track of the count for small caves that way. I started to do that but got into various problems along the way when I got frustrated with my code, deleted the whole thing and begun again.",
  "keywords": [
    
  ],
  "articleBody": "Advent Of Code - Day 12 - Updated A comment from one of my readers prompted me to revise my solution on this trying to do part 2. The suggestions was that instead of using a struct as seen, use int and keep track of the count for small caves that way. I started to do that but got into various problems along the way when I got frustrated with my code, deleted the whole thing and begun again. But this lead me to a small, and better code than before which actually worked.\nDay 12 - Part 1 There are a number of things I realized and improved upon. Let’s take them one by one.\nParsing I did this whole convoluted way of parsing the “graph” into an actual graph when I saw two things. First, I don’t need a graph I just need the values. Second, if you don’t need the graph, you don’t have anything to initialize and you can use Go map’s feature of creating default entries for default keys.\nGo maps initialize to value default. For reference types that’s nil. For primitives, whatever the primitives zero value is. Empty string, 0, etc.\nThis lead me to parsing the input such as:\ninput := strings.Split(string(content), \"\\n\") caves := make(map[string][]string) for _, line := range input { var ( a, b string ) split := strings.Split(line, \"-\") a = split[0] b = split[1] caves[a] = append(caves[a], b) caves[b] = append(caves[b], a) } And that’s it. append deals with nil slices and creates the slice if needed. Meaning if the entry doesn’t exist, append will create a new slice for it.\nState I need to keep state of the caves I’m visiting somehow. After reading a bunch of more information on DFS and BFS and listing all paths and all those things I never read otherwise every in my day to day life, I saw, that I for part two, and in fact, for part 1 as well, I need a state which I can refresh based on the current location.\nPreviously, my recursive dfs was doing that with the path passed in. That’s all fine, but I also need now if I ever visited a cave twice. The suggestions of using an int for visited is nice, but somehow, wasn’t working for me, because I kept messing up the subtraction when recursing back. So I decided that I drop the recursing and try to do this iteratively.\nSecond, I also saw in most of the cases I don’t care about the path, I just need a count. I just kept the path for debug to see where my algorithm is going. So I ditched that and just increase a counter.\nTo keep the state I’m using a struct which will have the current value of the cave, the path so far which was travelled from the current location and so far and the fact if I visited this cave before.\ntype cave struct { value string pathSoFar []string twice bool } This allows for a number of things. First, I don’t need to pass around path recursively, I will have a reference to it at the current visited location. Second, I can track the actual state in the cave, like paint the cave if I already saw that one. Once that happens, every other cave will have this value passed around, meaning all other caves will come in with a flag, that hey, I already visited a cave twice before, so I’m not gonna do that again.\nThe Loop No, not the amazon prime series The Loop ( which is fantastic btw ), but the main for loop of this logic. Now that I have my state, I can just do a BFS on this baby. The main loop changes slightly. We now, keep track of caves, not just the values.\nBut it’s super easy. Barely an inconvenience. Oh really? Yeah, you see, we just make our queue have caves. But what about the seen part? This changes as well. Now, because we pass around the path taken so far, we’ll have to look in that path if the neighbor if our current cave is already in the path that has been taken so far for that save.\nJust create a small Contains method ( which will be obsolete after finally go 1.18 comes out with generics and we’ll have the mighty Filter or Search on our side!!!!!! ) like this:\nseen := func(a string, b []string) bool { for _, v := range b { if v == a { return true } } return false } … and then we can look in the path if we met this cave before. What I also realized was that I was turning the cave value into lowercase and checked it that way, when I could have just said that if it matched with the ToLower version of the name it is lower case. :facepalm:. But this is why I’m doing AOC. To learn and evolve. Hopefully, I learned a lot from this day.\nSo the main loop:\ncount := 0 start := cave{ pos: \"start\", pathSoFar: []string{\"start\"}, } queue := []cave{start} var current cave for len(queue) \u003e 0 { current, queue = queue[0], queue[1:] if current.pos == \"end\" { count++ continue } for _, next := range caves[current.pos] { if !seen(next, current.pathSoFar) { path := make([]string, 0) path = append(path, current.pathSoFar...) if strings.ToLower(next) == next { path = append(path, next) } queue = append(queue, cave{ pos: next, pathSoFar: path, }) } } } And that’s it. We print count and we have our number.\nDay 12 - Part 2 Now that we have our state in the loop itself, we just add a new variable to the cave called twice (it was already there but I haven’t used it yet). Our criteria for twice is as follows. If we haven’t seen it yet, we explore it. If it is already in the path so far, from which we came in AND none of the caves so far were visited twice ( which we’ll know because we bring our marker with us during the loop ) we set our cave to visited ( paint it ) and we only take the path so far with us, so we don’t put this guy in the path YET. We’ll eventually do that though on the next time this cave is encountered at which point it will bring twice with it.\nHow does that look like in code?\nstart := cave{ value: \"start\", pathSoFar: []string{\"start\"}, } queue := []cave{start} var current cave for len(queue) \u003e 0 { current, queue = queue[0], queue[1:] if current.value == \"end\" { count++ continue } for _, next := range caves[current.value] { seenThisCaveBefore := seen(next, current.pathSoFar) if !seenThisCaveBefore { path := make([]string, 0) path = append(path, current.pathSoFar...) if strings.ToLower(next) == next { path = append(path, next) } queue = append(queue, cave{ value: next, pathSoFar: path, twice: current.twice, }) } else if seenThisCaveBefore \u0026\u0026 !current.twice \u0026\u0026 !seen(next, []string{\"start\", \"end\"}) { queue = append(queue, cave{ value: next, pathSoFar: current.pathSoFar, twice: true, }) } } } Again, we start off by adding start. Oh, and we don’t do that for start or end. Also realized that I can use seen now as sort of like a check for a value NOT being one of two values instead of a convoluted if structure.\nSo if everything is as before, expect we also take twice with us, and if we’ve seenThisCaveBefore but we haven’t visited any caves twice before ( we take the marker with us during the journey ) and it’s not start or end, we mark it as visited twice, and we add pathSoFar as the current path so far, without adding this cave into it.\nAnd that’s it!\nConclusion This day was somehow difficult on the first run. I couldn’t figure out a nice way to keep track of my journey so far. What helped me eventually was the prompt from my reading and reading various articles about keeping track during a BFS and how listing all paths in a graph work. Which can be a difficult problem especially when there is a circle in the graph. This would probably not work in that case, but we are confident that Eric doesn’t do tricks like that.\nThe repository for all my solutions for AOC 2021 can be found here.\nThank you for reading!\nGergely.\n",
  "wordCount" : "1406",
  "inLanguage": "en",
  "datePublished": "2021-12-17T01:01:00+01:00",
  "dateModified": "2021-12-17T01:01:00+01:00",
  "author":{
    "@type": "Person",
    "name": "hannibal"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://skarlso.github.io/2021/12/17/aoc-day12-updated/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ramblings of a cloud engineer",
    "logo": {
      "@type": "ImageObject",
      "url": "https://skarlso.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://skarlso.github.io" accesskey="h" title="Ramblings of a cloud engineer (Alt + H)">Ramblings of a cloud engineer</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://skarlso.github.io/posts/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Advent Of Code - Day 12 - Updated
    </h1>
    <div class="post-meta"><span title='2021-12-17 01:01:00 +0100 +0100'>December 17, 2021</span>&nbsp;·&nbsp;hannibal

</div>
  </header> 
  <div class="post-content"><h1 id="advent-of-code---day-12---updated">Advent Of Code - Day 12 - Updated<a hidden class="anchor" aria-hidden="true" href="#advent-of-code---day-12---updated">#</a></h1>
<p>A comment from one of my readers prompted me to revise my solution on this trying to do part 2. The suggestions was that
instead of using a <code>struct</code> as seen, use <code>int</code> and keep track of the count for small caves that way. I started to do
that but got into various problems along the way when I got frustrated with my code, deleted the whole thing and begun
again. But this lead me to a small, and better code than before which actually worked.</p>
<h2 id="day-12---part-1">Day 12 - Part 1<a hidden class="anchor" aria-hidden="true" href="#day-12---part-1">#</a></h2>
<p>There are a number of things I realized and improved upon. Let&rsquo;s take them one by one.</p>
<h3 id="parsing">Parsing<a hidden class="anchor" aria-hidden="true" href="#parsing">#</a></h3>
<p>I did this whole convoluted way of parsing the &ldquo;graph&rdquo; into an actual graph when I saw two things. First, I don&rsquo;t need a
graph I just need the values. Second, if you don&rsquo;t need the graph, you don&rsquo;t have anything to initialize and you can use
Go map&rsquo;s feature of creating default entries for default keys.</p>
<p>Go maps initialize to value default. For reference types that&rsquo;s nil. For primitives, whatever the primitives zero value
is. Empty string, <code>0</code>, etc.</p>
<p>This lead me to parsing the input such as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">input</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(string(<span style="color:#a6e22e">content</span>), <span style="color:#e6db74">&#34;\n&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">caves</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>][]<span style="color:#66d9ef">string</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">line</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">input</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>		)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">split</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">line</span>, <span style="color:#e6db74">&#34;-&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">a</span> = <span style="color:#a6e22e">split</span>[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">b</span> = <span style="color:#a6e22e">split</span>[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">caves</span>[<span style="color:#a6e22e">a</span>] = append(<span style="color:#a6e22e">caves</span>[<span style="color:#a6e22e">a</span>], <span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">caves</span>[<span style="color:#a6e22e">b</span>] = append(<span style="color:#a6e22e">caves</span>[<span style="color:#a6e22e">b</span>], <span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>And that&rsquo;s it. <code>append</code> deals with <code>nil</code> slices and creates the slice if needed. Meaning if the entry doesn&rsquo;t exist,
append will create a new slice for it.</p>
<h3 id="state">State<a hidden class="anchor" aria-hidden="true" href="#state">#</a></h3>
<p>I need to keep state of the caves I&rsquo;m visiting somehow. After reading a bunch of more information on DFS and BFS and
listing all paths and all those things I never read otherwise every in my day to day life, I saw, that I for part two,
and in fact, for part 1 as well, I need a state which I can refresh based on the current location.</p>
<p>Previously, my recursive dfs was doing that with the <code>path</code> passed in. That&rsquo;s all fine, but I also need now if I ever
visited a cave twice. The suggestions of using an int for visited is nice, but somehow, wasn&rsquo;t working for me, because I
kept messing up the subtraction when recursing back. So I decided that I drop the recursing and try to do this
iteratively.</p>
<p>Second, I also saw in most of the cases I don&rsquo;t care about the path, I just need a count. I just kept the path for debug
to see where my algorithm is going. So I ditched that and just increase a counter.</p>
<p>To keep the state I&rsquo;m using a <code>struct</code> which will have the current value of the cave, the path so far which was
travelled from the current location and so far and the fact if I visited this cave before.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">cave</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">value</span>     <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pathSoFar</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">twice</span>     <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This allows for a number of things. First, I don&rsquo;t need to pass around path recursively, I will have a reference to it
at the current visited location. Second, I can track the actual state in the cave, like paint the cave if I already saw
that one. Once that happens, every other cave will have this value passed around, meaning all other caves will come in
with a flag, that hey, I already visited a cave twice before, so I&rsquo;m not gonna do that again.</p>
<h3 id="the-loop">The Loop<a hidden class="anchor" aria-hidden="true" href="#the-loop">#</a></h3>
<p>No, not the amazon prime series The Loop ( which is fantastic btw ), but the main for loop of this logic. Now that I
have my state, I can just do a BFS on this baby. The main loop changes slightly. We now, keep track of caves, not just
the values.</p>
<p>But it&rsquo;s super easy. Barely an inconvenience. Oh really? Yeah, you see, we just make our queue have caves. But what
about the <code>seen</code> part? This changes as well. Now, because we pass around the path taken so far, we&rsquo;ll have to look in
that path if the neighbor if our current cave is already in the path that has been taken so far for that save.</p>
<p>Just create a small <code>Contains</code> method ( which will be obsolete after finally go 1.18 comes out with generics and we&rsquo;ll
have the mighty <code>Filter</code> or <code>Search</code> on our side!!!!!! ) like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">seen</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">b</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">a</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>&hellip; and then we can look in the path if we met this cave before. What I also realized was that I was turning the cave
value into lowercase and checked it that way, when I could have just said that if it matched with the ToLower version
of the name it is lower case. :facepalm:. But this is why I&rsquo;m doing AOC. To learn and evolve. Hopefully, I learned a lot
from this day.</p>
<p>So the main loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">count</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cave</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">pos</span>:       <span style="color:#e6db74">&#34;start&#34;</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">pathSoFar</span>: []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;start&#34;</span>},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">queue</span> <span style="color:#f92672">:=</span> []<span style="color:#a6e22e">cave</span>{<span style="color:#a6e22e">start</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">current</span> <span style="color:#a6e22e">cave</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> len(<span style="color:#a6e22e">queue</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">current</span>, <span style="color:#a6e22e">queue</span> = <span style="color:#a6e22e">queue</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">queue</span>[<span style="color:#ae81ff">1</span>:]
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">pos</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;end&#34;</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">count</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">next</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">caves</span>[<span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">pos</span>] {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">seen</span>(<span style="color:#a6e22e">next</span>, <span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">pathSoFar</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">path</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">path</span> = append(<span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">pathSoFar</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">ToLower</span>(<span style="color:#a6e22e">next</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">next</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">path</span> = append(<span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">next</span>)
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">queue</span> = append(<span style="color:#a6e22e">queue</span>, <span style="color:#a6e22e">cave</span>{
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">pos</span>:       <span style="color:#a6e22e">next</span>,
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">pathSoFar</span>: <span style="color:#a6e22e">path</span>,
</span></span><span style="display:flex;"><span>				})
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>And that&rsquo;s it. We print <code>count</code> and we have our number.</p>
<h2 id="day-12---part-2">Day 12 - Part 2<a hidden class="anchor" aria-hidden="true" href="#day-12---part-2">#</a></h2>
<p>Now that we have our state in the loop itself, we just add a new variable to the <code>cave</code> called <code>twice</code> (it was already
there but I haven&rsquo;t used it yet). Our criteria for twice is as follows. If we haven&rsquo;t seen it yet, we explore it. If it
is already in the path so far, from which we came in AND none of the caves so far were visited twice ( which we&rsquo;ll know
because we bring our marker with us during the loop ) we set our cave to visited ( paint it ) and we only take the path
so far with us, so we don&rsquo;t put this guy in the path YET. We&rsquo;ll eventually do that though on the next time this cave is
encountered at which point it will bring twice with it.</p>
<p>How does that look like in code?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cave</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">value</span>:     <span style="color:#e6db74">&#34;start&#34;</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">pathSoFar</span>: []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;start&#34;</span>},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">queue</span> <span style="color:#f92672">:=</span> []<span style="color:#a6e22e">cave</span>{<span style="color:#a6e22e">start</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">current</span> <span style="color:#a6e22e">cave</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> len(<span style="color:#a6e22e">queue</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">current</span>, <span style="color:#a6e22e">queue</span> = <span style="color:#a6e22e">queue</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">queue</span>[<span style="color:#ae81ff">1</span>:]
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">value</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;end&#34;</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">count</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">next</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">caves</span>[<span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">value</span>] {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">seenThisCaveBefore</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">seen</span>(<span style="color:#a6e22e">next</span>, <span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">pathSoFar</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">seenThisCaveBefore</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">path</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">path</span> = append(<span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">pathSoFar</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">ToLower</span>(<span style="color:#a6e22e">next</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">next</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">path</span> = append(<span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">next</span>)
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">queue</span> = append(<span style="color:#a6e22e">queue</span>, <span style="color:#a6e22e">cave</span>{
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">value</span>:     <span style="color:#a6e22e">next</span>,
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">pathSoFar</span>: <span style="color:#a6e22e">path</span>,
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">twice</span>:     <span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">twice</span>,
</span></span><span style="display:flex;"><span>				})
</span></span><span style="display:flex;"><span>			} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">seenThisCaveBefore</span> <span style="color:#f92672">&amp;&amp;</span> !<span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">twice</span> <span style="color:#f92672">&amp;&amp;</span> !<span style="color:#a6e22e">seen</span>(<span style="color:#a6e22e">next</span>, []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;start&#34;</span>, <span style="color:#e6db74">&#34;end&#34;</span>}) {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">queue</span> = append(<span style="color:#a6e22e">queue</span>, <span style="color:#a6e22e">cave</span>{
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">value</span>:     <span style="color:#a6e22e">next</span>,
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">pathSoFar</span>: <span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">pathSoFar</span>,
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">twice</span>:     <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>				})
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>Again, we start off by adding <code>start</code>. Oh, and we don&rsquo;t do that for <code>start</code> or <code>end</code>. Also realized that I can use
<code>seen</code> now as sort of like a check for a value NOT being one of two values instead of a convoluted if structure.</p>
<p>So if everything is as before, expect we also take <code>twice</code> with us, and if we&rsquo;ve <code>seenThisCaveBefore</code> but we haven&rsquo;t
visited any caves twice before ( we take the marker with us during the journey ) and it&rsquo;s not start or end, we mark it
as visited twice, and we add pathSoFar as the current path so far, without adding this cave into it.</p>
<p>And that&rsquo;s it!</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>This day was somehow difficult on the first run. I couldn&rsquo;t figure out a nice way to keep track of my journey so far.
What helped me eventually was the prompt from my reading and reading various articles about keeping track during a
BFS and how listing all paths in a graph work. Which can be a difficult problem especially when there is a circle in the
graph. This would probably not work in that case, but we are confident that Eric doesn&rsquo;t do tricks like that.</p>
<p>The repository for all my solutions for AOC 2021 can be found <a href="https://github.com/Skarlso/aoc2021">here</a>.</p>
<p>Thank you for reading!</p>
<p>Gergely.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer><div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hannibalDisqus" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://skarlso.github.io">Ramblings of a cloud engineer</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
