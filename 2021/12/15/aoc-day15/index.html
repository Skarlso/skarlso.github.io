<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Advent Of Code - Day 15 | Ramblings of a cloud engineer</title>
<meta name="keywords" content="">
<meta name="description" content="Advent Of Code - Day 15 Today, again, we open up Red Blob Games. It is a great source of information and descriptions. Especially, since this scenario is right up Red Blob&rsquo;s ally. We need some weighted path finding. And Red Blob has a lovely post on that using the ever famous Dijkstra algorithm with a Priority Queue.
Day 15 - Part 1 Let&rsquo;s get to it. After refreshing my memory about priority queues, I remembered that there is a package and some sample code in Go which implements priority queues using the container/heap package here.">
<meta name="author" content="hannibal">
<link rel="canonical" href="https://skarlso.github.io/2021/12/15/aoc-day15/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://skarlso.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://skarlso.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://skarlso.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://skarlso.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://skarlso.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Advent Of Code - Day 15" />
<meta property="og:description" content="Advent Of Code - Day 15 Today, again, we open up Red Blob Games. It is a great source of information and descriptions. Especially, since this scenario is right up Red Blob&rsquo;s ally. We need some weighted path finding. And Red Blob has a lovely post on that using the ever famous Dijkstra algorithm with a Priority Queue.
Day 15 - Part 1 Let&rsquo;s get to it. After refreshing my memory about priority queues, I remembered that there is a package and some sample code in Go which implements priority queues using the container/heap package here." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://skarlso.github.io/2021/12/15/aoc-day15/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-15T01:01:00+01:00" />
<meta property="article:modified_time" content="2021-12-15T01:01:00+01:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Advent Of Code - Day 15"/>
<meta name="twitter:description" content="Advent Of Code - Day 15 Today, again, we open up Red Blob Games. It is a great source of information and descriptions. Especially, since this scenario is right up Red Blob&rsquo;s ally. We need some weighted path finding. And Red Blob has a lovely post on that using the ever famous Dijkstra algorithm with a Priority Queue.
Day 15 - Part 1 Let&rsquo;s get to it. After refreshing my memory about priority queues, I remembered that there is a package and some sample code in Go which implements priority queues using the container/heap package here."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://skarlso.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Advent Of Code - Day 15",
      "item": "https://skarlso.github.io/2021/12/15/aoc-day15/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Advent Of Code - Day 15",
  "name": "Advent Of Code - Day 15",
  "description": "Advent Of Code - Day 15 Today, again, we open up Red Blob Games. It is a great source of information and descriptions. Especially, since this scenario is right up Red Blob\u0026rsquo;s ally. We need some weighted path finding. And Red Blob has a lovely post on that using the ever famous Dijkstra algorithm with a Priority Queue.\nDay 15 - Part 1 Let\u0026rsquo;s get to it. After refreshing my memory about priority queues, I remembered that there is a package and some sample code in Go which implements priority queues using the container/heap package here.",
  "keywords": [
    
  ],
  "articleBody": "Advent Of Code - Day 15 Today, again, we open up Red Blob Games. It is a great source of information and descriptions. Especially, since this scenario is right up Red Blob’s ally. We need some weighted path finding. And Red Blob has a lovely post on that using the ever famous Dijkstra algorithm with a Priority Queue.\nDay 15 - Part 1 Let’s get to it. After refreshing my memory about priority queues, I remembered that there is a package and some sample code in Go which implements priority queues using the container/heap package here.\nPretty straight forward. There are some bits that we don’t need. For example, the update function is not needed. And there is a single small thing which we really need to be aware of in this code base. This part:\nfunc (pq PriorityQueue) Less(i, j int) bool { // We want Pop to give us the highest, not lowest, priority so we use greater than here. return pq[i].priority \u003e pq[j].priority } This infuriating detail got me at least 20 minutes of trying to figure out why my path wasn’t correct. We need to change this to \u003c.\nAlso, important detail is that you don’t use the priority queue directly. You use it with heap.Push(\u0026pq). Otherwise the priorities and indexes will not be up to date.\nOkay, first… We parse our grid using our trusty character cheat code:\nfor _, i := range input { row := make([]int, 0) for _, v := range i { c := v - '0' row = append(row, int(c)) } grid = append(grid, row) } Then we write our path finding. It’s a bit more verbose in Go than in Python of course. We have to initialize the PQ, then add in some code to get the neighbors, than set up the cameFrom part and traverse that backwards to get our full path. I’m sure there are better solutions out there than this, but this is what I feel comfortable with. And I saw many solutions using PQ.\nThe whole thing looks like this:\nstart := point{x: 0, y: 0} goal := point{x: len(grid[0]) - 1, y: len(grid) - 1} pq := make(PriorityQueue, 0) heap.Init(\u0026pq) heap.Push(\u0026pq, \u0026Item{ point: start, priority: grid[0][0], }) cost := map[point]int{ start: grid[0][0], } cameFrom := map[point]point{ start: start, } for pq.Len() \u003e 0 { current := heap.Pop(\u0026pq).(*Item) if current.point == goal { break } for _, next := range neighbors(current.point, grid) { newCost := cost[current.point] + grid[next.y][next.x] if v, ok := cost[next]; !ok || newCost \u003c v { cameFrom[next] = current.point cost[next] = newCost heap.Push(\u0026pq, \u0026Item{ point: next, priority: newCost, }) } } } Not that bad. And now, following the path back and calculating the sum.\nvar sum int current := goal for current != start { sum += grid[current.y][current.x] current = cameFrom[current] } fmt.Println(\"sum: \", sum) And that’s it. This is our correct number. Now, checking part 2…\nDay 15 - Part 2 Part 2 is the same, but with a twist. We have to expand the grid by… what? Uh. So, our tile is just a piece of a greater tile. And as we duplicate our tile, we need to increase the numbers by one compared to their original part.\nOkay, this takes a little bit to wrap my head around. So let’s remove some rules and make it easier. First, let’s deal with a simpler objective. Just copy our initial tile into a 5x5 grid. To do that, we create the initial grid with the size original y * 5 and original x * 5.\nexpandedGrid := make([][]int, len(grid)*5) for i := 0; i \u003c len(expandedGrid); i++ { expandedGrid[i] = make([]int, len(grid[0])*5) } Done. Now, copy over the initial rows.\n// Prime the first tile for y := 0; y \u003c len(grid); y++ { for x := 0; x \u003c len(grid[y]); x++ { expandedGrid[y][x] = grid[y][x] } } With this, actually we did create our 5x5 matrix, so let’s think a little bit about the problem. We take each number of the original grid, and +1-it compared to the previous number in the original grid. Let’s make this easy as the example has it. If the grid would be a single number, 8, we would get this grid:\n8 9 1 2 3 9 1 2 3 4 1 2 3 4 5 2 3 4 5 6 3 4 5 6 7 If look at the pattern, all we have to do is create the first row correctly, and then we just +1 downwards on each column and we are golden(star (pun intended))! Nice. So, let’s create that first row.\n// fill out first line for all of the original grid sizes. for y := 0; y \u003c len(grid); y++ { for x := len(grid[y]); x \u003c len(expandedGrid[y]); x++ { // x - the length of the initial grid newValue := (expandedGrid[y][x-len(grid[y])] + 1) % 10 if newValue == 0 { newValue = 1 } expandedGrid[y][x] = newValue } } Basically, the newValue := (expandedGrid[y][x-len(grid[y])] + 1) % 10 new value, is the original location, which is the current location minus the size of the original grid[y] and then +1. And it wraps around of course.\nThat’s fantastic. With that, we have our first row like this:\n89123 00000 00000 00000 00000 Now, we just have to go downwards with the same logic. Compared to the original location, minus the size, and +1.\n// fill out downwards for y := len(grid); y \u003c len(expandedGrid); y++ { for x := 0; x \u003c len(expandedGrid[y]); x++ { // x - the length of the initial grid newValue := (expandedGrid[y-len(grid)][x] + 1) % 10 if newValue == 0 { newValue = 1 } expandedGrid[y][x] = newValue } } And done! We have our correct grid! We run the path finding, which didn’t change, and we have our correct result! Another star in the bag!\nConclusion Today, we again learned that Red Blob Games is an invaluable resource of path finding information. And it’s nice to read through the material once in a while to refresh our knowledge about these things that exist. And we had some fun manipulating a matrix again and understanding that patterns will save our asses in these exercises.\nThe repository for all my solutions for AOC 2021 can be found here.\nThank you for reading!\nGergely.\n",
  "wordCount" : "1058",
  "inLanguage": "en",
  "datePublished": "2021-12-15T01:01:00+01:00",
  "dateModified": "2021-12-15T01:01:00+01:00",
  "author":{
    "@type": "Person",
    "name": "hannibal"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://skarlso.github.io/2021/12/15/aoc-day15/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ramblings of a cloud engineer",
    "logo": {
      "@type": "ImageObject",
      "url": "https://skarlso.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://skarlso.github.io" accesskey="h" title="Ramblings of a cloud engineer (Alt + H)">Ramblings of a cloud engineer</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://skarlso.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/search/" title="Search">
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://skarlso.github.io">Home</a>&nbsp;»&nbsp;<a href="https://skarlso.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Advent Of Code - Day 15
    </h1>
    <div class="post-meta"><span title='2021-12-15 01:01:00 +0100 +0100'>December 15, 2021</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;hannibal

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#advent-of-code---day-15" aria-label="Advent Of Code - Day 15">Advent Of Code - Day 15</a><ul>
                        
                <li>
                    <a href="#day-15---part-1" aria-label="Day 15 - Part 1">Day 15 - Part 1</a></li>
                <li>
                    <a href="#day-15---part-2" aria-label="Day 15 - Part 2">Day 15 - Part 2</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="advent-of-code---day-15">Advent Of Code - Day 15<a hidden class="anchor" aria-hidden="true" href="#advent-of-code---day-15">#</a></h1>
<p>Today, again, we open up <a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html">Red Blob Games</a>.
It is a great source of information and descriptions. Especially, since this scenario is right up Red Blob&rsquo;s ally.
We need some weighted path finding. And Red Blob has a lovely post on that using the ever famous <a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html#dijkstra">Dijkstra</a> algorithm with a Priority Queue.</p>
<h2 id="day-15---part-1">Day 15 - Part 1<a hidden class="anchor" aria-hidden="true" href="#day-15---part-1">#</a></h2>
<p>Let&rsquo;s get to it. After refreshing my memory about priority queues, I remembered that there is a package and some sample
code in Go which implements priority queues using the <code>container/heap</code> package <a href="https://pkg.go.dev/container/heap#example-package-PriorityQueue">here</a>.</p>
<p>Pretty straight forward. There are some bits that we don&rsquo;t need. For example, the <code>update</code> function is not needed.
And there is a single small thing which we really need to be aware of in this code base. This part:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">pq</span> <span style="color:#a6e22e">PriorityQueue</span>) <span style="color:#a6e22e">Less</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// We want Pop to give us the highest, not lowest, priority so we use greater than here.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pq</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">priority</span> &gt; <span style="color:#a6e22e">pq</span>[<span style="color:#a6e22e">j</span>].<span style="color:#a6e22e">priority</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This infuriating detail got me at least 20 minutes of trying to figure out why my path wasn&rsquo;t correct. We need to change
this to <code>&lt;</code>.</p>
<p>Also, important detail is that you don&rsquo;t use the priority queue directly. You use it with <code>heap.Push(&amp;pq)</code>. Otherwise
the priorities and indexes will not be up to date.</p>
<p>Okay, first&hellip; We parse our grid using our trusty character cheat code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">input</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">row</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">i</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">row</span> = append(<span style="color:#a6e22e">row</span>, int(<span style="color:#a6e22e">c</span>))
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">grid</span> = append(<span style="color:#a6e22e">grid</span>, <span style="color:#a6e22e">row</span>)
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>Then we write our path finding. It&rsquo;s a bit more verbose in Go than in Python of course. We have to initialize the PQ,
then add in some code to get the neighbors, than set up the <code>cameFrom</code> part and traverse that backwards to get our full
path. I&rsquo;m sure there are better solutions out there than this, but this is what I feel comfortable with. And I saw many
solutions using PQ.</p>
<p>The whole thing looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">point</span>{<span style="color:#a6e22e">x</span>: <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">y</span>: <span style="color:#ae81ff">0</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">goal</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">point</span>{<span style="color:#a6e22e">x</span>: len(<span style="color:#a6e22e">grid</span>[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span>: len(<span style="color:#a6e22e">grid</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pq</span> <span style="color:#f92672">:=</span> make(<span style="color:#a6e22e">PriorityQueue</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">heap</span>.<span style="color:#a6e22e">Init</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pq</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">heap</span>.<span style="color:#a6e22e">Push</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pq</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Item</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">point</span>:    <span style="color:#a6e22e">start</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">priority</span>: <span style="color:#a6e22e">grid</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cost</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">point</span>]<span style="color:#66d9ef">int</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">start</span>: <span style="color:#a6e22e">grid</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cameFrom</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">point</span>]<span style="color:#a6e22e">point</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">start</span>: <span style="color:#a6e22e">start</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">pq</span>.<span style="color:#a6e22e">Len</span>() &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">current</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">heap</span>.<span style="color:#a6e22e">Pop</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pq</span>).(<span style="color:#f92672">*</span><span style="color:#a6e22e">Item</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">point</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">goal</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">next</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">neighbors</span>(<span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">point</span>, <span style="color:#a6e22e">grid</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">newCost</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cost</span>[<span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">point</span>] <span style="color:#f92672">+</span> <span style="color:#a6e22e">grid</span>[<span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">y</span>][<span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">x</span>]
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cost</span>[<span style="color:#a6e22e">next</span>]; !<span style="color:#a6e22e">ok</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">newCost</span> &lt; <span style="color:#a6e22e">v</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">cameFrom</span>[<span style="color:#a6e22e">next</span>] = <span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">point</span>
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">cost</span>[<span style="color:#a6e22e">next</span>] = <span style="color:#a6e22e">newCost</span>
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">heap</span>.<span style="color:#a6e22e">Push</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pq</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Item</span>{
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">point</span>:    <span style="color:#a6e22e">next</span>,
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">priority</span>: <span style="color:#a6e22e">newCost</span>,
</span></span><span style="display:flex;"><span>				})
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>Not that bad. And now, following the path back and calculating the sum.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sum</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">current</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">goal</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">current</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">start</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">grid</span>[<span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">y</span>][<span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">x</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">current</span> = <span style="color:#a6e22e">cameFrom</span>[<span style="color:#a6e22e">current</span>]
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;sum: &#34;</span>, <span style="color:#a6e22e">sum</span>)
</span></span></code></pre></div><p>And that&rsquo;s it. This is our correct number. Now, checking part 2&hellip;</p>
<h2 id="day-15---part-2">Day 15 - Part 2<a hidden class="anchor" aria-hidden="true" href="#day-15---part-2">#</a></h2>
<p>Part 2 is the same, but with a twist. We have to expand the grid by&hellip; what? Uh. So, our tile is just a piece of a
greater tile. And as we duplicate our tile, we need to increase the numbers by one compared to their original part.</p>
<p>Okay, this takes a little bit to wrap my head around. So let&rsquo;s remove some rules and make it easier. First, let&rsquo;s deal
with a simpler objective. Just copy our initial tile into a 5x5 grid. To do that, we create the initial grid with the
size original y * 5 and original x * 5.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">expandedGrid</span> <span style="color:#f92672">:=</span> make([][]<span style="color:#66d9ef">int</span>, len(<span style="color:#a6e22e">grid</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">expandedGrid</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">expandedGrid</span>[<span style="color:#a6e22e">i</span>] = make([]<span style="color:#66d9ef">int</span>, len(<span style="color:#a6e22e">grid</span>[<span style="color:#ae81ff">0</span>])<span style="color:#f92672">*</span><span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>Done. Now, copy over the initial rows.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#75715e">// Prime the first tile
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">y</span> &lt; len(<span style="color:#a6e22e">grid</span>); <span style="color:#a6e22e">y</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">x</span> &lt; len(<span style="color:#a6e22e">grid</span>[<span style="color:#a6e22e">y</span>]); <span style="color:#a6e22e">x</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">expandedGrid</span>[<span style="color:#a6e22e">y</span>][<span style="color:#a6e22e">x</span>] = <span style="color:#a6e22e">grid</span>[<span style="color:#a6e22e">y</span>][<span style="color:#a6e22e">x</span>]
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>With this, actually we did create our 5x5 matrix, so let&rsquo;s think a little bit about the problem. We take each number of
the original grid, and +1-it compared to the previous number in the original grid. Let&rsquo;s make this easy as the example
has it. If the grid would be a single number, <code>8</code>, we would get this grid:</p>
<pre tabindex="0"><code>8 9 1 2 3
9 1 2 3 4
1 2 3 4 5
2 3 4 5 6
3 4 5 6 7
</code></pre><p>If look at the pattern, all we have to do is create the first row correctly, and then we just +1 downwards on each
column and we are golden(star (pun intended))! Nice. So, let&rsquo;s create that first row.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#75715e">// fill out first line for all of the original grid sizes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">y</span> &lt; len(<span style="color:#a6e22e">grid</span>); <span style="color:#a6e22e">y</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">grid</span>[<span style="color:#a6e22e">y</span>]); <span style="color:#a6e22e">x</span> &lt; len(<span style="color:#a6e22e">expandedGrid</span>[<span style="color:#a6e22e">y</span>]); <span style="color:#a6e22e">x</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// x - the length of the initial grid
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">newValue</span> <span style="color:#f92672">:=</span> (<span style="color:#a6e22e">expandedGrid</span>[<span style="color:#a6e22e">y</span>][<span style="color:#a6e22e">x</span><span style="color:#f92672">-</span>len(<span style="color:#a6e22e">grid</span>[<span style="color:#a6e22e">y</span>])] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">newValue</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">newValue</span> = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">expandedGrid</span>[<span style="color:#a6e22e">y</span>][<span style="color:#a6e22e">x</span>] = <span style="color:#a6e22e">newValue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>Basically, the <code>newValue := (expandedGrid[y][x-len(grid[y])] + 1) % 10</code> new value, is the original location, which is
the current location minus the size of the original grid[y] and then +1. And it wraps around of course.</p>
<p>That&rsquo;s fantastic. With that, we have our first row like this:</p>
<pre tabindex="0"><code>89123
00000
00000
00000
00000
</code></pre><p>Now, we just have to go downwards with the same logic. Compared to the original location, minus the size, and +1.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#75715e">// fill out downwards
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">grid</span>); <span style="color:#a6e22e">y</span> &lt; len(<span style="color:#a6e22e">expandedGrid</span>); <span style="color:#a6e22e">y</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">x</span> &lt; len(<span style="color:#a6e22e">expandedGrid</span>[<span style="color:#a6e22e">y</span>]); <span style="color:#a6e22e">x</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// x - the length of the initial grid
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">newValue</span> <span style="color:#f92672">:=</span> (<span style="color:#a6e22e">expandedGrid</span>[<span style="color:#a6e22e">y</span><span style="color:#f92672">-</span>len(<span style="color:#a6e22e">grid</span>)][<span style="color:#a6e22e">x</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">newValue</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">newValue</span> = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">expandedGrid</span>[<span style="color:#a6e22e">y</span>][<span style="color:#a6e22e">x</span>] = <span style="color:#a6e22e">newValue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>And done! We have our correct grid! We run the path finding, which didn&rsquo;t change, and we have our correct result!
Another star in the bag!</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>Today, we again learned that Red Blob Games is an invaluable resource of path finding information. And it&rsquo;s nice to read
through the material once in a while to refresh our knowledge about these things that exist. And we had some fun
manipulating a matrix again and understanding that patterns will save our asses in these exercises.</p>
<p>The repository for all my solutions for AOC 2021 can be found <a href="https://github.com/Skarlso/aoc2021">here</a>.</p>
<p>Thank you for reading!</p>
<p>Gergely.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://skarlso.github.io/2021/12/17/aoc-day12-updated/">
    <span class="title">« Prev</span>
    <br>
    <span>Advent Of Code - Day 12 - Updated</span>
  </a>
  <a class="next" href="https://skarlso.github.io/2021/12/14/aoc-day14/">
    <span class="title">Next »</span>
    <br>
    <span>Advent Of Code - Day 14</span>
  </a>
</nav>

  </footer><div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hannibalDisqus" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://skarlso.github.io">Ramblings of a cloud engineer</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
