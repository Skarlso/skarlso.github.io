<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Advent Of Code - Day 9 | Ramblings of a cloud engineer</title>
<meta name="keywords" content="">
<meta name="description" content="Advent Of Code - Day 9
This one was an interesting one, and a step up from previous days. I used a BFS here and I have a fantastic link for the
description, usage and appliance of BFS and others like A*. Pop over to Red Blog Games for
all the good stuff. There are fantastic articles about all sorts of path finding and walking algorithms.
Day 9 - Part 1
We start off again with something easy. Basically, just walk through a map, and find lowest values in it compared to
neighbors of a cell. Here, we get to know a thing called direction calculation. In Go I have a list of points for that
which will come in handy in other situations. But first, let&rsquo;s parse our input. This time, I actually have a neat little
trick on Go to create a slice of numbers from a slice of string numbers:">
<meta name="author" content="hannibal">
<link rel="canonical" href="https://skarlso.github.io/2021/12/09/aoc-day9/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://skarlso.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://skarlso.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://skarlso.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://skarlso.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://skarlso.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://skarlso.github.io/2021/12/09/aoc-day9/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Advent Of Code - Day 9">
<meta property="og:description" content="Advent Of Code - Day 9
This one was an interesting one, and a step up from previous days. I used a BFS here and I have a fantastic link for the
description, usage and appliance of BFS and others like A*. Pop over to Red Blog Games for
all the good stuff. There are fantastic articles about all sorts of path finding and walking algorithms.
Day 9 - Part 1
We start off again with something easy. Basically, just walk through a map, and find lowest values in it compared to
neighbors of a cell. Here, we get to know a thing called direction calculation. In Go I have a list of points for that
which will come in handy in other situations. But first, let&rsquo;s parse our input. This time, I actually have a neat little
trick on Go to create a slice of numbers from a slice of string numbers:">
<meta property="og:type" content="article">
<meta property="og:url" content="https://skarlso.github.io/2021/12/09/aoc-day9/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-12-09T01:01:00+01:00">
<meta property="article:modified_time" content="2021-12-09T01:01:00+01:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Advent Of Code - Day 9">
<meta name="twitter:description" content="Advent Of Code - Day 9
This one was an interesting one, and a step up from previous days. I used a BFS here and I have a fantastic link for the
description, usage and appliance of BFS and others like A*. Pop over to Red Blog Games for
all the good stuff. There are fantastic articles about all sorts of path finding and walking algorithms.
Day 9 - Part 1
We start off again with something easy. Basically, just walk through a map, and find lowest values in it compared to
neighbors of a cell. Here, we get to know a thing called direction calculation. In Go I have a list of points for that
which will come in handy in other situations. But first, let&rsquo;s parse our input. This time, I actually have a neat little
trick on Go to create a slice of numbers from a slice of string numbers:">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://skarlso.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Advent Of Code - Day 9",
      "item": "https://skarlso.github.io/2021/12/09/aoc-day9/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Advent Of Code - Day 9",
  "name": "Advent Of Code - Day 9",
  "description": "Advent Of Code - Day 9 This one was an interesting one, and a step up from previous days. I used a BFS here and I have a fantastic link for the description, usage and appliance of BFS and others like A*. Pop over to Red Blog Games for all the good stuff. There are fantastic articles about all sorts of path finding and walking algorithms.\nDay 9 - Part 1 We start off again with something easy. Basically, just walk through a map, and find lowest values in it compared to neighbors of a cell. Here, we get to know a thing called direction calculation. In Go I have a list of points for that which will come in handy in other situations. But first, let\u0026rsquo;s parse our input. This time, I actually have a neat little trick on Go to create a slice of numbers from a slice of string numbers:\n",
  "keywords": [
    
  ],
  "articleBody": "Advent Of Code - Day 9 This one was an interesting one, and a step up from previous days. I used a BFS here and I have a fantastic link for the description, usage and appliance of BFS and others like A*. Pop over to Red Blog Games for all the good stuff. There are fantastic articles about all sorts of path finding and walking algorithms.\nDay 9 - Part 1 We start off again with something easy. Basically, just walk through a map, and find lowest values in it compared to neighbors of a cell. Here, we get to know a thing called direction calculation. In Go I have a list of points for that which will come in handy in other situations. But first, let’s parse our input. This time, I actually have a neat little trick on Go to create a slice of numbers from a slice of string numbers:\ninput := strings.Split(string(content), \"\\n\") grid := make([][]int, 0) for _, i := range input { row := make([]int, 0) for _, v := range i { c := v - '0' row = append(row, int(c)) } grid = append(grid, row) } In Go, characters are runes and they can be used like numbers with the ascii representations. So if you subtract the ascii number 0 from the ascii value 1 you’ll get 1 as a value. Converting that to int gives you the number that you want. Neat.\nWith that out of the way, let’s find our lowest points.\nsum := 0 // display(grid) for y := 0; y \u003c len(grid); y++ { for x := 0; x \u003c len(grid[y]); x++ { lowest := true for _, d := range directions { np := point{x: x + d.x, y: y + d.y} if np.x \u003e= 0 \u0026\u0026 np.x \u003c len(grid[y]) \u0026\u0026 np.y \u003e= 0 \u0026\u0026 np.y \u003c len(grid) { if grid[np.y][np.x] \u003c= grid[y][x] { lowest = false break } } } if lowest { fmt.Println(\"lowest: \", grid[y][x]) sum += grid[y][x] + 1 } } } fmt.Println(\"sum: \", sum) What is directions?\ndirections = []point{ {x: -1, y: 0}, {x: 0, y: -1}, {x: 1, y: 0}, {x: 0, y: 1}, } What’s happening here is, instead of doing something like if x-1 \u003c ... x-1... we save the up, down, left, right as directions which we add to the current coordinates. This could easily now be expanded with say x: -1, y: -1 which would be to upper left corner. This way we don’t have to add any new ifs. We loop through them and check the boundaries.\nThen we just a min on all the points and sum them up. Done. Nice. Now, comes the bigger part.\nDay 9 - Part 2 For this, we first have to understand what the heck is going on. Reading the text, we see some keywords like, lowest point and that they should converge to that point. And also the 9 is the limit and it’s not part of the whole thing. We also read on that it flows downward which makes us tempted to do this search from the other way around. But, we already have the point of origin. So let’s start from there and go outside.\nWhat are we trying to do here exactly? We are trying to find paths which lead back to our lowest point. Our natural stopper will be the number 9 and the ends of the map. Also, we will search for higher numbers than ours. Just to recap. Start from lowest, and find paths with numbers that are higher than the previous number.\nThis is a BFS algorithm. And the linked blog will explain it better than I could. I really encourage you to take a look. It has great resources for these things.\nI’m just going to show the Go equivalent.\nfor _, p := range basins { sizes = append(sizes, calculateBasinSize(p, grid)) } sort.Ints(sizes) l := len(sizes) fmt.Println(\"sum: \", sizes[l-1]*sizes[l-2]*sizes[l-3]) Calculate Basin is then the BFS:\nfunc neighbors(p point, grid [][]int) []point { var result []point for _, d := range directions { np := point{x: p.x + d.x, y: p.y + d.y} if np.x \u003e= 0 \u0026\u0026 np.x \u003c len(grid[p.y]) \u0026\u0026 np.y \u003e= 0 \u0026\u0026 np.y \u003c len(grid) { if grid[np.y][np.x] \u003e grid[p.y][p.x] \u0026\u0026 grid[np.y][np.x] != 9 { result = append(result, np) } } } return result } func calculateBasinSize(p point, grid [][]int) int { start := p seen := map[point]struct{}{ start: {}, } queue := []point{start} var current point for len(queue) \u003e 0 { current, queue = queue[0], queue[1:] for _, next := range neighbors(current, grid) { if _, ok := seen[next]; !ok { queue = append(queue, next) seen[next] = struct{}{} } } } return len(seen) } The gist of this is the queue thing, finding neighbors based on the rules we have. Greater than us, and not 9. And then we return the number of seen points. Those will be the size of the basin.\nAnd we are done. We do the calculation and hopefully we’ll have the right result.\nConclusion Today we learned about BFS and later on about A* and various path finding algorithms which will come in handy later on.\nThe repository for all my solutions for AOC 2021 can be found here.\nThank you for reading!\nGergely.\n",
  "wordCount" : "884",
  "inLanguage": "en",
  "datePublished": "2021-12-09T01:01:00+01:00",
  "dateModified": "2021-12-09T01:01:00+01:00",
  "author":{
    "@type": "Person",
    "name": "hannibal"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://skarlso.github.io/2021/12/09/aoc-day9/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ramblings of a cloud engineer",
    "logo": {
      "@type": "ImageObject",
      "url": "https://skarlso.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://skarlso.github.io/" accesskey="h" title="Ramblings of a cloud engineer (Alt + H)">Ramblings of a cloud engineer</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://skarlso.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/search/" title="Search">
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://skarlso.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://skarlso.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Advent Of Code - Day 9
    </h1>
    <div class="post-meta"><span title='2021-12-09 01:01:00 +0100 +0100'>December 9, 2021</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;hannibal

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#advent-of-code---day-9" aria-label="Advent Of Code - Day 9">Advent Of Code - Day 9</a><ul>
                        
                <li>
                    <a href="#day-9---part-1" aria-label="Day 9 - Part 1">Day 9 - Part 1</a></li>
                <li>
                    <a href="#day-9---part-2" aria-label="Day 9 - Part 2">Day 9 - Part 2</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="advent-of-code---day-9">Advent Of Code - Day 9<a hidden class="anchor" aria-hidden="true" href="#advent-of-code---day-9">#</a></h1>
<p>This one was an interesting one, and a step up from previous days. I used a BFS here and I have a fantastic link for the
description, usage and appliance of BFS and others like A*. Pop over to <a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html">Red Blog Games</a> for
all the good stuff. There are fantastic articles about all sorts of path finding and walking algorithms.</p>
<h2 id="day-9---part-1">Day 9 - Part 1<a hidden class="anchor" aria-hidden="true" href="#day-9---part-1">#</a></h2>
<p>We start off again with something easy. Basically, just walk through a map, and find lowest values in it compared to
neighbors of a cell. Here, we get to know a thing called direction calculation. In Go I have a list of points for that
which will come in handy in other situations. But first, let&rsquo;s parse our input. This time, I actually have a neat little
trick on Go to create a slice of numbers from a slice of string numbers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">input</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(string(<span style="color:#a6e22e">content</span>), <span style="color:#e6db74">&#34;\n&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">grid</span> <span style="color:#f92672">:=</span> make([][]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">input</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">row</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">i</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">row</span> = append(<span style="color:#a6e22e">row</span>, int(<span style="color:#a6e22e">c</span>))
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">grid</span> = append(<span style="color:#a6e22e">grid</span>, <span style="color:#a6e22e">row</span>)
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>In Go, characters are runes and they can be used like numbers with the ascii representations. So if you subtract the
ascii number <code>0</code> from the ascii value <code>1</code> you&rsquo;ll get <code>1</code> as a value. Converting that to <code>int</code> gives you the number that
you want. Neat.</p>
<p>With that out of the way, let&rsquo;s find our lowest points.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// display(grid)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">y</span> &lt; len(<span style="color:#a6e22e">grid</span>); <span style="color:#a6e22e">y</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">x</span> &lt; len(<span style="color:#a6e22e">grid</span>[<span style="color:#a6e22e">y</span>]); <span style="color:#a6e22e">x</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">lowest</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">directions</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">np</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">point</span>{<span style="color:#a6e22e">x</span>: <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>: <span style="color:#a6e22e">y</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">y</span>}
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">np</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">np</span>.<span style="color:#a6e22e">x</span> &lt; len(<span style="color:#a6e22e">grid</span>[<span style="color:#a6e22e">y</span>]) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">np</span>.<span style="color:#a6e22e">y</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">np</span>.<span style="color:#a6e22e">y</span> &lt; len(<span style="color:#a6e22e">grid</span>) {
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">grid</span>[<span style="color:#a6e22e">np</span>.<span style="color:#a6e22e">y</span>][<span style="color:#a6e22e">np</span>.<span style="color:#a6e22e">x</span>] <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">grid</span>[<span style="color:#a6e22e">y</span>][<span style="color:#a6e22e">x</span>] {
</span></span><span style="display:flex;"><span>						<span style="color:#a6e22e">lowest</span> = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>					}
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">lowest</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;lowest: &#34;</span>, <span style="color:#a6e22e">grid</span>[<span style="color:#a6e22e">y</span>][<span style="color:#a6e22e">x</span>])
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">grid</span>[<span style="color:#a6e22e">y</span>][<span style="color:#a6e22e">x</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;sum: &#34;</span>, <span style="color:#a6e22e">sum</span>)
</span></span></code></pre></div><p>What is directions?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">directions</span> = []<span style="color:#a6e22e">point</span>{
</span></span><span style="display:flex;"><span>		{<span style="color:#a6e22e">x</span>: <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span>: <span style="color:#ae81ff">0</span>},
</span></span><span style="display:flex;"><span>		{<span style="color:#a6e22e">x</span>: <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">y</span>: <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>},
</span></span><span style="display:flex;"><span>		{<span style="color:#a6e22e">x</span>: <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span>: <span style="color:#ae81ff">0</span>},
</span></span><span style="display:flex;"><span>		{<span style="color:#a6e22e">x</span>: <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">y</span>: <span style="color:#ae81ff">1</span>},
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>What&rsquo;s happening here is, instead of doing something like <code>if x-1 &lt; ... x-1...</code> we save the up, down, left, right as
directions which we add to the current coordinates. This could easily now be expanded with say <code>x: -1, y: -1</code> which would
be to upper left corner. This way we don&rsquo;t have to add any new ifs. We loop through them and check the boundaries.</p>
<p>Then we just a min on all the points and sum them up. Done. Nice. Now, comes the bigger part.</p>
<h2 id="day-9---part-2">Day 9 - Part 2<a hidden class="anchor" aria-hidden="true" href="#day-9---part-2">#</a></h2>
<p>For this, we first have to understand what the heck is going on. Reading the text, we see some keywords like, lowest point
and that they should converge to that point. And also the 9 is the limit and it&rsquo;s not part of the whole thing. We also
read on that it flows downward which makes us tempted to do this search from the other way around. But, we already have
the point of origin. So let&rsquo;s start from there and go outside.</p>
<p>What are we trying to do here exactly? We are trying to find paths which lead back to our lowest point. Our natural
stopper will be the number <code>9</code> and the ends of the map. Also, we will search for higher numbers than ours. Just to recap.
Start from lowest, and find paths with numbers that are higher than the previous number.</p>
<p>This is a BFS algorithm. And the linked blog will explain it better than I could. I really encourage you to take a look.
It has great resources for these things.</p>
<p>I&rsquo;m just going to show the Go equivalent.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">basins</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">sizes</span> = append(<span style="color:#a6e22e">sizes</span>, <span style="color:#a6e22e">calculateBasinSize</span>(<span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">grid</span>))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sort</span>.<span style="color:#a6e22e">Ints</span>(<span style="color:#a6e22e">sizes</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">sizes</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;sum: &#34;</span>, <span style="color:#a6e22e">sizes</span>[<span style="color:#a6e22e">l</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">sizes</span>[<span style="color:#a6e22e">l</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">sizes</span>[<span style="color:#a6e22e">l</span><span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>])
</span></span></code></pre></div><p>Calculate Basin is then the BFS:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">neighbors</span>(<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">point</span>, <span style="color:#a6e22e">grid</span> [][]<span style="color:#66d9ef">int</span>) []<span style="color:#a6e22e">point</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">result</span> []<span style="color:#a6e22e">point</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">directions</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">np</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">point</span>{<span style="color:#a6e22e">x</span>: <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>: <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">y</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">y</span>}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">np</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">np</span>.<span style="color:#a6e22e">x</span> &lt; len(<span style="color:#a6e22e">grid</span>[<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">y</span>]) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">np</span>.<span style="color:#a6e22e">y</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">np</span>.<span style="color:#a6e22e">y</span> &lt; len(<span style="color:#a6e22e">grid</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">grid</span>[<span style="color:#a6e22e">np</span>.<span style="color:#a6e22e">y</span>][<span style="color:#a6e22e">np</span>.<span style="color:#a6e22e">x</span>] &gt; <span style="color:#a6e22e">grid</span>[<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">y</span>][<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">x</span>] <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">grid</span>[<span style="color:#a6e22e">np</span>.<span style="color:#a6e22e">y</span>][<span style="color:#a6e22e">np</span>.<span style="color:#a6e22e">x</span>] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">9</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">result</span> = append(<span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">np</span>)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">calculateBasinSize</span>(<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">point</span>, <span style="color:#a6e22e">grid</span> [][]<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">seen</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">point</span>]<span style="color:#66d9ef">struct</span>{}{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">start</span>: {},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">queue</span> <span style="color:#f92672">:=</span> []<span style="color:#a6e22e">point</span>{<span style="color:#a6e22e">start</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">current</span> <span style="color:#a6e22e">point</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> len(<span style="color:#a6e22e">queue</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">current</span>, <span style="color:#a6e22e">queue</span> = <span style="color:#a6e22e">queue</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">queue</span>[<span style="color:#ae81ff">1</span>:]
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">next</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">neighbors</span>(<span style="color:#a6e22e">current</span>, <span style="color:#a6e22e">grid</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">seen</span>[<span style="color:#a6e22e">next</span>]; !<span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">queue</span> = append(<span style="color:#a6e22e">queue</span>, <span style="color:#a6e22e">next</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">seen</span>[<span style="color:#a6e22e">next</span>] = <span style="color:#66d9ef">struct</span>{}{}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> len(<span style="color:#a6e22e">seen</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The gist of this is the queue thing, finding neighbors based on the rules we have. Greater than us, and not 9. And then
we return the number of seen points. Those will be the size of the basin.</p>
<p>And we are done. We do the calculation and hopefully we&rsquo;ll have the right result.</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>Today we learned about BFS and later on about A* and various path finding algorithms which will come in handy later on.</p>
<p>The repository for all my solutions for AOC 2021 can be found <a href="https://github.com/Skarlso/aoc2021">here</a>.</p>
<p>Thank you for reading!</p>
<p>Gergely.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://skarlso.github.io/2021/12/10/aoc-day10/">
    <span class="title">« Prev</span>
    <br>
    <span>Advent Of Code - Day 10</span>
  </a>
  <a class="next" href="https://skarlso.github.io/2021/12/08/aoc-day8/">
    <span class="title">Next »</span>
    <br>
    <span>Advent Of Code - Day 8</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://skarlso.github.io/">Ramblings of a cloud engineer</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
