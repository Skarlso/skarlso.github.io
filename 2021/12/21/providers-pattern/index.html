<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Providers Pattern | Ramblings of a cloud engineer</title>
<meta name="keywords" content="">
<meta name="description" content="Hello Dear readers.
Today, I would like to write about a project design pattern I&rsquo;ve been using successfully over the past years for various projects. It has many variations and it has some design patterns that are commonly found in the wild, so there is nothing really special about it.
Let&rsquo;s begin.
Providers Pattern What is this pattern anyways? It&rsquo;s a pattern I learned while working at ArangoDB. It&rsquo;s quite nice and defines package abstractions wonderfully.">
<meta name="author" content="hannibal">
<link rel="canonical" href="https://skarlso.github.io/2021/12/21/providers-pattern/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://skarlso.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://skarlso.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://skarlso.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://skarlso.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://skarlso.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Providers Pattern" />
<meta property="og:description" content="Hello Dear readers.
Today, I would like to write about a project design pattern I&rsquo;ve been using successfully over the past years for various projects. It has many variations and it has some design patterns that are commonly found in the wild, so there is nothing really special about it.
Let&rsquo;s begin.
Providers Pattern What is this pattern anyways? It&rsquo;s a pattern I learned while working at ArangoDB. It&rsquo;s quite nice and defines package abstractions wonderfully." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://skarlso.github.io/2021/12/21/providers-pattern/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-21T01:01:00+01:00" />
<meta property="article:modified_time" content="2021-12-21T01:01:00+01:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Providers Pattern"/>
<meta name="twitter:description" content="Hello Dear readers.
Today, I would like to write about a project design pattern I&rsquo;ve been using successfully over the past years for various projects. It has many variations and it has some design patterns that are commonly found in the wild, so there is nothing really special about it.
Let&rsquo;s begin.
Providers Pattern What is this pattern anyways? It&rsquo;s a pattern I learned while working at ArangoDB. It&rsquo;s quite nice and defines package abstractions wonderfully."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://skarlso.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Providers Pattern",
      "item": "https://skarlso.github.io/2021/12/21/providers-pattern/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Providers Pattern",
  "name": "Providers Pattern",
  "description": "Hello Dear readers.\nToday, I would like to write about a project design pattern I\u0026rsquo;ve been using successfully over the past years for various projects. It has many variations and it has some design patterns that are commonly found in the wild, so there is nothing really special about it.\nLet\u0026rsquo;s begin.\nProviders Pattern What is this pattern anyways? It\u0026rsquo;s a pattern I learned while working at ArangoDB. It\u0026rsquo;s quite nice and defines package abstractions wonderfully.",
  "keywords": [
    
  ],
  "articleBody": "Hello Dear readers.\nToday, I would like to write about a project design pattern I’ve been using successfully over the past years for various projects. It has many variations and it has some design patterns that are commonly found in the wild, so there is nothing really special about it.\nLet’s begin.\nProviders Pattern What is this pattern anyways? It’s a pattern I learned while working at ArangoDB. It’s quite nice and defines package abstractions wonderfully. It somewhat resembles the Repository pattern from DDD and also uses Chain of Responsibility to setup multiple providers for a given functionality. Like a fallback, in case a Provider does not understand the current thing it got. In that case, it will delegate to Next.\nI’m going to demonstrate all of the pattern’s capabilities through a sample project which is hopefully a sensible thing and not just dummy functionality.\nTL;DR A Provider is like the Repository pattern from DDD combined with Chain Of Responsibility. Basically, set up a Provider using an interface as a definition. Give that as dependency to another provider and call it’s function. If the Provider doesn’t understand the type its supposed to work on, it will call Next in the chain delegating the function to the following Provider. For a detailed use of this pattern, check out Providers Example project on GitHub.\nThe Project Providers Example is the project I’ll be using to demonstrate this pattern. It’s pretty simple; yet, I hope, it presents a useful function to be show off this pattern’s capabilities.\nIn essence, this is a plugin executor. We have a CLI which can register plugins to execute. These plugins can either be bare metal (as in a simple executable living somewhere), or a docker container, in which case it will use Docker to execute the plugin. It will forward all possible parameters and display any outputs.\nSimple, yet there are a couple things that we can extract into Providers such as:\nDealing with the archive ( so we can test the Tar function ) (sorry, I scrapped this, to keep things simple) Selecting the executing environment ( bare metal, container ) which we can chain Output formatting ( possibly, thing like, JSON, Table, etc. ) Saving things into a Database ( we will save what kind of plugins exist using sqlite ) 4.1. We’ll just save the name and the type for simplicity Basics Let’s take a look at the folder structure here.\n➜ providers-example git:(main) tree . ├── LICENSE ├── Makefile ├── README.md ├── bin ├── cmd │ ├── add.go │ ├── list.go │ ├── remove.go │ ├── root.go │ └── run.go ├── example │ └── echo_plugin │ └── Dockerfile ├── go.mod ├── go.sum ├── main.go ├── pkg │ ├── commands │ │ └── add.go │ ├── models │ │ └── plugin.go │ └── providers │ ├── archiver.go │ ├── bare │ │ └── bare_runner.go │ ├── container │ │ ├── container_runner.go │ │ └── container_runner_test.go │ ├── fakes │ │ └── fake_storer_client.go │ ├── runner.go │ ├── storage.go │ ├── storer │ │ └── storer.go │ └── tar │ ├── tar.go │ ├── tar_test.go │ └── testdata │ └── test.tar.gz └── tests └── integration ├── init_test.go └── plugin_store_test.go 18 directories, 29 files What are we looking at? We have some standard packages, like pkg, cmd and tests. What’s “new” is pkg/providers. I ended up not using archiver, but I left it in for prosperity. There are 3 interfaces under providers. Each support a simple functionality. Let’s go over them.\n// Archiver can extract files from an archive. type Archiver interface { Untar(content []byte) ([]byte, error) } My initial plan was to implement the bare metal as an ability to download an archive and then untar that. But I scrapped that idea for a simpler one. This provider would have been an untarer.\nNext up is storage.\n// ListOpts defines options for listing plugins. type ListOpts struct { TypeFilter string } // Storer can store information about the plugins that were created. //go:generate go run github.com/maxbrunsfeld/counterfeiter/v6 -generate //counterfeiter:generate -o fakes/fake_storer_client.go . Storer type Storer interface { Init() error Create(ctx context.Context, plugin *models.Plugin) error Get(ctx context.Context, name string) (*models.Plugin, error) Delete(ctx context.Context, name string) error List(ctx context.Context, opts ListOpts) ([]*models.Plugin, error) } A simple CRUD interface, with an Init action. Whatever that init is. Currently, I’m using sqlite3, so the live store init is simply creating the database file and bootstrapping it with the plugins table. I’m using counterfeiter to generate a mock which I’ll be using in tests to mock this provider where I don’t care about it.\nAnd the runner…\n// Runner runs a plugin. type Runner interface { Run(ctx context.Context, name string, args []string) error } This is the single method a runner needs to be able to provide / do. A runner simply takes a name and some arguments and based on the plugin’s type, runs it.\nThese interfaces are then implemented by real providers. For example, the storage has its implementation under storer. Which has code for sqlite. The runner has two implementations. One for container and one for bare metal. And now, let’s see how the chain works.\nDependency Injection and Usage Take a closer look at the container implementation for example.\n// Config defines parameters for the Runner. type Config struct { DefaultMaximumCommandRuntime int } // Dependencies defines the provider dependencies this provider has. type Dependencies struct { Next providers.Runner Storer providers.Storer Logger zerolog.Logger } // Runner implements the Run interface for container based runtimes. type Runner struct { Config Dependencies cli client.APIClient } // NewRunner creates a new container based runtime. func NewRunner(cfg Config, deps Dependencies) (*Runner, error) { cli, err := client.NewClientWithOpts(client.FromEnv) if err != nil { deps.Logger.Debug().Err(err).Msg(\"Failed to create docker client.\") return nil, err } return \u0026Runner{ Config: cfg, Dependencies: deps, cli: cli, }, nil } This is the main structure of a provider. It gets Configuration options via the Config struct. Things like, DefaultMaximumCommandRuntime which is a configuration value for maximum wait time. And it gets dependencies, other providers and third party things, like logger, through the Dependencies struct. We also wire things up that we are going to use later on, like a client for Docker. Later on, in the tests, I can inject a mock for it.\nNotice the field in the Dependencies struct called Next. This is the chain’s first stop. In root.go we wired up next to be the bare metal type plugin like this:\nbarePlugin := bare.NewBareRunner(bare.Config{}, bare.Dependencies{ Logger: log, Storer: store, }) containerPlugin, err := container.NewRunner(container.Config{ DefaultMaximumCommandRuntime: 15, }, container.Dependencies{ Storer: store, Next: barePlugin, Logger: log, }) And then, when calling Run we check the type of the plugin we got, and if we know it, we execute it, if not, we call the Next thing in the chain. Simple.\n// Run implements the container based runtime details, using Docker as an engine. func (cr *Runner) Run(ctx context.Context, name string, args []string) error { // Find the plugin, get the location, find the type, if it's not container, call next. cmd, err := cr.Storer.Get(ctx, name) if err != nil { return fmt.Errorf(\"plugin not found: %w\", err) } if cmd.Type != models.Container { cr.Logger.Info().Msg(\"Unknown plugin type, calling next in line.\") if cr.Next == nil { return fmt.Errorf(\"no next provider configured\") } return cr.Next.Run(ctx, name, args) } if err := cr.runCommand(cmd.Name, cmd.Container.Image, args); err != nil { return fmt.Errorf(\"failed to run command: %w\", err) } return nil } And that’s it! But wait a second. How is this different from just calling the thing? Well, this makes it so that in the actual code, we only have to call the top level element in the chain and call Run on it. A default if you will. By default, our plugins are of container type. This way, you can avoid a type switch for example. Or avoid having implementation choosing logic in the code when deciding what runner to use.\nif err := containerPlugin.Run(context.Background(), runArgs.name, runArgs.args); err != nil { log.Error().Err(err).Msg(\"Failed to run plugin\") os.Exit(1) } I’m just calling containerPlugin’s Run and the rest will just work. With generics coming in 1.18 this will be even more easier to use.\nTestability The great thing about these providers are that they enclose ( you might say, encapsulate ) a single functionality. They provide some kind of behavior to another behavior. Because that behavior is defined by an interface, and the dependency requires an interface, it’s trivial to unit test the actual provider. For example, the storage. You see above, that the storage is defined as Storer providers.Storer. And we already have a fake. So in the tests we can set it up such as:\nfakeStorer := \u0026fakes.FakeStorer{} fakeStorer.GetReturns(\u0026models.Plugin{ ID: 1, Name: \"test\", Type: models.Container, Container: \u0026models.ContainerPlugin{ Image: \"test-image\", }, }, nil) ... r := Runner{ Dependencies: Dependencies{ Storer: fakeStorer, Logger: logger, }, Config: Config{ DefaultMaximumCommandRuntime: 15, }, cli: apiClient, } After that, we can use it to return errors and various bits and pieces to test our actual plugin runner and not care about storage.\nPros and Cons The pros are obvious. Separation, testability, chaining, fallback logic, encapsulated behavior, etc.\nBut what about the cons? The downside could be the following things:\nnaming gets hard and packages can get prolific interfaces will be binding, changing them might result in changing a bunch of implementations some implementations might not use some parameters from the interface if they don’t provide that functionality ( this might be mitigated by a very restrictive interface design ) it’s a bit verbose ( this can be mitigated by not calling it dependencies or passing in a single struct instead of two) wiring up all the dependencies can lead to a long set up function if there are several providers ( this can be mitigated by having defaults and smaller setup functions ) Still, I think the benefits easily out weight these problems. And many other package designs have similar issues.\nOther providers This is just an example. Another couple of examples include:\nfallback authentication; start with Auth0, then SSH, username/password, finally localhost and fail output parsing; what does the struct provide, use that, otherwise, fallback to table github, gitlab, bitbucket handlers chained up and chosen based on url types Conclusions This is it. That’s the provider pattern. It’s a useful little tool in the box to have. With generics, the choosing type will change, but the pattern can adapt to that too. It’s a nice little thing to have. Of course it’s not a solution to all the problems ever. But I’ve been using it for a while now, to good effect.\nThanks for reading,\nGergely.\n",
  "wordCount" : "1767",
  "inLanguage": "en",
  "datePublished": "2021-12-21T01:01:00+01:00",
  "dateModified": "2021-12-21T01:01:00+01:00",
  "author":{
    "@type": "Person",
    "name": "hannibal"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://skarlso.github.io/2021/12/21/providers-pattern/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ramblings of a cloud engineer",
    "logo": {
      "@type": "ImageObject",
      "url": "https://skarlso.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://skarlso.github.io" accesskey="h" title="Ramblings of a cloud engineer (Alt + H)">Ramblings of a cloud engineer</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://skarlso.github.io/posts/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://skarlso.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Providers Pattern
    </h1>
    <div class="post-meta"><span title='2021-12-21 01:01:00 +0100 +0100'>December 21, 2021</span>&nbsp;·&nbsp;hannibal

</div>
  </header> 
  <div class="post-content"><p>Hello Dear readers.</p>
<p>Today, I would like to write about a project design pattern I&rsquo;ve been using successfully over the past years for
various projects. It has many variations and it has some design patterns that are commonly found in the wild, so there
is nothing really special about it.</p>
<p>Let&rsquo;s begin.</p>
<h1 id="providers-pattern">Providers Pattern<a hidden class="anchor" aria-hidden="true" href="#providers-pattern">#</a></h1>
<p>What is this pattern anyways? It&rsquo;s a pattern I learned while working at <a href="https://www.arangodb.com/">ArangoDB</a>. It&rsquo;s
quite nice and defines package abstractions wonderfully. It somewhat resembles the Repository pattern from DDD and also
uses Chain of Responsibility to setup multiple providers for a given functionality. Like a fallback, in case a Provider
does not understand the current thing it got. In that case, it will delegate to <code>Next</code>.</p>
<p>I&rsquo;m going to demonstrate all of the pattern&rsquo;s capabilities through a sample project which is hopefully a sensible thing
and not just dummy functionality.</p>
<h2 id="tldr">TL;DR<a hidden class="anchor" aria-hidden="true" href="#tldr">#</a></h2>
<p>A Provider is like the <a href="https://martinfowler.com/eaaCatalog/repository.html">Repository pattern</a> from DDD combined with
<a href="https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern">Chain Of Responsibility</a>. Basically, set up a Provider
using an <code>interface</code> as a definition. Give that as dependency to another provider and call it&rsquo;s function. If the
Provider doesn&rsquo;t understand the type its supposed to work on, it will call <code>Next</code> in the chain delegating the function
to the following Provider. For a detailed use of this pattern, check out
<a href="https://github.com/Skarlso/providers-example">Providers Example</a> project on GitHub.</p>
<h2 id="the-project">The Project<a hidden class="anchor" aria-hidden="true" href="#the-project">#</a></h2>
<p><a href="https://github.com/Skarlso/providers-example">Providers Example</a> is the project I&rsquo;ll be using to demonstrate this
pattern. It&rsquo;s pretty simple; yet, I hope, it presents a useful function to be show off this pattern&rsquo;s capabilities.</p>
<p>In essence, this is a plugin executor. We have a CLI which can register plugins to execute. These plugins can either be
bare metal (as in a simple executable living somewhere), or a docker container, in which case it will use Docker to
execute the plugin. It will forward all possible parameters and display any outputs.</p>
<p>Simple, yet there are a couple things that we can extract into Providers such as:</p>
<ol>
<li><del>Dealing with the archive ( so we can test the Tar function )</del> (sorry, I scrapped this, to keep things simple)</li>
<li>Selecting the executing environment ( bare metal, container ) which we can chain</li>
<li>Output formatting ( possibly, thing like, JSON, Table, etc. )</li>
<li>Saving things into a Database ( we will save what kind of plugins exist using sqlite )
4.1. We&rsquo;ll just save the name and the type for simplicity</li>
</ol>
<h2 id="basics">Basics<a hidden class="anchor" aria-hidden="true" href="#basics">#</a></h2>
<p>Let&rsquo;s take a look at the folder structure here.</p>
<pre tabindex="0"><code>➜  providers-example git:(main) tree
.
├── LICENSE
├── Makefile
├── README.md
├── bin
├── cmd
│   ├── add.go
│   ├── list.go
│   ├── remove.go
│   ├── root.go
│   └── run.go
├── example
│   └── echo_plugin
│       └── Dockerfile
├── go.mod
├── go.sum
├── main.go
├── pkg
│   ├── commands
│   │   └── add.go
│   ├── models
│   │   └── plugin.go
│   └── providers
│       ├── archiver.go
│       ├── bare
│       │   └── bare_runner.go
│       ├── container
│       │   ├── container_runner.go
│       │   └── container_runner_test.go
│       ├── fakes
│       │   └── fake_storer_client.go
│       ├── runner.go
│       ├── storage.go
│       ├── storer
│       │   └── storer.go
│       └── tar
│           ├── tar.go
│           ├── tar_test.go
│           └── testdata
│               └── test.tar.gz
└── tests
    └── integration
        ├── init_test.go
        └── plugin_store_test.go

18 directories, 29 files
</code></pre><p>What are we looking at? We have some standard packages, like <code>pkg</code>, <code>cmd</code> and <code>tests</code>. What&rsquo;s &ldquo;new&rdquo; is <code>pkg/providers</code>.
I ended up not using archiver, but I left it in for prosperity. There are 3 interfaces under <code>providers</code>. Each support
a simple functionality. Let&rsquo;s go over them.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Archiver can extract files from an archive.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Archiver</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Untar</span>(<span style="color:#a6e22e">content</span> []<span style="color:#66d9ef">byte</span>) ([]<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>My initial plan was to implement the bare metal as an ability to download an archive and then untar that. But I scrapped
that idea for a simpler one. This provider would have been an <code>untarer</code>.</p>
<p>Next up is storage.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// ListOpts defines options for listing plugins.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ListOpts</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">TypeFilter</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Storer can store information about the plugins that were created.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//go:generate go run github.com/maxbrunsfeld/counterfeiter/v6 -generate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//counterfeiter:generate -o fakes/fake_storer_client.go . Storer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Storer</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Init</span>() <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Create</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">plugin</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">models</span>.<span style="color:#a6e22e">Plugin</span>) <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">models</span>.<span style="color:#a6e22e">Plugin</span>, <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Delete</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">List</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">opts</span> <span style="color:#a6e22e">ListOpts</span>) ([]<span style="color:#f92672">*</span><span style="color:#a6e22e">models</span>.<span style="color:#a6e22e">Plugin</span>, <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>A simple CRUD interface, with an Init action. Whatever that init is. Currently, I&rsquo;m using sqlite3, so the live store init
is simply creating the database file and bootstrapping it with the <code>plugins</code> table. I&rsquo;m using counterfeiter to generate
a mock which I&rsquo;ll be using in tests to mock this provider where I don&rsquo;t care about it.</p>
<p>And the runner&hellip;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Runner runs a plugin.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Runner</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">args</span> []<span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is the single method a runner needs to be able to provide / do. A runner simply takes a name and some arguments
and based on the plugin&rsquo;s type, runs it.</p>
<p>These interfaces are then implemented by real providers. For example, the storage has its implementation under <code>storer</code>.
Which has code for sqlite. The runner has two implementations. One for container and one for bare metal. And now, let&rsquo;s
see how the chain works.</p>
<h2 id="dependency-injection-and-usage">Dependency Injection and Usage<a hidden class="anchor" aria-hidden="true" href="#dependency-injection-and-usage">#</a></h2>
<p>Take a closer look at the container implementation for example.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Config defines parameters for the Runner.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Config</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">DefaultMaximumCommandRuntime</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Dependencies defines the provider dependencies this provider has.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Dependencies</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Next</span>   <span style="color:#a6e22e">providers</span>.<span style="color:#a6e22e">Runner</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Storer</span> <span style="color:#a6e22e">providers</span>.<span style="color:#a6e22e">Storer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Logger</span> <span style="color:#a6e22e">zerolog</span>.<span style="color:#a6e22e">Logger</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Runner implements the Run interface for container based runtimes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Runner</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Config</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Dependencies</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cli</span>    <span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">APIClient</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// NewRunner creates a new container based runtime.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewRunner</span>(<span style="color:#a6e22e">cfg</span> <span style="color:#a6e22e">Config</span>, <span style="color:#a6e22e">deps</span> <span style="color:#a6e22e">Dependencies</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">Runner</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cli</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">NewClientWithOpts</span>(<span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">FromEnv</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">deps</span>.<span style="color:#a6e22e">Logger</span>.<span style="color:#a6e22e">Debug</span>().<span style="color:#a6e22e">Err</span>(<span style="color:#a6e22e">err</span>).<span style="color:#a6e22e">Msg</span>(<span style="color:#e6db74">&#34;Failed to create docker client.&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Runner</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Config</span>:       <span style="color:#a6e22e">cfg</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Dependencies</span>: <span style="color:#a6e22e">deps</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">cli</span>:          <span style="color:#a6e22e">cli</span>,
</span></span><span style="display:flex;"><span>	}, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is the main structure of a provider. It gets Configuration options via the <code>Config</code> struct. Things like,
<code>DefaultMaximumCommandRuntime</code> which is a configuration value for maximum wait time. And it gets dependencies, other
providers and third party things, like logger, through the <code>Dependencies</code> struct. We also wire things up that we are
going to use later on, like a client for Docker. Later on, in the tests, I can inject a mock for it.</p>
<p>Notice the field in the <code>Dependencies</code> struct called <code>Next</code>. This is the chain&rsquo;s first stop. In <code>root.go</code> we wired up
next to be the bare metal type plugin like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">barePlugin</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bare</span>.<span style="color:#a6e22e">NewBareRunner</span>(<span style="color:#a6e22e">bare</span>.<span style="color:#a6e22e">Config</span>{}, <span style="color:#a6e22e">bare</span>.<span style="color:#a6e22e">Dependencies</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Logger</span>: <span style="color:#a6e22e">log</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Storer</span>: <span style="color:#a6e22e">store</span>,
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">containerPlugin</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">container</span>.<span style="color:#a6e22e">NewRunner</span>(<span style="color:#a6e22e">container</span>.<span style="color:#a6e22e">Config</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">DefaultMaximumCommandRuntime</span>: <span style="color:#ae81ff">15</span>,
</span></span><span style="display:flex;"><span>	}, <span style="color:#a6e22e">container</span>.<span style="color:#a6e22e">Dependencies</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Storer</span>: <span style="color:#a6e22e">store</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Next</span>:   <span style="color:#a6e22e">barePlugin</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Logger</span>: <span style="color:#a6e22e">log</span>,
</span></span><span style="display:flex;"><span>	})
</span></span></code></pre></div><p>And then, when calling <code>Run</code> we check the type of the plugin we got, and if we know it, we execute it, if not, we call
the <code>Next</code> thing in the chain. Simple.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Run implements the container based runtime details, using Docker as an engine.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cr</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Runner</span>) <span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">args</span> []<span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Find the plugin, get the location, find the type, if it&#39;s not container, call next.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">cmd</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cr</span>.<span style="color:#a6e22e">Storer</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">name</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;plugin not found: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cmd</span>.<span style="color:#a6e22e">Type</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">models</span>.<span style="color:#a6e22e">Container</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">cr</span>.<span style="color:#a6e22e">Logger</span>.<span style="color:#a6e22e">Info</span>().<span style="color:#a6e22e">Msg</span>(<span style="color:#e6db74">&#34;Unknown plugin type, calling next in line.&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cr</span>.<span style="color:#a6e22e">Next</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;no next provider configured&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cr</span>.<span style="color:#a6e22e">Next</span>.<span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">args</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cr</span>.<span style="color:#a6e22e">runCommand</span>(<span style="color:#a6e22e">cmd</span>.<span style="color:#a6e22e">Name</span>, <span style="color:#a6e22e">cmd</span>.<span style="color:#a6e22e">Container</span>.<span style="color:#a6e22e">Image</span>, <span style="color:#a6e22e">args</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;failed to run command: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And that&rsquo;s it! But wait a second. How is this different from just calling the thing? Well, this makes it so that in the
actual code, we only have to call the top level element in the chain and call <code>Run</code> on it. A default if you will.
By default, our plugins are of <code>container</code> type. This way, you can avoid a type switch for example. Or avoid having
implementation choosing logic in the code when deciding what runner to use.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">containerPlugin</span>.<span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>(), <span style="color:#a6e22e">runArgs</span>.<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">runArgs</span>.<span style="color:#a6e22e">args</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Error</span>().<span style="color:#a6e22e">Err</span>(<span style="color:#a6e22e">err</span>).<span style="color:#a6e22e">Msg</span>(<span style="color:#e6db74">&#34;Failed to run plugin&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Exit</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>I&rsquo;m just calling <code>containerPlugin</code>&rsquo;s Run and the rest will just work. With generics coming in 1.18 this will be even
more easier to use.</p>
<h2 id="testability">Testability<a hidden class="anchor" aria-hidden="true" href="#testability">#</a></h2>
<p>The great thing about these providers are that they enclose ( you might say, encapsulate ) a single functionality. They
provide some kind of behavior to another behavior. Because that behavior is defined by an interface, and the dependency
requires an interface, it&rsquo;s trivial to unit test the actual provider. For example, the storage. You see above, that the
storage is defined as <code>Storer providers.Storer</code>. And we already have a fake. So in the tests we can set it up such as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>    <span style="color:#a6e22e">fakeStorer</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fakes</span>.<span style="color:#a6e22e">FakeStorer</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fakeStorer</span>.<span style="color:#a6e22e">GetReturns</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">models</span>.<span style="color:#a6e22e">Plugin</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ID</span>:   <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Name</span>: <span style="color:#e6db74">&#34;test&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Type</span>: <span style="color:#a6e22e">models</span>.<span style="color:#a6e22e">Container</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Container</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">models</span>.<span style="color:#a6e22e">ContainerPlugin</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Image</span>: <span style="color:#e6db74">&#34;test-image&#34;</span>,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    }, <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Runner</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Dependencies</span>: <span style="color:#a6e22e">Dependencies</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">Storer</span>: <span style="color:#a6e22e">fakeStorer</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">Logger</span>: <span style="color:#a6e22e">logger</span>,
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Config</span>: <span style="color:#a6e22e">Config</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">DefaultMaximumCommandRuntime</span>: <span style="color:#ae81ff">15</span>,
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">cli</span>: <span style="color:#a6e22e">apiClient</span>,
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>After that, we can use it to return errors and various bits and pieces to test our actual plugin runner and not care
about storage.</p>
<h2 id="pros-and-cons">Pros and Cons<a hidden class="anchor" aria-hidden="true" href="#pros-and-cons">#</a></h2>
<p>The pros are obvious. Separation, testability, chaining, fallback logic, encapsulated behavior, etc.</p>
<p>But what about the cons? The downside could be the following things:</p>
<ul>
<li>naming gets hard and packages can get prolific</li>
<li>interfaces will be binding, changing them might result in changing a bunch of implementations</li>
<li>some implementations might not use some parameters from the interface if they don&rsquo;t provide that functionality ( this
might be mitigated by a very restrictive interface design )</li>
<li>it&rsquo;s a bit verbose ( this can be mitigated by not calling it dependencies or passing in a single struct instead of two)</li>
<li>wiring up all the dependencies can lead to a long set up function if there are several providers ( this can be
mitigated by having defaults and smaller setup functions )</li>
</ul>
<p>Still, I think the benefits easily out weight these problems. And many other package designs have similar issues.</p>
<h2 id="other-providers">Other providers<a hidden class="anchor" aria-hidden="true" href="#other-providers">#</a></h2>
<p>This is just an example. Another couple of examples include:</p>
<ul>
<li>fallback authentication; start with Auth0, then SSH, username/password, finally localhost and fail</li>
<li>output parsing; what does the struct provide, use that, otherwise, fallback to table</li>
<li>github, gitlab, bitbucket handlers chained up and chosen based on url types</li>
</ul>
<h2 id="conclusions">Conclusions<a hidden class="anchor" aria-hidden="true" href="#conclusions">#</a></h2>
<p>This is it. That&rsquo;s the provider pattern. It&rsquo;s a useful little tool in the box to have. With generics, the choosing type
will change, but the pattern can adapt to that too. It&rsquo;s a nice little thing to have. Of course it&rsquo;s not a solution to
all the problems ever. But I&rsquo;ve been using it for a while now, to good effect.</p>
<p>Thanks for reading,</p>
<p>Gergely.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://skarlso.github.io">Ramblings of a cloud engineer</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
